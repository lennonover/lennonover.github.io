<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一丿口石砳磊">
<meta property="og:type" content="website">
<meta property="og:title" content="lennonover">
<meta property="og:url" content="https://github.com/lennonover/page/6/index.html">
<meta property="og:site_name" content="lennonover">
<meta property="og:description" content="一丿口石砳磊">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lennonover">
<meta name="twitter:description" content="一丿口石砳磊">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/lennonover/page/6/"/>





  <title> lennonover </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lennonover</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2017/01/21/JS原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/21/JS原型链/" itemprop="url">
                  JS 原型链
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-21T20:23:20+08:00">
                2017-01-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>由Function创造出来的函数 eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>系统内置的函数对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>,<span class="built_in">Object</span>,<span class="built_in">Array</span>,<span class="built_in">String</span>,<span class="built_in">Number</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有函数对象才有 prototype 属性</p>
</blockquote>
<blockquote>
<p>引用类型值：指的是那些保存在堆内存中的对象，意思是，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象,那么数组,普通对象,函数对象都算是引用数据类型,引用数据类型范围包含函数对象的范围</p>
</blockquote>
<h2 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h2><p>函数对象之外的对象都是普通对象</p>
<blockquote>
<p>基本类型值：指的是保存在栈内存中的简单数据段；除开函数对象之外的对象都是普通对象,那么普通对象范围是包含基本数据类型的</p>
</blockquote>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>prototype属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>对象 <code>a</code> 是由<code>Function</code>创造出来,是函数对象,<code>a</code> 就有了<code>prototype</code>属性.那么这个原型对象是怎么创造出来的呢?<br>来看下面这个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> a();</span><br><span class="line">a.prototype = temp;</span><br></pre></td></tr></table></figure>
<p>a的prototype属性就是这样创造出来的</p>
<h2 id="指针proto"><a href="#指针proto" class="headerlink" title="指针proto"></a>指针<strong>proto</strong></h2><p>所有的对象obj都具有proto属性(null和undefined除外),而且指向创造obj对象的函数对象的prototype属性 eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype.__proto__===<span class="built_in">Object</span>.prototype); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__===<span class="built_in">Function</span>.prototype); <span class="comment">//true 指向创造obj对象的函数对象的prototype属性</span></span><br></pre></td></tr></table></figure>
<p>eg :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JavaScript的世界中，所有的函数都能作为构造函数，构造出一个对象</span></span><br><span class="line"><span class="comment">// 下面我给自己构造一个女神做对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NvShen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">"Alice"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在我设置NvShen这个函数的prototype属性</span></span><br><span class="line"><span class="comment">// 一般来说直接用匿名的对象就行，我这里是为了方便理解，</span></span><br><span class="line"><span class="comment">// 先定义一个hand对象再把hand赋值给NvShen的prototype</span></span><br><span class="line"><span class="keyword">var</span> hand = &#123;</span><br><span class="line"> whichOne: <span class="string">"right hand"</span>,</span><br><span class="line"> someFunction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"not safe for work."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">NvShen.prototype = hand;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候，我们可以用NvShen作为构造函数，构造出myObject对象</span></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> NvShen();</span><br><span class="line"><span class="built_in">console</span>.log(myObject.__proto__ === NvShen.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>我们构建了一个对象myObject，而myObject的原型是hand对象，而刚好myObject的构造函数NvShen()的prototype属性也指向hand对象。现在我们知道，prototype与<strong>proto</strong>的关系就是：你的<strong>proto</strong>来自你构造函数的prototype<br>hand.<strong>proto</strong> 指向的是Object.prototype</p>
<blockquote>
<p>思考：var obj={}; obj.prototype.<strong>proto</strong>指向谁__?</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">这里分步思考:</span><br><span class="line"><span class="number">1</span>, obj是是一个普通对象</span><br><span class="line"><span class="number">2</span>, 什么类型的对象是由prototype属性的?当然是函数对象</span><br><span class="line"><span class="number">3</span>, 所以obj是没有prototype属性的</span><br><span class="line"><span class="number">4</span>, 所以obj.prototype===<span class="literal">undefined</span></span><br><span class="line"><span class="number">5</span>, 所以此题的最终问题是:<span class="literal">undefined</span>.proto指向什么</span><br><span class="line"><span class="number">6</span>, 所有的对象obj都具有proto属性(<span class="literal">null</span>和<span class="literal">undefined</span>除外)!所以答案是 js报错</span><br><span class="line"><span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 构造器constructor</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">constructor 属性返回对创建此对象的函数对象的引用。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.constructor===<span class="built_in">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.prototype.constructor===a); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>函数a是由Function创造出来,那么它的constructor指向的Function,<br>a.prototype是由new a()方式创造出来,那么a.prototype.constructor理应指向a</p>
<blockquote>
<p>思考:a.prototype.<strong>proto</strong>.constructor指向谁__?</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这里继续分解题目:</span><br><span class="line"><span class="number">1</span>, a.prototype指向a的一个实例,我们已经多次强调了,而且属于普通对象</span><br><span class="line"><span class="number">2</span>, __proto__定义为:指向创造obj对象的函数对象的prototype属性,所以看下谁创造了a.prototype,因为a.prototype是普通对象,类型为object,那么是<span class="built_in">Object</span>创造了它,</span><br><span class="line"><span class="number">3</span>, 那么显而易见a.prototype.__proto__指向了<span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="number">4</span>, 那么题目简化为<span class="built_in">Object</span>.prototype.constructor指向谁</span><br><span class="line"><span class="number">5</span>, 继续分解题目,<span class="built_in">Object</span>.prototype为基本对象,那么就是<span class="built_in">Object</span>创造了它,那么它的<span class="keyword">constructor</span>就指向了Object</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.constructor===<span class="built_in">Object</span> <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__===<span class="literal">null</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个<strong>proto</strong>的内置属性，用于指向创建它的函数对象的原型对象prototype。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.__proto__ === person.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>同样，person.prototype对象也有<strong>proto</strong>属性，它指向创建它的函数对象（Object）的prototype</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>继续，Object.prototype对象也有<strong>proto</strong>属性，但它比较特殊，为null</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<p>我们把这个有<strong>proto</strong>串起来的直到Object.prototype.<strong>proto</strong>为null的链叫做原型链。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2017/01/07/CSS之absolute/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/07/CSS之absolute/" itemprop="url">
                  CSS之absolute
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-07T19:15:00+08:00">
                2017-01-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于absolute"><a href="#关于absolute" class="headerlink" title="关于absolute"></a>关于absolute</h2><blockquote>
<p>来自张鑫旭老师</p>
</blockquote>
<ul>
<li>脱离文档流</li>
<li>去浮动</li>
<li>超越overflow</li>
</ul>
<p>绝对定位和浮动有相似性，同样具有浮动的包裹性和破坏性。一旦给元素加上absolute或float就相当于给元素加上了display:block。</p>
<p>设置为绝对定位的元素框从文档流完全删除并去浮动也不瘦overflow控制，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。<br>绝对定位使元素的位置与文档流无关，因此不占据空间。</p>
<h2 id="如何确定定位点"><a href="#如何确定定位点" class="headerlink" title="如何确定定位点"></a>如何确定定位点</h2><ul>
<li>第一种情况</li>
</ul>
<p>用户只给元素指定了absolute，未指定left/top/right/bottom。此时absolute元素的左上角定位点位置就是该元素<code>正常文档流</code>里的位置（也就是位置跟随）。</p>
<ul>
<li>第二种情况</li>
</ul>
<p>用户给absolute元素指定了left/right，top/bottom。位置是absolute元素没有position:static以外的父元素。<br>设置值得是相对没有position:static以外的父元素定位，没有设置值得还是在正常文档流中。</p>
<h2 id="无依赖的绝对定位实战"><a href="#无依赖的绝对定位实战" class="headerlink" title="无依赖的绝对定位实战"></a>无依赖的绝对定位实战</h2><p>优点对父级无依赖，自适应好</p>
<ul>
<li>图片图表定位</li>
</ul>
<p>利用跟随性实现</p>
<iframe width="100%" height="300" src="//jsfiddle.net/lennonover/mzx6qc2r/embedded/html,css,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<ul>
<li>边缘定位</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"course-fixed-x"</span>&gt;</span></span><br><span class="line">    &amp;nbsp;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"course-fixed"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.imooc.com/activity/diaocha"</span> <span class="attr">class</span>=<span class="string">"goto_top_diaocha"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.imooc.com/mobile/app"</span> <span class="attr">class</span>=<span class="string">"goto_top_app"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.imooc.com/user/feedback"</span> <span class="attr">class</span>=<span class="string">"goto_top_feed"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.course-fixed-x</span> &#123; <span class="attribute">height</span>: <span class="number">0</span>;  <span class="attribute">text-align</span>:right; <span class="attribute">overflow</span>: hidden; &#125;</span><br><span class="line"><span class="selector-class">.course-fixed</span> &#123; <span class="attribute">display</span>: inline; <span class="attribute">position</span>: fixed; <span class="attribute">margin-left</span>: <span class="number">20px</span>; <span class="attribute">bottom</span>: <span class="number">100px</span>; &#125;</span><br></pre></td></tr></table></figure>
<iframe width="100%" height="300" src="//jsfiddle.net/lennonover/L6j0svgr/embedded/html,css,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2017/01/01/CSS之float/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/01/CSS之float/" itemprop="url">
                  CSS之float
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T18:25:17+08:00">
                2017-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="浮动的原始作用"><a href="#浮动的原始作用" class="headerlink" title="浮动的原始作用"></a>浮动的原始作用</h2><blockquote>
<p>来自张鑫旭老师</p>
</blockquote>
<p>实现文字环绕图片</p>
<p>特性  </p>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/17-1-1/18915576-file_1483272315295_15747.png" alt=""></p>
<p>本质定义为包裹与破坏。</p>
<ul>
<li>包裹性</li>
</ul>
<p>例如按钮宽度自适应，按钮要自动包裹在文字的外面。我们用什么方法实现呢？一就是display:inline-block；二就是float。</p>
<ul>
<li>破坏性</li>
</ul>
<p>文字之所以会环绕含有float属性的图片时因为浮动破坏了正常的line boxes。<br>脱离文档流，父元素感受不到子元素，也就没了高度。</p>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><ul>
<li>clear</li>
</ul>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/17-1-1/84516968-file_1483271906445_14f39.png" alt=""><br><img src="http://ob6nlbpso.bkt.clouddn.com/17-1-1/28721104-file_1483272033640_f4b2.png" alt=""></p>
<ul>
<li>BFC</li>
</ul>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/17-1-1/11863236-file_1483271975963_16541.png" alt=""><br><img src="http://ob6nlbpso.bkt.clouddn.com/17-1-1/63092528-file_1483272033530_381d.png" alt=""></p>
<p>兼容性</p>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/17-1-1/82732728-file_1483272086314_3785.png" alt=""></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><img src="http://ob6nlbpso.bkt.clouddn.com/17-1-1/34179867-file_1483272176105_b73a.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2016/12/30/CSS之vertical-align/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/30/CSS之vertical-align/" itemprop="url">
                  CSS之vertical-align
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-30T20:05:52+08:00">
                2016-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于vertical-align"><a href="#关于vertical-align" class="headerlink" title="关于vertical-align"></a>关于vertical-align</h2><blockquote>
<p>来自张鑫旭老师</p>
</blockquote>
<p>vertical-align 属性设置元素的垂直对齐方式。<br>vertical-align属性的值有baseline、sub、super、top、text-top、middle、bottom、text-bottom等，其中初始值为baseline。</p>
<p>支持四大类</p>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/sp161230_202002.png" alt=""></p>
<blockquote>
<p>注：vertical-align的数值百分比是根据line-height计算的</p>
</blockquote>
<ul>
<li><p>baseline(基线)——将子元素的基线与父元素的基线相对齐。对于没有基线的元素，如图像或对象，则使它的底部与父元素的基线对齐。ppps：内联元素是基线对齐，文本的基线一般是<code>X</code>的下边缘。</p>
</li>
<li><p>top(顶部)——使元素的顶部与行中最高事物的顶部相对齐。</p>
</li>
<li><p>middle(中间)——使元素垂直居中。</p>
</li>
<li><p>bottom(底部)——使元素的底部与行中最低事物的底部相对齐。</p>
</li>
<li><p>text-top(文本顶部)——使元素的顶部与其父元素最高字母的顶部相对齐。</p>
</li>
<li><p>text-bottom(文本底部)——使元素的底部与其父元素字体的底部相对齐。</p>
</li>
<li><p>sub(下面)——把元素置于下方(下标)，确切地说是使元素的基线对齐它的父元素首选的下标位置。</p>
</li>
<li><p>super(上面)——把元素置于上方(上标)，确切地说是使元素的基线对齐它的父元素首选的上标位置。</p>
</li>
</ul>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/sp170101_165106.png" alt=""></p>
<h2 id="vertical-align起作用的前提条件"><a href="#vertical-align起作用的前提条件" class="headerlink" title="vertical-align起作用的前提条件"></a>vertical-align起作用的前提条件</h2><p>符合以下条件</p>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/sp161230_202811.png" alt=""><br><img src="http://ob6nlbpso.bkt.clouddn.com/sp161230_202901.png" alt=""></p>
<blockquote>
<p>table-call只作用于自身</p>
</blockquote>
<ul>
<li><p>直接display设置<br>  display</p>
</li>
<li><p>css声明更改元素显示水平<br>  float、position</p>
</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><iframe width="100%" height="600" src="//jsfiddle.net/lennonover/j5unucec/embedded/html,css,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2016/12/29/CSS之line-height/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/29/CSS之line-height/" itemprop="url">
                  CSS之line-height
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-29T21:15:04+08:00">
                2016-12-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于行高"><a href="#关于行高" class="headerlink" title="关于行高"></a>关于行高</h2><blockquote>
<p>来自张鑫旭老师</p>
</blockquote>
<p>语法： line-height : normal |&lt;实数&gt; | &lt;长度&gt; | &lt;百分比&gt; | inherit<br>说明：设置元素中行的高度。<br>值： normal：默认行高，一般为1到1.2；<br><img src="http://ww2.sinaimg.cn/large/c15a9505gw1fb80s9srh4j214c0ijmze.jpg" alt="normal"><br><img src="http://ob6nlbpso.bkt.clouddn.com/sp161230_180949.png" alt="normal"><br>实数：实数值，缩放因子；<br>长度：合法的长度值，可为负数；<br><img src="http://ob6nlbpso.bkt.clouddn.com/sp161230_180903.png" alt="length"><br><img src="http://ob6nlbpso.bkt.clouddn.com/sp161229_222443.png" alt=""><br>百分比：百分比取值基于元素的字体尺寸。<br><img src="http://ob6nlbpso.bkt.clouddn.com/sp161230_180923.png" alt="%"><br>初始值： normal<br>继承性：继承<br>适用于：所有元素        </p>
<h2 id="行内框盒子模型"><a href="#行内框盒子模型" class="headerlink" title="行内框盒子模型"></a>行内框盒子模型</h2><p>所有内敛元素的表现都和行内框盒子模型</p>
<ul>
<li>内容区域（content area）</li>
</ul>
<p>是一种围绕文字看不见的的盒子，大小和字体大小有关。</p>
<p><img src="http://ww2.sinaimg.cn/large/c15a9505gw1fb7zns673ej210e0240t1.jpg" alt="内容区域"></p>
<ul>
<li>内联盒子（inline boxes）</li>
</ul>
<p>让内容排成一排显示，包含inline属性的都是，如果只是文字属于匿名内联盒子</p>
<p><img src="http://ww4.sinaimg.cn/large/c15a9505gw1fb7ztmap7ij210h02egm7.jpg" alt="内联盒子"></p>
<ul>
<li>行框盒子（line boxes）</li>
</ul>
<p>每一行都是行框盒子，每个行框盒子都是由一个个内联盒子组成</p>
<p><img src="http://ww4.sinaimg.cn/large/c15a9505gw1fb7zwz3lixj210d02cgm1.jpg" alt="行框盒子"></p>
<ul>
<li>包含盒子（containing box）</li>
</ul>
<p>由一行行行框盒子组成</p>
<p><img src="http://ww3.sinaimg.cn/large/c15a9505gw1fb7zze6n4fj20zj02ewf1.jpg" alt="包含盒子"></p>
<p>包含盒子包含行框盒子，行框盒子包含内联盒子</p>
<h2 id="line-height的机制原理"><a href="#line-height的机制原理" class="headerlink" title="line-height的机制原理"></a>line-height的机制原理</h2><p>有一个空的div，如果没有设置至少大于1像素高度height值时，该div的高度就是个0。如果该div里面打入了一个空格或是文字，则此div就会有一个高度。</p>
<p>这是个看上去很简单的问题，是理解line-height非常重要的一个问题。可能有人会跟认为是：文字撑开的！文字占据空间，自然将div撑开。我一开始也是这样理解的，但是事实上根本不是文字撑开了div的高度，而是line-height！</p>
<p>高度的表现不是行高，而是内容区域和行间距之和。</p>
<p><img src="http://ww4.sinaimg.cn/large/c15a9505gw1fb8069zl1zj20st06e74y.jpg" alt="line"><br><img src="http://ww4.sinaimg.cn/large/c15a9505gw1fb807s4k58j212t0h3jug.jpg" alt="line"><br><img src="http://ww2.sinaimg.cn/large/c15a9505gw1fb80eqerrqj214b0ljwi7.jpg" alt="line"><br><img src="http://ww3.sinaimg.cn/large/c15a9505gw1fb80ezl5p8j214e0li0wc.jpg" alt="line"><br><img src="http://ww2.sinaimg.cn/large/c15a9505gw1fb80fkfktlj214a0awgnk.jpg" alt="line"></p>
<p>当行框盒子里有多个不同的行高的内联盒子此时行高？</p>
<h2 id="使用经验"><a href="#使用经验" class="headerlink" title="使用经验"></a>使用经验</h2><p><img src="http://ob6nlbpso.bkt.clouddn.com/sp161229_222811.png" alt="body"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2016/12/21/移动端的自适应/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/21/移动端的自适应/" itemprop="url">
                  移动端的自适应
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-21T22:45:04+08:00">
                2016-12-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>完美视口</p>
<p>  在移动端，低端无定制的需求，都可以用这个完美视口完成。</p>
</li>
<li><p>物理像素(physical pixel)</p>
<p>  一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。</p>
</li>
</ul>
<ul>
<li><p>设备独立像素(density-independent pixel)</p>
<p>  设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。同一张图片在各屏幕显示大小不一。<br>  我们希望不同屏幕显示图片的大小要一致。<br>  我们要计算图片缩放比例。</p>
<p>  计算公式：</p>
<p>  图片逻辑像素大小px1 / 图片缩放后实际像素大小px2 = 物理像素（设备像素dp） / 设备独立像素dips</p>
<p>  px2 = px1 * (dp / dips)</p>
<p>  px2 = px1 * dpr</p>
</li>
<li><p>设备像素比(device pixel ratio )</p>
<p>  设备像素比(简称dpr)定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式的得到</p>
<p>  设备像素比 = 物理像素 / 设备独立像素 </p>
<p>  在某一方向上，x方向或者y方向，可以通过window.devicePixelRatio获取到当前设备的dpr</p>
<blockquote>
<p>由于苹果retina的产生，使得清晰度提升，主要是因为<code>设备像素</code>提升了一倍，因此可以用更多像素去绘画更清晰的图像</p>
</blockquote>
<p>  坊间对于dpr更通俗的说法叫</p>
<ul>
<li>一倍屏</li>
<li>两倍屏</li>
<li>三倍屏</li>
</ul>
</li>
<li><p>屏幕拉伸比scale</p>
<p>  也就是视口上的initial-scale , maximum-sacle 等属性</p>
<blockquote>
<p>scale 和 dpr的关系是倒数。</p>
</blockquote>
</li>
<li><p>例子</p>
<p>  以iphone6为例：</p>
<p>  设备宽高为375×667，可以理解为设备独立像素(或css像素)。<br>  dpr为2，根据上面的计算公式，其物理像素就应该×2，为750×1334。</p>
<p>  在不同的屏幕上(普通屏幕 vs retina屏幕)，css像素所呈现的大小(物理尺寸)是一致的，不同的是1个css像素所对应的物理像素个数是不一致的。</p>
<p>  在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。 在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。</p>
</li>
<li><p>位图像素</p>
<p>  一个位图像素是栅格图像(如：png, jpg, gif等)最小的数据单元。每一个位图像素都包含着一些自身的显示信息(如：显示位置，颜色值，透明度等)。</p>
<p>  理论上，1个位图像素对应于1个物理像素，图片才能得到完美清晰的展示。</p>
<p>  在普通屏幕下是没有问题的，但是在retina屏幕下就会出现位图像素点不够，从而导致图片模糊的情况。</p>
</li>
</ul>
<pre><code>对于dpr=2的retina屏幕而言，1个位图像素对应于4个物理像素，由于单个位图像素不可以再进一步分割，所以只能就近取色，从而导致图片模糊(注意上述的几个颜色值)。

所以，对于图片高清问题，比较好的方案就是两倍图片(@2x)。

如：200×300(css pixel)img标签，就需要提供400×600的图片。

如此一来，位图像素点个数就是原来的4倍，在retina屏幕下，位图像素点个数就可以跟物理像素点个数形成 1 : 1的比例，图片自然就清晰了(这也解释了之前留下的一个问题，为啥视觉稿的画布大小要×2？)。

在普通屏幕下，200×300(css pixel)img标签，所对应的物理像素个数就是200×300个，而两倍图片的位图像素个数则是200×300*4，所以就出现一个物理像素点对应4个位图像素点，所以它的取色也只能通过一定的算法(显示结果就是一张只有原图像素总数四分之一，我们称这个过程叫做downsampling)，肉眼看上去虽然图片不会模糊，但是会觉得图片缺少一些锐利度，或者是有点色差(但还是可以接受的)。
</code></pre><h2 id="移动端的问题"><a href="#移动端的问题" class="headerlink" title="移动端的问题"></a>移动端的问题</h2><ul>
<li><p>retina屏幕，图片高清问题</p>
<p>  两倍图片(@2x)，然后图片容器缩小50%。</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">img</span>标签</span><br><span class="line"><span class="selector-tag">width</span>: 200<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 300<span class="selector-tag">px</span>;</span><br><span class="line">背景图片</span><br><span class="line"><span class="selector-tag">width</span>: 200<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 300<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>(<span class="selector-tag">image</span>@<span class="keyword">2x</span>.<span class="keyword">jpg</span>);</span><br><span class="line"><span class="selector-tag">background-size</span>: 200<span class="selector-tag">px</span> 300<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p>缺点普通屏幕下：</p>
<p>同样下载了@2x的图片，造成资源浪费。<br>图片由于downsampling，会失去了一些锐利度(或是色差)。</p>
<p>解决办法是：不同的dpr下，加载不同的尺寸的图片。</p>
<p>这样的话，是不是是要准备两套图片了？</p>
<p>解决；用图片服务器，通过url获取参数，然后可以控制图片质量，也可以将图片裁剪成不同的尺寸。</p>
<ul>
<li><p>retina下，border: 1px问题</p>
<p>  设计师想要的retina下border: 1px;，其实就是1物理像素宽，对于css而言，可以认为是border: 0.5px;，这是retina下(dpr=2)下能显示的最小单位。</p>
<p>  并不是所有手机浏览器都能识别border: 0.5px;，ios7以下，android等其他系统里，0.5px会被当成为0px处理，那么如何实现这0.5px呢</p>
<p>  最简单的一个做法就是这样(元素scale)：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>:<span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>:<span class="built_in">scaleY</span>(.5);</span><br><span class="line">    <span class="attribute">-webkit-transform-origin</span>:<span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但是这样hack实在是不够通用(如：圆角等)，写起来也麻烦。</p>
<p>比较推荐的还是页面scale的方案，是比较通用的，几乎满足所有场景。</p>
<p>对于iphone5(dpr=2)，添加如下的meta标签，设置viewport(scale 0.5)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=640,initial-scale=0.5,maximum-scale=0.5, minimum-scale=0.5,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多屏适配布局问题</li>
</ul>
<pre><code>基于rem的原理,针对不同手机屏幕尺寸和dpr动态的改变根节点html的font-size大小(基准值)。
乘以dpr，是因为页面有可能为了实现1px border页面会缩放(scale) 1/dpr 倍(如果没有，dpr=1),。
</code></pre><p>除以10，是为了取整，方便计算(理论上可以是任何值)</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rem = document.documentElement.clientWidth * dpr / 10</span><br></pre></td></tr></table></figure>

- CSS方式更改

通过设备宽度来媒体查询来改变html的font-size：

- javascript方式更改

通过上面的公式，计算出基准值rem，然后写入样式
</code></pre><ul>
<li><p>字体大小问题</p>
<p>  设置viewpor页面scale，必然会带来字体大小会被缩放。</p>
<p>  针对不同的分辨率(dpr不同)，设置不用的大小。</p>
</li>
</ul>
<h2 id="各大厂解决方案"><a href="#各大厂解决方案" class="headerlink" title="各大厂解决方案"></a>各大厂解决方案</h2><ul>
<li><p>手机淘宝</p>
<ul>
<li>获取手机dpr(window.devicePixelRatio)，动态生成viewport。</li>
<li>换取手机宽度，分成10份，每一份的宽度即是rem的尺寸。</li>
<li>根据设计稿尺寸(px)通过计算，转换成rem去布局。</li>
</ul>
</li>
<li><p>天猫</p>
<ul>
<li>采用scale=1.0 写死viewport。</li>
<li>flex布局，笃定认为布局尺寸是375 (iPhone6)</li>
<li>rem 确定非flex的元素</li>
</ul>
</li>
<li><p>手机携程</p>
<ul>
<li>采用scale=1.0 写死viewport</li>
<li>px + 百分比布局</li>
</ul>
</li>
<li><p>拉钩</p>
<ul>
<li>关键元素高宽和位置都不变，只有容器元素在做伸缩变换。</li>
<li>文字流式，控件弹性，图片等比缩放</li>
</ul>
</li>
</ul>
<h2 id="如何与设计协作"><a href="#如何与设计协作" class="headerlink" title="如何与设计协作"></a>如何与设计协作</h2><ol>
<li><p>视觉设计阶段，设计师按宽度750px（iPhone 6）做设计稿，除图片外所有设计元素用矢量路径来做。设计定稿后在750px的设计稿上做标注，输出标注图。同时等比放大1.5倍生成宽度1125px的设计稿，在1125px的稿子里切图。</p>
</li>
<li><p>输出两个交付物给开发工程师：一个是程序用到的@3x切图资源，另一个是宽度750px的设计标注图。</p>
</li>
<li><p>开发工程师拿到750px标注图和@3x切图资源，完成iPhone 6（375pt）的界面开发。此阶段不能用固定宽度的方式开发界面，得用自动布局（auto layout），方便后续适配到其它尺寸。</p>
</li>
<li><p>适配调试阶段，基于iPhone 6的界面效果，分别向上向下调试iPhone 6 plus（414pt）和iPhone 5S及以下（320pt）的界面效果。由此完成大中小三屏适配。</p>
</li>
</ol>
<h2 id="鞠躬"><a href="#鞠躬" class="headerlink" title="鞠躬"></a>鞠躬</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2016/12/17/CSS解疑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/17/CSS解疑/" itemprop="url">
                  CSS解疑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-17T21:16:04+08:00">
                2016-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-BFC"><a href="#1-BFC" class="headerlink" title="1.BFC"></a>1.BFC</h2><blockquote>
<p>Block-level elements are those elements of the source document that are formatted visually as blocks (e.g., paragraphs). The following values of the ‘display’ property make an element block-level: ‘block’, ‘list-item’, and ‘table’</p>
</blockquote>
<p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。</p>
<p>至少满足下列条件中的任何一个：</p>
<ul>
<li><p>float的值不为none</p>
</li>
<li><p>position的值不为static或者relative</p>
</li>
<li><p>display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个</p>
</li>
<li><p>overflow的值不为visible</p>
</li>
</ul>
<h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><p>在一个块级格式化上下文里，盒子从包含块的顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。毗邻块盒子的垂直外边距折叠只有他们是在同一BFC时才会发生。如果他们属于不同的BFC，他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。</p>
<p>在块级格式化上下文中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘），即使存在浮动也是如此，除非这个盒子创建一个新的块级格式化上下文。</p>
<ul>
<li><p>内部的Box会在垂直方向，一个接一个地放置。</p>
</li>
<li><p>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</p>
</li>
<li><p>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p>
</li>
<li><p>BFC的区域不会与float box重叠。</p>
</li>
<li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>
</li>
<li><p>计算BFC的高度时，浮动元素也参与计算 // 清除浮动</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>
<p>因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</p>
<h2 id="属性继承"><a href="#属性继承" class="headerlink" title="属性继承"></a>属性继承</h2><ul>
<li><p>不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。</p>
</li>
<li><p>所有元素可继承：visibility和cursor。</p>
</li>
<li><p>内联元素可继承(inline)：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。</p>
</li>
<li><p>终端块状元素可继承(inline-block)：text-indent和text-align。</p>
</li>
<li><p>列表元素可继承(block)：list-style、list-style-type、list-style-position、list-style-image。</p>
</li>
<li><p>表格元素可继承：border-collapse。</p>
</li>
</ul>
<h2 id="box"><a href="#box" class="headerlink" title="box"></a>box</h2><ul>
<li><p>W3C的标准Box Model</p>
<p>  /<em>外盒尺寸计算（元素空间尺寸）</em>/<br>  Element空间高度 = content height + padding + border + margin<br>  Element 空间宽度 = content width + padding + border + margin<br>  /<em>内盒尺寸计算（元素大小）</em>/<br>  Element Height = content height + padding + border （Height为内容高度）<br>  Element Width = content width + padding + border （Width为内容宽度）</p>
</li>
</ul>
<ul>
<li><p>IE传统下Box Model</p>
<p>  /<em>外盒尺寸计算（元素空间尺寸）</em>/<br>  Element空间高度 = content Height + margin (Height包含了元素内容宽度，边框宽度，内距宽度)<br>  Element空间宽度 = content Width + margin (Width包含了元素内容宽度、边框宽度、内距宽度)<br>  /<em>内盒尺寸计算（元素大小）</em>/<br>  Element Height = content Height(Height包含了元素内容宽度，边框宽度，内距宽度)<br>  Element Width = content Width(Width包含了元素内容宽度、边框宽度、内距宽度)</p>
</li>
</ul>
<h2 id="box-size"><a href="#box-size" class="headerlink" title="box-size"></a>box-size</h2><pre><code>box-sizing ： content-box || border-box || inherit
</code></pre><ul>
<li>content-box</li>
</ul>
<p>此值为其默认值，其让元素维持W3C的标准Box Model，也就是说元素的宽度/高度（width/height）等于元素边框宽度（border）加上元素内边距（padding）加上元素内容宽度/高度（content width/height）即：Element Width/Height = border+padding+content width/height。</p>
<ul>
<li>border-box</li>
</ul>
<p>此值让元素维持IE传统的Box Model（IE6以下版本），也就是说元素的宽度/高度等于元素内容的宽度/高度。（从上面Box Model介绍可知，我们这里的content width/height包含了元素的border,padding,内容的width/height【此处的内容宽度/高度=width/height-border-padding】）。</p>
<h2 id="border"><a href="#border" class="headerlink" title="border"></a>border</h2><p>边框三角</p>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/17-1-3/35927458-file_1483451513816_13023.png" alt=""></p>
<h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><ul>
<li>滚动条高度</li>
</ul>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/17-1-3/58643265-file_1483456292463_15378.png" alt=""></p>
<ul>
<li>解决出现滚动条后水平方向抖动问题</li>
</ul>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/17-1-3/50929365-file_1483456274449_bb3e.png" alt=""></p>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/17-1-6/66418111-file_1483699900475_6f2c.png" alt="overflow"></p>
<h2 id="去除图片和标签之间的空格"><a href="#去除图片和标签之间的空格" class="headerlink" title="去除图片和标签之间的空格"></a>去除图片和标签之间的空格</h2><p><img src="http://ob6nlbpso.bkt.clouddn.com/sp170107_195326.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2016/12/13/编写高效css/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/13/编写高效css/" itemprop="url">
                  编写高效CSS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-13T22:42:07+08:00">
                2016-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h1><p>对于CSS的优化，网络上分享的确实找不到什么系统的，整理下平时的积累。<br>主要从以下几个方面：</p>
<h2 id="1-CSS架构"><a href="#1-CSS架构" class="headerlink" title="1. CSS架构"></a>1. CSS架构</h2><p> 关于如何处理网站的CSS，各个网站做法都不一样，一般分为reset.css, main.css, content.css，然后每个活动页面一个单独的CSS，也是我最常用的。</p>
<ul>
<li>关于CSS reset</li>
</ul>
<p>CSS reset血多基本上是不需要的，反而增加了页面CSS 的overwrite，有些常用标签我也是会简单重置一下的，而且会避免overwrite（样式重写），以保证样式最精简，渲染最高效。</p>
<ul>
<li>CSS通用样式库</li>
</ul>
<p>CSS通用样式库就是可以在任何网站使用的CSS样式库</p>
<ul>
<li>网站CSS样式库</li>
</ul>
<p>根据当前实际的项目内容指定的。例如，文字链接颜色是什么，文字链接经过的样式是什么；一些常用的背景色样式，常用的边框样式等，以及一些高宽等。按照我的经验，网站CSS样式库又可以架构为以下几部分：</p>
<pre><code>网站常见颜色
网站常见padding属性、margin属性
网站常见width属性、height属性
</code></pre><ul>
<li><p>网站公共结构样式</p>
</li>
<li><p>单页面的精细结构</p>
</li>
</ul>
<h2 id="2-css样式分离"><a href="#2-css样式分离" class="headerlink" title="2. css样式分离"></a>2. css样式分离</h2><p>样式的精简与重用</p>
<p>eg：</p>
<pre><code>.dib{display:inline-block;}
.bdd border:1px solid #ddd;}
.bgf7{background:#f7f7f7;}
.p20_40{padding:20px 40px;}
</code></pre><p>字面上很容易理解，就是把这段样式分离成一个一个单独的样式，这样但是，要实现一个复杂的效果，HTML代码量就是非常庞大，一切都是权衡，何时分离，哪些要分离？样式精简与重用仅仅是通过分离吗。</p>
<p>这类样式库可惜细分“通用库”和“当前项目库”等。</p>
<p>样式的独立拆分，使得各种效果可以自由组合，这是有别于一个class类覆盖多个CSS属性的做法的。样式的独立拆分，精简的CSS文件，每个样式的重用性可谓发挥到的最大，同时，页面的后期维护变得异常轻松，样式冲突的可能性也是非常低的。</p>
<h2 id="3-css命名"><a href="#3-css命名" class="headerlink" title="3. css命名"></a>3. css命名</h2><p>面向属性的命名方法</p>
<p>也就是上面说的分离，分离为什么可以让样式的重用性放大至最大，就是因为分离后样式的命名就是样式本身，针对自身属性的一种命名方式，只会overwrite，不会冲突。</p>
<p>eg：</p>
<pre><code>.tr{text-align:right;}
.pb8{padding-bottom:8px;}
</code></pre><p>限制重用</p>
<p>会使用层级(.test .test1)，会使用标签(ul.test),这样限制越多，越抑制了CSS的重用性</p>
<p>统一前缀</p>
<p>减小类名的长度，间接影响CSS文件大小</p>
<h2 id="4-基于状态类名交互"><a href="#4-基于状态类名交互" class="headerlink" title="4. 基于状态类名交互"></a>4. 基于状态类名交互</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2016/11/05/CSS单位EM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/05/CSS单位EM/" itemprop="url">
                  CSS单位EM和REM
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-05T20:58:56+08:00">
                2016-11-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="em-和-rem"><a href="#em-和-rem" class="headerlink" title="em 和 rem"></a>em 和 rem</h2><p>em和rem是一个相对的大小，我们可以这样来设置1em，0.5em，1.5em等，而且“em”还可以指定到小数点后三位，比如“1.234em”。“相对”的意思是：</p>
<ul>
<li><p>相对的计算必然会一个参考物，那么这里相对所指的是相对于相对于使用em单位的元素的font-size。比如：如果在一个div中设置字体大小为“16px”，此时这个div的后代元素将继承他的字体大小，除非重新在其后代元素中进行过显示的设置。此时，如果你将其子元素的字体大小设置为<code>0.75em</code>，那么其字体大小计算出来后就相当于<code>0.75 X 16px = 12px</code>；</p>
</li>
<li><p>如果用户通过浏览器的UI控件改变了文字的大小，那么我们整个页面也会进行放大（或缩小），不至于用户改变了浏览器的字体后会致使整个页面崩溃。</p>
</li>
</ul>
<p>也就是说em 和 rem都是灵活、 可扩展的单位，由浏览器转换为像素值，具体取决于您的设计中的字体大小设置。 如果你使用值 1em 或 1rem，它可以被浏览器翻译成 从16px到 160px 或其他任意值。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>em 和 rem 单位提供的这种灵活性和工作方式都很相似，所以最大的问题是，我们何时应使用 em 值，何时应使用 rem 值呢</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>em 和 rem 单位之间的区别是浏览器根据谁来转化成px值。</p>
<h3 id="rem-单位如何转换为像素值"><a href="#rem-单位如何转换为像素值" class="headerlink" title="rem 单位如何转换为像素值"></a>rem 单位如何转换为像素值</h3><p>当使用 rem 单位，他们转化为像素大小取决于页根元素的字体大小，即 html 元素的字体大小。 根元素字体大小乘以你 rem 值。<br>例如，根元素的字体大小 16px，10rem 将等同于 160px，即 10 x 16 = 160。</p>
<h3 id="em-单位如何转换为像素值"><a href="#em-单位如何转换为像素值" class="headerlink" title="em 单位如何转换为像素值"></a>em 单位如何转换为像素值</h3><p>当使用em单位时，像素值将是em值乘以使用em单位的元素的字体大小。<br>例如，如果一个 div 有 18px 字体大小，10em 将等同于 180px，即 10 × 18 = 180。</p>
<blockquote>
<p>有一个比较普遍的误解，认为 em 单位是相对于父元素的字体大小。 事实上，根据W3标准 ，它们是相对于使用em单位的元素的字体大小。父元素的字体大小可以影响 em 值，但这种情况的发生，纯粹是因为继承。 让我们看看为什么以及如何起作用。</p>
</blockquote>
<h4 id="em-单位的遗传效果"><a href="#em-单位的遗传效果" class="headerlink" title="em 单位的遗传效果"></a>em 单位的遗传效果</h4><p>使用 em 单位存在继承的时候，情况会变得比较棘手，因为每个元素将自动继承其父元素的字体大小。 继承效果只能被明确的字体单位覆盖，比如px,vw。</p>
<p>使用 em 单位的元素字体大小根据它们来定。 但该元素可能继承其父元素的字体大小，而父元素又继承其父元素的字体大小，等等。 因此，以 em 为单位的元素字体大小可能会受到其任何父元素的字体大小影响。</p>
<h5 id="em-继承的例子"><a href="#em-继承的例子" class="headerlink" title="em 继承的例子"></a>em 继承的例子</h5><p>如果我们的根元素字体大小为 16px (通常是默认值) 一个子元素 div 里面padding值为 1.5em，该 div 将从根元素继承字体大小 16px。 因此padding会翻译成 24px，即 1.5 x 16 = 24。</p>
<p>如果我们加多一个div来包裹原先的div，然后设置其字体大小为 1.25em呢?</p>
<p>我们包裹的 div 继承根元素字体大小 16px ，并乘以它自己的 1.25em 的字体大小。 这将设置包裹 div 字体大小为 20px，即 1.25 x 16 = 20。</p>
<p>现在我们原始的 div 不再直接从根元素继承,而是从其新的父元素继承字体大小为 20px 1.5em 其padding值现在等于 30px，即 1.5 x 20 = 30。</p>
<p>这个继承效应可以更复杂，如果我们向我们原始的 div 添加 em 字体单位，比方说 1.2em。</p>
<p>Div 从其父级继承 20px 字体大小，然后，乘以它自己的 1.2em 设置，给它 24px，即 1.2 × 20 = 24 新字体大小。</p>
<p>div上的1.5em padding 现在将再次改变大小，用新的字体大小，36px，即 1.5 × 24 = 36 。</p>
<p>最后，为了进一步说明那个 em 单位是相对于他们最终获得(不是父元素)的字体大小，让我们来看看设置padding 1.5em 如果我们显式设置 div 使用 14px值，不继承字体大小会发生什么。</p>
<p>现在，我们的padding为 21px，即 1.5 x 14 = 21 已经变小。 它不受父元素的字体大小。</p>
<blockquote>
<p>根 html 元素将继承浏览器中设置的字体大小，除非显式设置固定值去覆盖。所以 html 元素的字体大小虽然是直接确定 rem值，但字体大小可能首先来自浏览器设置。因此浏览器的字体大小设置可以影响每个使用 rem 单元以及每个通过 em 单位继承的值。</p>
</blockquote>
<h3 id="总结与-rem-差异-em"><a href="#总结与-rem-差异-em" class="headerlink" title="总结与 rem 差异 em"></a>总结与 rem 差异 em</h3><ul>
<li><p>rem 单位翻译为像素值是由 html 元素的字体大小决定的。 此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位。</p>
</li>
<li><p>em 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位。</p>
</li>
</ul>
<h3 id="使用rem的目的"><a href="#使用rem的目的" class="headerlink" title="使用rem的目的"></a>使用rem的目的</h3><p>确保无论用户如何设置自己的浏览器，我们的布局都能调整到合适大小。</p>
<h3 id="使用em的目的"><a href="#使用em的目的" class="headerlink" title="使用em的目的"></a>使用em的目的</h3><p>em 单位取决于一个font-size值而非 html 元素的字体大小。<br>em 单位的主要目的应该是允许保持在一个特定的设计元素范围内的可扩展性。根据某个元素的字体大小做缩放而不是根元素的字体大小。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>rem 和 em 单位是由浏览器基于你的设计中的字体大小计算得到的像素值。</li>
<li>em 单位基于使用他们的元素的字体大小。</li>
<li>rem 单位基于 html 元素的字体大小。</li>
<li>em 单位可能受任何继承的父元素字体大小影响</li>
<li>rem 单位可以从浏览器字体设置中继承字体大小。</li>
<li>使用 em 单位应根据组件的字体大小而不是根元素的字体大小。</li>
<li>在不需要使用em单位，并且需要根据浏览器的字体大小设置缩放的情况下使用rem。</li>
<li>使用rem单位，除非你确定你需要 em 单位，包括对字体大小。</li>
<li>媒体查询中使用 rem 单位</li>
<li>不要在多列布局中使用 em 或 rem -改用 %。</li>
<li>不要使用 em 或 rem，如果缩放会不可避免地导致要打破布局元素。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2016/10/22/Node-js高性能的异步I-O/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/22/Node-js高性能的异步I-O/" itemprop="url">
                  Node.js高性能的异步I/O
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-22T21:58:23+08:00">
                2016-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Node的单线程异步非阻塞I-O模型"><a href="#Node的单线程异步非阻塞I-O模型" class="headerlink" title="Node的单线程异步非阻塞I/O模型"></a>Node的单线程异步非阻塞I/O模型</h1><p><br></p>
<blockquote>
<p>  Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.</p>
</blockquote>
<p>说异步之前先了解几个名词</p>
<ul>
<li><p>I/O的阻塞与非阻塞：阻塞模式的I/O会造成应用程序等待，直到I/O完成。同时操作系统也支持将I/O操作设置为非阻塞模式，这时应用程序的调用将可能在没有拿到真正数据时就立即返回了，为此应用程序需要多次调用才能确认I/O操作完全完成，这就是一个轮训的过程。</p>
</li>
<li><p>I/O的同步与异步：I/O的同步与异步出现在应用程序中。如果做阻塞I/O调用，应用程序等待调用的完成的过程就是一种同步状况。相反，I/O为非阻塞模式时，应用程序则是异步的。</p>
</li>
<li><p>事件驱动：当事件被检测到发生时才回调调用会到函数，通过事件循环加事件触发的方式来运行程序。</p>
</li>
<li><p>事件循环：当有大量异步操作时需要调用相应的回调函数，需要用一种机制来管理同一个队列。</p>
</li>
</ul>
<p>Node的单线程异步非阻塞I/O模型利用单线程，远离多线程的死锁、状态同步等问题避免不必要的内存开销和上下文切换开销。 利用异步I/O，让单线程远离阻塞，更好的利CPU。</p>
<p>一个异步 I/O 的大致流程如下：</p>
<ul>
<li><p>发起 I/O 调用</p>
<ul>
<li>用户通过 Javascript 代码调用 Node 核心模块，将参数和回调函数传入到核心模块；</li>
<li>Node 核心模块会将传入的参数和回调函数封装成一个请求对象；</li>
<li>将这个请求对象推入到 I/O 线程池等待执行；</li>
<li>Javascript 发起的异步调用结束，Javascript 线程继续执行后续操作。</li>
</ul>
</li>
<li><p>执行回调</p>
<ul>
<li>I/O 操作完成后，会将结果储存到请求对象的 result 属性上，并发出操作完成的通知；</li>
<li>每次事件循环时会检查是否有完成的 I/O 操作，如果有就将请求对象加入到 I/O 观察者队列中，之后当做事件处理；</li>
<li>处理 I/O 观察者事件时，会取出之前封装在请求对象中的回调函数，执行这个回调函数，并将 result 当参数，以完成 Javascript 回调的目的。</li>
</ul>
</li>
</ul>
<p>这里面涉及到了一个设计理念:事件循环（Event Loop），它是一个类似于 while true 的无限循环,它会维护一系列的监视器,这些监视器都有对应着一种异步操作，它们注册事件监听以及相应的回调。事件循环除了维护那些观察者队列，还维护了一个 time 字段，在初始化时会被赋值为0，每次循环都会更新这个值。所有与时间相关的操作，都会和这个值进行比较，来决定是否执行。与 timer 相关的过程如下：</p>
<ul>
<li>更新当前循环的 time 字段，即当前循环下的“现在”；</li>
<li>检查循环中是否还有需要处理的任务（handlers/requests），如果没有就不必循环了，即是否 alive。</li>
<li>检查注册过的 timer，如果某一个 timer 中指定的时间落后于当前时间了，说明该 timer 已到期，于是执行其对应的回调函数；</li>
<li>执行一次 I/O polling（即阻塞住线程，等待 I/O 事件发生），如果在下一个 timer 到期时还没有任何 I/O 完成，则停止等待，执行下一个 timer 的回调。如果发生了 I/O 事件，则执行对应的回调；由于执行回调的时间里可能又有 timer 到期了，这里要再次检查 timer 并执行回调。</li>
</ul>
<p>Node.js它的单线程指的是自身 Javascript 运行环境的单线程，Node.js 并没有给 Javascript 执行时创建新线程的能力，最终的实际操作是通过事件循环来执行的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lennonover" />
          <p class="site-author-name" itemprop="name">lennonover</p>
           
              <p class="site-description motion-element" itemprop="description">一丿口石砳磊</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">69</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lennonover</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
