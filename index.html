<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一丿口石砳磊">
<meta property="og:type" content="website">
<meta property="og:title" content="lennonover">
<meta property="og:url" content="https://github.com/lennonover/index.html">
<meta property="og:site_name" content="lennonover">
<meta property="og:description" content="一丿口石砳磊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lennonover">
<meta name="twitter:description" content="一丿口石砳磊">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/lennonover/"/>





  <title> lennonover </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lennonover</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/03/30/函数式编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/30/函数式编程/" itemprop="url">
                   函数式编程(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-30T20:20:09+08:00">
                2018-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>函数式语言给了我一个全新的视角，从一个完全不同的方式去看待编程，开始会感到不自然，需要时间去适应。所有的定义都是基于函数，值不可更改，无状态，但是时间久了就会发现代码会更加简洁，而且容易复用。</p>
<h2 id="if-简化"><a href="#if-简化" class="headerlink" title="if 简化"></a>if 简化</h2><p>几乎每个if语句的实例都可以用一个等价的三元操作来替代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 典型的</div><div class="line">function saveCustomer(customer) &#123;</div><div class="line">  if (isCustomerValid(customer)) &#123;</div><div class="line">    database.save(customer)</div><div class="line">  &#125; else &#123;</div><div class="line">    alert(&apos;customer is invalid&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 三元</div><div class="line">function saveCustomer(customer) &#123;</div><div class="line">  return isCustomerValid(customer)</div><div class="line">    ? database.save(customer)</div><div class="line">    : alert(&apos;customer is invalid&apos;)</div><div class="line">&#125;</div><div class="line">// ES6 的写法</div><div class="line">const saveCustomer = customer =&gt;</div><div class="line">  isCustomerValid(customer)</div><div class="line">    ? database.save(customer)</div><div class="line">    : alert(&apos;customer is invalid&apos;)</div></pre></td></tr></table></figure>
<p>多层嵌套</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 多层 else-if</div><div class="line">function customerValidation(customer) &#123;</div><div class="line">  if (!customer.email) &#123;</div><div class="line">    return error(&apos;email is require&apos;)</div><div class="line">  &#125; else if (!customer.login) &#123;</div><div class="line">    return error(&apos;login is required&apos;)</div><div class="line">  &#125; else if (!customer.name) &#123;</div><div class="line">    return error(&apos;name is required&apos;)</div><div class="line">  &#125; else &#123;</div><div class="line">    return customer</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ES6 三元修正</div><div class="line">const customerValidation = customer =&gt;</div><div class="line">  !customer.email   ? error(&apos;email is required&apos;)</div><div class="line">  : !customer.login ? error(&apos;login is required&apos;)</div><div class="line">  : !customer.name  ? error(&apos;name is required&apos;)</div><div class="line">                    : customer</div></pre></td></tr></table></figure>
<p>现在就可以清楚地看到左侧定义的所有条件以及右侧返回的值。</p>
<h2 id="没有-for-循环"><a href="#没有-for-循环" class="headerlink" title="没有 for 循环"></a>没有 for 循环</h2><p>filter, map 和 reduce 可以满足所有情况, filter、map 和 reduce 共同点就是并不会对原数组做任何改动，结果都是生成一个新变量。</p>
<p>原始代码 获得小于 10个月的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const peoples = [</div><div class="line">  &#123; name: &apos;小明&apos;,     months: 84 &#125;,</div><div class="line">  &#123; name: &apos;小小明&apos;,   months: 24 &#125;,</div><div class="line">  &#123; name: &apos;小小小明&apos;, months: 4 &#125;</div><div class="line">]</div><div class="line">var children = []</div><div class="line">for (var i = 0; i &lt; peoples.length; i++) &#123;</div><div class="line">  if (peoples[i].months &lt; 10) &#123;</div><div class="line">    children.push(peoples[i].name)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">console.log(children)</div></pre></td></tr></table></figure></p>
<p>将 if 语句提取到它自己的函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const isChildren = people =&gt; people.months &lt; 10</div><div class="line">var children = []</div><div class="line">for (var i = 0; i &lt; peoples.length; i++) &#123;</div><div class="line">  if (isChildren(peoples[i])) &#123;</div><div class="line">    children.push(peoples[i].name)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下一个改变是从 people 类型的对象中提取转换（或映射）到名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const isChildren = people =&gt; people.months &lt; 10</div><div class="line">const getName = people =&gt; people.name</div><div class="line">var children = []</div><div class="line">for (var i = 0; i &lt; peoples.length; i++) &#123;</div><div class="line">  if (isChildren(peoples[i])) &#123;</div><div class="line">    children.push(getName(peoples[i]))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后一步 使用 map 操作，最好地展示您的代码的可读性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const isChildren = people =&gt; people.months &lt; 10</div><div class="line">const getName = people =&gt; people.name</div><div class="line">const children =</div><div class="line">  peoples.filter(isChildren)</div><div class="line">      .map(getName)</div></pre></td></tr></table></figure>
<p>完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const isChildren = people =&gt; people.months &lt; 10</div><div class="line">const getName = people =&gt; people.name</div><div class="line">const getChildrenNames = peoples =&gt;</div><div class="line">  peoples.filter(isChildren)</div><div class="line">      .map(getName)</div><div class="line">const peoples = [</div><div class="line">    &#123; name: &apos;小明&apos;,     months: 84 &#125;,</div><div class="line">    &#123; name: &apos;小小明&apos;,   months: 24 &#125;,</div><div class="line">    &#123; name: &apos;小小小明&apos;, months: 4 &#125;</div><div class="line">]</div><div class="line">const children = getChildrenNames(peoples)</div><div class="line">console.log(children)</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/03/14/一道面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/14/一道面试题/" itemprop="url">
                  一道面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-14T20:29:08+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>浏览器中输入www.baidu.com 直到看到页面之间发生了什么？</p>
</blockquote>
<p>今天就说说根据这道题梳理自己的前端知识！</p>
<h2 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h2><p>解释 URL 是浏览器的活，所以首先要搞明白浏览器的工作方式。<br>浏览器是多进程的，有一个主控进程，进程可能包括主控进程，插件进程，GPU，tab 页（浏览器内核）等等，主要包括：</p>
<ul>
<li>Browser 进程：浏览器的主进程（负责协调、主控），只有一个</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
<li>GPU进程：最多一个，用于 3D 绘制</li>
<li>浏览器渲染进程（内核）：默认每个 Tab 页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白 tab 会合并成一个进程）</li>
</ul>
<p>浏览器渲染进程是多线程的，它有主要几大类子线程</p>
<ul>
<li>GUI 线程</li>
<li>JS 引擎线程</li>
<li>事件触发线程</li>
<li>定时器线程</li>
<li>网络请求线程</li>
</ul>
<p>输入URL后，从浏览器会进行解析，URL 一般包括几大部分：</p>
<ul>
<li>protocol，协议头，譬如有 http，https 等</li>
<li>host，主机域名或IP地址</li>
<li>port，端口号</li>
<li>path，目录路径</li>
<li>query，即查询参数</li>
<li>fragment，即 # 后的 hash 值，一般用来定位到某个位置</li>
</ul>
<p>每次网络请求时都需要开辟单独的线程进行,览器会根据解析出得协议，开辟一个网络线程，前往请求资源.</p>
<h2 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h2><p>网络请求之前会先都差缓存，HTTP 缓存有多种规则，根据是否需要重新向服务器发起请求来分类，将其分为强制缓存，对比缓存。</p>
<ul>
<li><p>强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起 http 请求</p>
</li>
<li><p>对比缓存（304）时，浏览器会向服务端发起 http 请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存，可以使用 <code>Ctrl + F5</code> 强制刷新可以使得对比缓存无效</p>
</li>
</ul>
<p>http1.0中的缓存控制：</p>
<ul>
<li>Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置 no-cache 时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容 http1.0，所以以前又被大量应用）</li>
<li>Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires 一般对应服务器端时间，如 Expires：Fri, 30 Oct 1998 14:19:41</li>
<li>If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-Modified-Since，而服务端的是 Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified 匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内</li>
</ul>
<p>http1.1中的缓存控制：</p>
<ul>
<li>Cache-Control：缓存控制头部，有no-cache、max-age等多种取值</li>
<li><p>Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age 是 Cache-Control 头部的值，不是独立的头部，譬如 Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算</p>
</li>
<li><p>If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-None-Match，而服务端的是 E-tag，同样，发出请求后，如果 If-None-Match 和 E-tag 匹配，则代表内容未变，通知浏览器使用本地缓存，和 Last-Modified 不同，E-tag 更精确，它是类似于指纹一样的东西，基于 FileEtag INode Mtime Size 生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</p>
</li>
</ul>
<p>强缓存判断依据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（http1.1）Cache-Control =&gt; Cache-Control: max-age = 35600</div><div class="line">（http1.0）Expires =&gt; 服务器端的时间</div></pre></td></tr></table></figure>
<p>cache-control 中的 max-age 保存一个相对时间。例如 Cache-Control: max-age = 35600，表示浏览器收到文件后，缓存在35600s内均有效。如果同时存在 cache-control 和 Expires ，浏览器总是优先使用cache-control。<br>Max-Age 相比 Expires，Expires 使用的是服务器端的时间，但是有时候会有这样一种情况-客户端时间和服务端不同步。所以一般 http1.1 后不推荐使用 Expires。</p>
<p>对比缓存判断依据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（http1.1）E-tag/If-None-Match</div><div class="line">（http1.0）Last-Modified/If-Modified-Since</div></pre></td></tr></table></figure>
<p>last-modified 是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送 if-modified-since 字段。服务器用本地 Last-modified 时间与 if-modified-since 时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。</p>
<p>E-tag：资源的实体标识（哈希字符串），当资源内容更新时，E-tag 会改变。服务器会判断E-tag是否发生变化，如果变化则返回新资源，否则返回304。<br>　　<br>如果同时带有 E-tag 和 Last-Modified，服务端会优先检查 E-tag</p>
<p>在浏览器接收到服务器响应后，会检测响应头部（Header），如果有nEtag 字段，那么浏览器就会将本次缓存写入硬盘中。
　　
　　</p>
<h2 id="开启线程发出请求"><a href="#开启线程发出请求" class="headerlink" title="开启线程发出请求"></a>开启线程发出请求</h2><ul>
<li>dns 查询</li>
</ul>
<p>dns 是通常是完成域名到 ip 的映射，大致流程：</p>
<ul>
<li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host</li>
<li>如果本地没有，就向 dns 域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的 IP</li>
</ul>
<p>dns 解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑 <code>dns-prefetch</code> 优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a 标签的 DNS 预解析 默认是开启的 但是当 使用 https 的时候是默认关闭的需要手动开启 a 标签的预解析</div><div class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;    </div><div class="line"></div><div class="line">开启 dns 预解析</div><div class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;IP地址&quot;&gt;</div></pre></td></tr></table></figure>
<ul>
<li>tcp/ip 请求</li>
</ul>
<p>首先会建立 tcp 连接</p>
<ul>
<li>建立链接（三次握手）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">客户端发个请求“开门呐，我要进来”给服务器</div><div class="line">服务器发个“进来吧，我去给你开门”给客户端</div><div class="line">客户端有很客气的发个“谢谢，我要进来了”给服务器</div></pre></td></tr></table></figure>
<p>建立连接也会断开连接只是不是这时候断开，先提前说下</p>
<ul>
<li>断开连接（四次挥手）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">客户端发个“时间不早了，我要走了”给服务器，等服务器起身送他</div><div class="line">服务器听到了，发个“我知道了，那我送你出门吧”给客户端，等客户端走</div><div class="line">服务器把门关上后，发个“我关门了”给客户端，然后等客户端走（尼玛~矫情啊）</div><div class="line">客户端发个“我知道了，我走了”，之后自己就走了</div></pre></td></tr></table></figure>
<p>由于 tcp/ip 对链接有并发的控制，所以有甚多针对请求的优化，比如合并请求的雪碧图。<br>关于这里有涉及到五层网络协议，就是从客户端发出 http 请求到服务器接收，中间会经过一系列的流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">应用层（dns,http） DNS 解析成IP并发送 http 请求</div><div class="line">传输层（tcp/ip）建立连接</div><div class="line">网络层（ip）IP 寻址</div><div class="line">数据链层（ppp）封装成二进制帧</div><div class="line">物理层 物理传输</div></pre></td></tr></table></figure></p>
<p>其实也有一个完整的 OSI 七层框架，与之相比，多了会话层、表示层。</p>
<p>浏览器向服务器发送 HTTP 请求。</p>
<ul>
<li>http 报文结构</li>
</ul>
<p>报文一般包括了：通用头部，请求/响应头部，请求/响应体</p>
<ul>
<li>通用头部<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Request Url: 请求的web服务器地址</div><div class="line">Request Method: 请求方式</div><div class="line">（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</div><div class="line">Status Code: 请求的返回状态码，如200代表成功</div><div class="line">Remote Address: 请求的远程服务器地址（会转为IP）</div></pre></td></tr></table></figure>
</li>
</ul>
<p>code 状态码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1xx——指示信息，表示请求已接收，继续处理</div><div class="line">2xx——成功，表示请求已被成功接收、理解、接受</div><div class="line">3xx——重定向，要完成请求必须进行更进一步的操作</div><div class="line">4xx——客户端错误，请求有语法错误或请求无法实现</div><div class="line">5xx——服务器端错误，服务器未能实现合法的请求</div></pre></td></tr></table></figure></p>
<p>请求/响应头部</p>
<p>常用的请求头部（部分）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Accept: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的 Content-Type ）</div><div class="line">Accept-Encoding：浏览器支持的压缩类型,如 gzip 等,超出类型不能接收</div><div class="line">Content-Type：客户端发送出去实体内容的类型</div><div class="line">Cache-Control: 指定请求和响应遵循的缓存机制，如 no-cache</div><div class="line">If-Modified-Since：对应服务端的 Last-Modified ，用来匹配看文件是否变动，只能精确到 1s 之内，http1.0中</div><div class="line">Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</div><div class="line">Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</div><div class="line">If-None-Match：对应服务端的 E-tag，用来匹配文件内容是否改变（非常精确），http1.1 中</div><div class="line">Cookie: 有 cookie 并且同域访问时会自动带上</div><div class="line">Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如 keep-alive</div><div class="line">Host：请求的服务器 URL</div><div class="line">Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin 比 Referer 更尊重隐私</div><div class="line">Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</div><div class="line">User-Agent：用户客户端的一些必要信息，如 UA 头部等</div></pre></td></tr></table></figure>
<p>常用的响应头部（部分）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Headers: 服务器端允许的请求 Headers</div><div class="line">Access-Control-Allow-Methods: 服务器端允许的请求方法</div><div class="line">Access-Control-Allow-Origin: 服务器端允许的请求 Origin 头部（譬如为*）</div><div class="line">Content-Type：服务端返回的实体内容的类型</div><div class="line">Date：数据从服务器发送的时间</div><div class="line">Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档</div><div class="line">Last-Modified：请求资源的最后修改时间</div><div class="line">Expires：应该在什么时候认为文档已经过期,从而不再缓存它</div><div class="line">Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control 后有效</div><div class="line">E-tag：请求变量的实体标签的当前值</div><div class="line">Set-Cookie：设置和页面关联的 cookie，服务器通过这个头部把 cookie 传给客户端</div><div class="line">Keep-Alive：如果客户端有 keep-alive，服务端也会有响应（如 timeout=38 ）</div><div class="line">Server：服务器的一些相关信息</div></pre></td></tr></table></figure>
<p>一般来说，请求头部和响应头部是匹配分析的。</p>
<p>譬如，请求头部的 Accept 要和响应头部的 Content-Type 匹配，否则会报错</p>
<p>譬如，跨域请求时，请求头部的 Origin 要匹配响应头部的 Access-Control-Allow-Origin，否则会报跨域错误</p>
<p>譬如，在使用缓存时，请求头部的 If-Modified-Since、If-None-Match 分别和响应头部的Last-Modified、E-tag对应</p>
<h2 id="服务器接收到请求"><a href="#服务器接收到请求" class="headerlink" title="服务器接收到请求"></a>服务器接收到请求</h2><ul>
<li>负载均衡</li>
</ul>
<p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡。用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了 nginx 控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的 HTTP 响应，并将它反馈给用户</p>
<ul>
<li><p>后台的处理</p>
</li>
<li><p>cookie<br>cookie 是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用.<br>由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化,例如：</p>
</li>
<li><p>将静态资源分组，分别放到不同的子域名下</p>
</li>
<li>而子域名请求时，是不会带上父级域名的cookie的，所以就避免了浪费</li>
</ul>
<p>说到了多域名拆分，这里再提一个问题，那就是：</p>
<p>在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）此时就需要用到一种优化方案：dns-prefetch（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）</p>
<p>说到 cookie 就要把 localStorage，sessionStorage 区分下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</div><div class="line"></div><div class="line">cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。</div><div class="line"></div><div class="line">存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带cookie，所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到5M或更大。</div><div class="line"></div><div class="line">数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</div><div class="line"></div><div class="line">作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。</div></pre></td></tr></table></figure>
<ul>
<li>gzip 压缩</li>
</ul>
<p>gzip 是 GNU zip的缩写，它是一个 GNU 自由软件的文件压缩程序。一般服务器都会开启 gzip 这样可以减少带宽消耗。但是 HTTP 压缩需要成本。Web 服务器获得需要的内容，然后压缩它，最后将它发送到客户端。如果内容不能被进一步压缩，你只是在浪费 CPU 做无意义的任务，采用 HTTP 压缩已经被过压缩的东西并不能使它更小。事实上，添加标头，压缩字典，并校验响应体实际上使它变得更大。</p>
<ul>
<li>长连接与短连接</li>
</ul>
<p>首先看tcp/ip层面的定义：</p>
<ul>
<li>长连接：一个 tcp/ip 连接上可以连续发送多个数据包，在 tcp 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li>
<li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li>
</ul>
<p>然后在http层面：</p>
<ul>
<li>http1.0中，默认使用的是短连接，也就是说，浏览器每进行一次 http 操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li>
<li>http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 http 的 tcp 连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li>
</ul>
<p>注意： keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</p>
<ul>
<li>https</li>
</ul>
<p>简单来看，https 与 http 的区别就是： 在请求前，会建立 ssl 链接，确保接下来的通信都是加密的，无法被轻易截取分析。如果要将网站升级成 https，需要后端支持（后端需要申请证书等），然后 https 的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说 http2.0 配合 https 的体验更佳（因为 http2.0 更快了）SSL/TLS 的握手流程握手流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1. 浏览器建立 SSL 连接，像服务端 发送一个随机数和加密方法</div><div class="line">2. 服务端选取加密方法回复一个随机数并将自己的证书发送过去</div><div class="line">3. 浏览器收到证书后</div><div class="line">    - 验证证书合法性</div><div class="line">    - 用户街道证书后生成新的随机数，然后证书中的公钥以及指定的加密方法加密发送</div><div class="line">    - 通过一定的算法生成 HTTP 链接数据传输的对称加密 key</div><div class="line">    - 使用约定好的算法计算握手消息，并使用生成的 key 对消息进行加密，最后将之前生成的所有信息发送给服务端。 </div><div class="line">4. 服务端收到浏览器的回复</div><div class="line">    - 利用已知的加解密方式与自己的私钥进行解密</div><div class="line">    - 和浏览器相同规则生成 key</div><div class="line">    - 使用 key 解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</div><div class="line">    - 使用 key 加密一段握手消息，发送给浏览器</div><div class="line">5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束</div></pre></td></tr></table></figure>
<ul>
<li>http 2.0</li>
</ul>
<p>http2.0 它相当于是 http 的下一代规范，与http1.1的显著不同点：</p>
<ul>
<li>http1.1 中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来</li>
<li>ttp2.0 中，一个 tcp/ip 请求可以请求多个资源，也就是说，只要一次 tcp/ip 请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li>
</ul>
<p>http2.0的一些特性：</p>
<ul>
<li>多路复用（即一个tcp/ip连接可以请求多个资源）</li>
<li>首部压缩（http头部压缩，减少体积）</li>
<li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li>
<li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li>
<li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li>
</ul>
<p>注意：HTTP2.0 的多路复用和 HTTP1.1 中的长连接复用的区别就是：</p>
<p>HTTP/1.1 Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞。</p>
<p>HTTP/2 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</p>
<ul>
<li><p>浏览器接收响应</p>
</li>
<li><p>构建渲染树</p>
</li>
</ul>
<p>浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树。</p>
<ul>
<li>HTML解析，构建DOM</li>
</ul>
<p>解析 HTML 到构建出DOM当然过程可以简述如下：</p>
<p><code>Bytes → characters → tokens → nodes → DOM</code></p>
<ul>
<li>生成CSS规则</li>
</ul>
<p>CSS 规则树的生成也是类似。简述为：</p>
<p><code>Bytes → characters → tokens → nodes → CSSOM</code></p>
<ul>
<li>渲染</li>
</ul>
<p>布局是由 CPU 处理的，而绘制则是由 GPU 完成的,GPU 会对我们的渲染层作缓存，如果我们把那些一直发生大量重排重绘的元素提取出来，单独触发一个渲染层，那样这个元素不就不会“连累”其他元素一块重绘。<br>Video 元素、WebGL、Canvas、CSS3 3D、CSS滤镜、z-index 大于某个相邻节点的元素都会触发新的 Layer，剩下的其实我们最常用的方法，就是给某个元素加上下面的样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateZ</span>(0);</div><div class="line"><span class="selector-tag">backface-visibility</span>: <span class="selector-tag">hidden</span>;</div></pre></td></tr></table></figure>
<p>也会触发渲染层，把容易触发重排重绘的元素单独触发渲染层，让它与那些“静态”元素隔离，让GPU分担更多的渲染工作，我们通常把这样的措施成为硬件加速，或者是GPU加速。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Style：该区域为样式计算阶段，浏览器会根据选择器（就是CSS选择器，如.td）计算出哪些节点应用哪些CSS规则，然后计算出每个节点的最终样式并应用到节点上。</div><div class="line"></div><div class="line">Layout：该区域为布局计算阶段，浏览器会在该过程中根据节点的样式规则来计算它要占据的空间大小以及在屏幕中的位置。</div><div class="line"></div><div class="line">Paint：该区域为绘制阶段，浏览器会先创建绘图调用的列表，然后填充像素。绘制阶段会涉及到文本、颜色、图像、边框和阴影，基本上包括了每个可视部分。绘制一般是在多个图层（用过Photoshop等图片编辑软件的童鞋一定很眼熟图层这个词，这里的图层的含义其实是差不多的）上完成的。</div><div class="line"></div><div class="line">Composite：该区域为合成阶段，浏览器将多个图层按照正确顺序绘制到屏幕上。</div></pre></td></tr></table></figure>
<p>如果动态修改了 DOM 或 CSS，就会重新布局（Layout）或渲染（Repaint）这里 Layou t和 Repaint 的概念是有区别的：</p>
<ul>
<li><p>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</p>
</li>
<li><p>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</p>
</li>
</ul>
<p>什么会引起回流？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1.页面渲染初始化</div><div class="line"></div><div class="line">2.DOM结构改变，比如删除了某个节点</div><div class="line"></div><div class="line">3.render树变化，比如减少了padding</div><div class="line"></div><div class="line">4.窗口resize</div><div class="line"></div><div class="line">5.改变字体大小会引发回流</div><div class="line"></div><div class="line">6.最复杂的一种：获取某些属性，引发回流</div><div class="line">很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</div><div class="line">    (1) offset(Top/Left/Width/Height)</div><div class="line">    (2) scroll(Top/Left/Width/Height)</div><div class="line">    (3) cilent(Top/Left/Width/Height)</div><div class="line">    (4) width,height</div><div class="line">    (5) 调用了getComputedStyle()或者IE的currentStyle</div></pre></td></tr></table></figure>
<p>回流一定伴随着重绘，重绘却可以单独出现</p>
<p>所以一般会有一些优化方案，如：</p>
<ul>
<li>减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新</li>
<li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document</li>
<li>避免多次读取offset等属性。无法避免则将它们缓存到变量</li>
<li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li>
</ul>
<p>最后如果想要知道每个CSS属性将会对哪个阶段产生怎样的影响，请去 <a href="https://csstriggers.com/" target="_blank" rel="external">CSS Triggers</a>，该网站详细地说明了每个CSS属性会影响到哪个阶段。</p>
<ul>
<li>关闭TCP连接或继续保持连接</li>
</ul>
<p>通过四次挥手关闭连接</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/03/02/文字避让/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/02/文字避让/" itemprop="url">
                  文字避让
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T20:58:22+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>webGis 经常会遇到地图上标记文字问题，但是文字空间不够时，就会造成文字重叠显示混乱的现象，导致效果很不好，下面就说说解决方案。</p>
<h2 id="文字避让"><a href="#文字避让" class="headerlink" title="文字避让"></a>文字避让</h2><p>文字标注算法是 GIS 中最复杂（NP）的问题之一，本篇将介绍四分位模型算法。<br>关于文字在地图上的坐标是经纬度坐标根据墨卡托转换而来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;</div><div class="line">    &quot;name&quot;: &quot;南京市&quot;,//要显示的文字</div><div class="line">    &quot;lon&quot;: 118.15,</div><div class="line">    &quot;lat&quot;: 32.89,</div><div class="line">    &quot;pixel&quot;: &#123; //像素坐标</div><div class="line">      &quot;x&quot;: 968,</div><div class="line">      &quot;y&quot;: 736</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<ul>
<li>求出每段文字矩形的实际大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let ctx = this.container.getContext(&apos;2d&apos;); // canvas 上下文</div><div class="line">let width= ctx.measureText(name).width;</div></pre></td></tr></table></figure>
<p>通过 measureText 得到每个文字的宽度，canvas 并没有直接获取文字的方法，那文字的高度如何的得到呢？</p>
<p>我们通过反复测试发现 canvas 的 font 等于 “13px Arial” 字体的时候，文字的高度大概是 fontSize 的 1.1 倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let fontSize = parseInt(ctx.font);</div><div class="line">let height = fontSize * 1.1;</div></pre></td></tr></table></figure>
<p>文字的宽度和高度得到后，我们就可以创建文字矩形的坐标系了。</p>
<p>所谓四分位模型，每一个标记点都有上下左右四个放文字的位子，如果左边放不下，那就放右边试试，还不行就放到下面试试，以此类推</p>
<p>创建右侧虚拟矩形坐标描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_getLeftAnchor() &#123;</div><div class="line">    let x = this.center.x - this.radius - this.textReact.width,</div><div class="line">        y = this.center.y - this.textReact.height / 2,</div><div class="line">        diam = this.radius * 2,</div><div class="line">        maxH = diam &gt; this.textReact.height ? diam : this.textReact.height; //矩形的高度</div><div class="line">    return &#123;</div><div class="line">        x,</div><div class="line">        y,</div><div class="line">        minX: x,</div><div class="line">        maxX: this.center.x + this.radius,</div><div class="line">        minY: this.center.y - maxH / 2,</div><div class="line">        maxY: this.center.y + maxH / 2</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以此类推，描述下面、左面、上面的虚拟矩形坐标。</p>
<ul>
<li>判断碰撞</li>
</ul>
<p>判断两个矩形是否覆盖相交，根据矩形的 minX,maxX,minY,maxY 判断相交，原理比较简单，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 判断分位是否相交</div><div class="line"> * @param &#123;*&#125; target </div><div class="line"> */</div><div class="line"> </div><div class="line">isAnchorMeet(target) &#123;</div><div class="line">    let react = this.getCurrentRect(),</div><div class="line">        targetReact = target.getCurrentRect();</div><div class="line">    if ((react.minX &lt; targetReact.maxX) &amp;&amp; (targetReact.minX &lt; react.maxX) &amp;&amp;</div><div class="line">        (react.minY &lt; targetReact.maxY) &amp;&amp; (targetReact.minY &lt; react.maxY)) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>创建虚拟文字集合对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let labels = pixels.map((val) =&gt; &#123;</div><div class="line">    let radius = val.pixel.radius + this.style.normal.borderWidth; //圆点半径</div><div class="line">    return new Label(val.pixel.x, val.pixel.y, radius, fontSize, byteWidth, val.name);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>递归遍历虚拟文字集合、判断是否与其他相交，如果有相交就移动当前文字位子，直到不相交为止。当找不到合适位置时，就选择隐藏当前文字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">    var meet = false; //本轮是否有相交</div><div class="line">    for (let i = 0; i &lt; labels.length; i++) &#123;</div><div class="line">        let temp = labels[i];</div><div class="line">        for (let j = 0; j &lt; labels.length; j++) &#123;</div><div class="line">            if (i != j &amp;&amp; temp.show &amp;&amp; temp.isAnchorMeet(labels[j])) &#123;</div><div class="line">                temp.next();</div><div class="line">                meet = true;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; while (meet);</div></pre></td></tr></table></figure>
<ul>
<li>绘画文字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">labels.forEach(function (item) &#123;</div><div class="line">    if (item.show) &#123; //是否显示</div><div class="line">        let pixel = item.getCurrentRect();</div><div class="line">        ctx.beginPath();</div><div class="line">        ctx.fillText(item.text, pixel.x, pixel.y);</div><div class="line">        ctx.fill();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/01/26/git-工作流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/26/git-工作流/" itemprop="url">
                  git 工作流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-26T21:38:02+08:00">
                2018-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>git 是目前最流行的源代码管理工具，Git 的确可以在各个方面做很多事情，然而任然存在采用何种分支管理的问题，Git 分支管理并没有普遍适用的最佳做法，只有对每个团队和项目而言最适合的工作流。<br>git 的操作还是有一定复杂度的，错误的操作影响也比较大，异步小心就会导致部分代码丢失，还很难查到具体出问题的时间点和功能点。</p>
<p>我们采用的是 git-flow 流程,包含 4 类分支，分别是 master、develop、新功能分支（feature）和 hotfix。</p>
<h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>在 github 中创建一个新的仓库，只有一个 master 分支</p>
<h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><p>每次开发新功能，都应该从当前主开发分支新建一个功能分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b feature-wz-qx</div></pre></td></tr></table></figure>
<h2 id="提交分支"><a href="#提交分支" class="headerlink" title="提交分支"></a>提交分支</h2><p>模块开发差不多，提交代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git status</div><div class="line">git add -F</div><div class="line">git commit -m &apos;add xxxxx&apos;</div></pre></td></tr></table></figure>
<p>关于 commit 完整的 log 由 类别(必须)  简短描述(必须) 详细描述(可选) 三部分组成：</p>
<ul>
<li>类别<ul>
<li>add 增加</li>
<li>fix 修复 bug</li>
<li>change 修改</li>
<li>del 移除</li>
<li>refactor 代码重构</li>
<li>docs 文档</li>
</ul>
</li>
</ul>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &apos;add xxxxx&apos;</div></pre></td></tr></table></figure>
<p>如果增加详细描述，具体内容前空一行，兼容 Markdown。<br>还可以可以配合 <a href="https://gitmoji.carloscuesta.me/" target="_blank" rel="external">gitmoji</a> 强化信息可读性。</p>
<h2 id="合并提交记录"><a href="#合并提交记录" class="headerlink" title="合并提交记录"></a>合并提交记录</h2><p>为了避免太多的 commit 而造成版本控制的混乱，通常我们推荐将这些 commit 合并成一个。假如我们提交了四次记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">commit 14c69cf825c17bd3e48154994e6f722db251fcfb</div><div class="line">Author: lennonover &lt;lennonover@163.com&gt;</div><div class="line">Date:   Tue Jan 23 16:38:57 2018 +0800</div><div class="line"></div><div class="line">    add forth </div><div class="line"></div><div class="line">commit 969161b68ab3b479fc52a26c4f053395ce4f3c63</div><div class="line">Author: lennonover &lt;lennonover@163.com&gt;</div><div class="line">Date:   Tue Jan 23 16:01:12 2018 +0800</div><div class="line"></div><div class="line">    add third </div><div class="line"></div><div class="line">commit 44adff48febeb65e5f89e2dc18ecc3ba7c9c31ba</div><div class="line">Author: lennonover &lt;lennonover@gmail.com&gt;</div><div class="line">Date:   Tue Jan 23 15:56:27 2018 +0800</div><div class="line"></div><div class="line">    add second </div><div class="line"></div><div class="line">commit a897c7ac82eb2de3e8268454d19f2ec91a5be9bd</div><div class="line">Author: lennonover &lt;lennonover@gmail.com&gt;</div><div class="line">Date:   Tue Jan 23 15:56:04 2018 +0800</div><div class="line"></div><div class="line">    add first</div></pre></td></tr></table></figure>
<p>如何把四次合并到一起，并且只保留 最后一次 的 Git message 呢？推荐 git rebase 进行合并操作。</p>
<p>合并最后四个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase -i HEAD~4</div></pre></td></tr></table></figure>
<p>git 会打开一个互动界面，方便用户对历史提交进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">pick 969161b add first</div><div class="line">pick 14c69cf add second </div><div class="line">pick b246936 add third</div><div class="line">pick 5b192dc add forth </div><div class="line"></div><div class="line"># Rebase 44adff4..5b192dc onto 44adff4 (4 command(s))</div><div class="line">#</div><div class="line"># Commands:</div><div class="line"># p, pick = 使用该提交</div><div class="line"># r, reword = 使用该提交，但需要编辑提交信息</div><div class="line"># e, edit = 使用该提交，但此处暂停并提供修改机会</div><div class="line"># s, squash = 使用该提交，但合并到上一个提交记录中</div><div class="line"># f, fixup = 类似 squash，但丢弃当前提交记录的提交信息</div><div class="line"># x, exec = 执行 shell 命令</div><div class="line"># d, drop = 移除当前提交</div></pre></td></tr></table></figure>
<p>我们需要把前面的 pick 改为 squash 这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pick 969161b add first</div><div class="line">squash 14c69cf add second </div><div class="line">squash b246936 add third</div><div class="line">squash 5b192dc add forth</div></pre></td></tr></table></figure>
<p>完成后，使用 <code>:wq</code> 保存并退出。这个时候则需要在下一步中对这 4 条 commit 信息进行修改和保存(如果 fixup 的话，则直接丢弃其它记录，省去下一步操作)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># This is a combinatin of 4 commits.</div><div class="line"># This is the 1st commit message:</div><div class="line">add first </div><div class="line"># This is the commit message #2:</div><div class="line">add second </div><div class="line"># This is the commit message #3:</div><div class="line">add third</div><div class="line"># This is the commit message #4:</div><div class="line">add forth</div></pre></td></tr></table></figure>
<p>使用 <code>:wq</code> 后，通过 git log 可以看到仅剩一条 commit 记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">commit c2391a59bf51240a60ab4c8455b251cff1ec3cdd</div><div class="line">Author: lennonover &lt;lennonover@163.com&gt;</div><div class="line">Date:   Wed Jan 24 15:01:12 2018 +0800</div><div class="line"></div><div class="line">    add stylelint-0.0.3</div></pre></td></tr></table></figure>
<p>rebase 的风险：</p>
<p>当待合并 commit 记录中杂糅着他人的 commit 记录，此时就不可以再对这部分 commit 记录做合并操作。</p>
<p>但只要新开分支且保持分支独立开发，杂糅的情况就不存在。</p>
<h2 id="推送到仓库"><a href="#推送到仓库" class="headerlink" title="推送到仓库"></a>推送到仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin feature-wz-qx</div></pre></td></tr></table></figure>
<h2 id="提交-Merge-Request-申请"><a href="#提交-Merge-Request-申请" class="headerlink" title="提交 Merge Request 申请"></a>提交 Merge Request 申请</h2><p>请求相关同学从你的 feature-wz-qx 合并分支</p>
<ul>
<li>提交 Merge Request：</li>
</ul>
<p>通过「＋Create Merge Request」按钮创建一个 Merge Request；</p>
<ul>
<li>指定「Assignee」：</li>
</ul>
<p>指定需要 review 你代码的同学，禁止指定自己；</p>
<ul>
<li>更改「Target branch」：</li>
</ul>
<p>改变为需要合并进去的目标分支；</p>
<ul>
<li>设置合并后删除被合并分支的选项：</li>
</ul>
<p>勾选「Remove source branch when merge request is accepted.」选项，在合并完成后删除源分支，控制分支总数量；</p>
<ul>
<li>提交合并请求</li>
</ul>
<p>完成上述设置后，相关同学将会收到邮件通知，此时可进入 GitLab 进行 code review。如果发现问题则对问题代码进行点评并拒绝关闭申请，反之则通过合并申请。</p>
<h2 id="修复-Bug"><a href="#修复-Bug" class="headerlink" title="修复 Bug"></a>修复 Bug</h2><p>发现 bug 了,从 develop 分支上新建分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b hotfix/xxx develop</div></pre></td></tr></table></figure>
<p>改完推送到仓库后提交 Merge Request 申请</p>
<h2 id="减少冲突"><a href="#减少冲突" class="headerlink" title="减少冲突"></a>减少冲突</h2><p>从我们的工作流程上来说，代码合并导致的问题，一般都发生在特性、修复分支合并到 master 或者 develop 的时候，因为这个时候开始，才是真正与其他分支汇合，不同的改动会发生冲突。而且合并没法完全避免，我们只能去思考如何减少合并冲突。</p>
<ul>
<li>合理的分工，人员职责划分尽量清晰，减少互相之间的交叉，减少多个人同时改动同一份代码的几率</li>
<li>合适的合并工具</li>
<li>合并后的代码检查</li>
<li>公共代码改动，要通知各使用方变化点</li>
<li>code review</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/01/15/npm-script/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/15/npm-script/" itemprop="url">
                  npm script
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T23:45:36+08:00">
                2018-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>读书少了最近才看到这篇文章 <a href="https://www.keithcirkel.co.uk/why-we-should-stop-using-grunt/" target="_blank" rel="external">Why we should stop using Grunt &amp; Gulp</a>。文章中笔者建议大家使用 npm 作为替代方案，绝对要打 call。npm 的 scripts 配置可以更简单的实现这些构建工具的所有功能。确实，npm script 相比 grunt、gulp 之类的构建工具简单很多，它消除了这些构建工具所带来的抽象层，并带给我们更大的自由度。而且随着社区的发展，各种基础工具你都可以信手拈来，只要你会使用 <a href="https://www.npmjs.com/" target="_blank" rel="external">npmjs.com</a> 去搜索，或者去 <a href="https://libraries.io/" target="_blank" rel="external">libraries.io</a> 上搜索（当然我们公司的工作流还是在农耕火种时代。</p>
<h2 id="npm-script"><a href="#npm-script" class="headerlink" title="npm script"></a>npm script</h2><p>npm 为我们提供了快速创建 package.json 文件的命令 npm init，执行该命令会问几个基本问题，如包名称、版本号、作者信息、入口文件、仓库地址、许可协议等，多数问题已经提供了默认值。</p>
<p>npm 允许在 package.json 文件里面，使用 scripts 字段定义脚本命令，而执行它的是 npm 核心命令之一的 npm run-script 命令（简称 npm run ），npm run 就会自动新建一个 Shell 并且可以从 package.json 中解析出 scripts 对象，然后将该对象的键作为 npm run 的第一个参数，它会在操作系统的默认终端中执行该键对应的命令。例如下面的 package.json：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">'name'</span>: <span class="string">'hello-npm-script'</span>,</div><div class="line">  <span class="string">'version'</span>: <span class="string">'0.1.0'</span>,</div><div class="line">  <span class="string">'main'</span>: <span class="string">'index.js'</span>,</div><div class="line">  <span class="string">'scripts'</span>: &#123;</div><div class="line">    <span class="string">'lint:js'</span>: <span class="string">'eslint *.js'</span>,</div><div class="line">    <span class="string">'lint:css'</span>: <span class="string">'stylelint *.less'</span>,</div><div class="line">    <span class="string">'test'</span>: <span class="string">'npm run lint:js &amp;&amp; npm run lint:css'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果运行 <code>npm run lint:js</code> ，npm 将在终端中执行 <code>eslint *.js</code>。执行 <code>npm run xxx</code> 时会将 <code>node_modules/.bin</code> 加入终端的 PATH 环境变量中，这样你就可以直接运行那些作为依赖安装的二进制模块，也就是说你不需要 <code>./node_modules/.bin/eslint **.js</code> 或 <code>$(npm bin)/eslint **.js</code> 这样来指定命令的路径。</p>
<p>如果运行 <code>npm run test</code> 则表示子命令的执行顺序是先 <code>lint:js</code> 后  <code>lint:css</code> 来，实现了多个 npm script 串行执行。</p>
<p>由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符 也就是 <code>*</code>。</p>
<h2 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h2><p>npm 可以在 scripts 中为任何可执行的命令指定 <code>pre-</code> 和 <code>post-</code> 钩子。例如，当运行 <code>npm run lint:js</code> 时，即便是没有在 scripts 中定义对应的 <code>pre-</code> 命令，npm 也会首先执行 <code>npm run prelint:js</code>，接着才是 <code>npm run lint:js</code>，最后是 <code>npm run postlint:js</code>。</p>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p><code>--</code> 是 npm 用来传递参数的，例如 <code>npm run lint:js -- a.js</code> 将运行 <code>`eslint *.js a.js</code></p>
<h2 id="命令行自动补全"><a href="#命令行自动补全" class="headerlink" title="命令行自动补全"></a>命令行自动补全</h2><ul>
<li><p>不带任何参数运行 npm run 能列出 scripts 对象中定义的所有命令，，再结合管道操作符、less 命令（ less 是 linux 里面的工具）</p>
</li>
<li><p>npm 自身也提供了自动完成工具 <a href="https://docs.npmjs.com/cli/completion" target="_blank" rel="external">completion</a></p>
</li>
</ul>
<h2 id="跨平台运行"><a href="#跨平台运行" class="headerlink" title="跨平台运行"></a>跨平台运行</h2><ul>
<li><p>使用 <a href="http://www.yolinux.com/TUTORIALS/unix_for_dos_users.html" target="_blank" rel="external">跨平台的命令</a></p>
</li>
<li><p>使用 node packages 。可以使用 node packages 来取代 shell 命令。</p>
</li>
</ul>
<h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>  因为 JSON 规范不支持添加注释，所以不能在 package.json 里添加注释。</p>
<h2 id="常用脚本"><a href="#常用脚本" class="headerlink" title="常用脚本"></a>常用脚本</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 删除目录</span></div><div class="line"><span class="string">"clean"</span>: <span class="string">"rimraf dist/*"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 本地搭建一个 HTTP 服务</span></div><div class="line"><span class="string">"serve"</span>: <span class="string">"http-server -p 9090 dist/"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 打开浏览器</span></div><div class="line"><span class="string">"open:dev"</span>: <span class="string">"opener http://localhost:9090"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 实时刷新</span></div><div class="line"> <span class="string">"livereload"</span>: <span class="string">"live-reload --port 9091 dist/"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 构建 HTML 文件</span></div><div class="line"><span class="string">"build:html"</span>: <span class="string">"jade index.jade &gt; dist/index.html"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 只要 CSS 文件有变动，就重新执行构建</span></div><div class="line"><span class="string">"watch:css"</span>: <span class="string">"watch 'npm run build:css' assets/styles/"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 只要 HTML 文件有变动，就重新执行构建</span></div><div class="line"><span class="string">"watch:html"</span>: <span class="string">"watch 'npm run build:html' assets/html"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 部署到 Amazon S3</span></div><div class="line"><span class="string">"deploy:prod"</span>: <span class="string">"s3-cli sync ./dist/ s3://example-com/prod-site/"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 构建 favicon</span></div><div class="line"><span class="string">"build:favicon"</span>: <span class="string">"node scripts/favicon.js"</span>,</div></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="external">npm scripts 使用指南</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/01/09/树莓派安装-Ubuntu-Mate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/09/树莓派安装-Ubuntu-Mate/" itemprop="url">
                  树莓派安装 Ubuntu Mate
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-09T22:53:36+08:00">
                2018-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近买个树莓派准备做下载机和低配版的 NAS ，昨天晚上装了 Ubuntu Mate的系统挺简单的特意分享下</p>
<h2 id="树莓派"><a href="#树莓派" class="headerlink" title="树莓派"></a>树莓派</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE" target="_blank" rel="external">树莓派</a>（英语：Raspberry Pi），是一款基于Linux的单板机电脑。它由英国的树莓派基金会所开发，目的是以低价硬件及自由软件促进学校的基本计算机科学教育。</p>
<p>我买的是最新的3代 B ，增加了无线和蓝牙模块方便了很多。<br>树莓派检查,树莓派在没有插入TF卡的时候通电，如果红灯亮了并且可以持续亮着而不是闪烁，就证明硬件是没问题的。</p>
<p>电源没有购买用的是手机的 5v/2A 的电源，有四个 USB 接口和一个 HDMI 接口</p>
<h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>一开始的时候树莓派是没有系统的，需要自己准备内存卡。官方推荐是使用其官方工具NOOBS安装工具，很小白，</p>
<ul>
<li>解压<a href="https://www.raspberrypi.org/downloads/noobs/" target="_blank" rel="external">NOOBS.zip</a>文件</li>
<li>将解压的文件复制到SD卡上面(SD 格式话推荐用 <a href="https://www.sdcard.org/downloads/formatter_4/eula_windows/" target="_blank" rel="external">sdcard</a>)</li>
<li>将 SD 卡插入到树莓派里面开机按照指示做就可以了</li>
</ul>
<p>我今天要说的是写入系统进去。那么怎么写入呢？在windows下写入，用Win32DiskImager写入镜像。</p>
<ul>
<li>在官网下载最新版的Ubuntu Mate，<a href="https://ubuntu-mate.org/raspberry-pi/" target="_blank" rel="external">官网</a></li>
<li>下载 <a href="https://sourceforge.net/projects/win32diskimager/" target="_blank" rel="external">Win32DiskImager</a></li>
<li>下载 <a href="https://www.sdcard.org/downloads/formatter_4/" target="_blank" rel="external">sdformatter</a> 格式化 SD 卡</li>
<li>用 Win32DiskImager 写入之前下载的 ubuntu-mate-16.10-desktop-armhf-raspberry-pi-3.img 镜像</li>
<li>将TF卡插入树莓派，启动按照界面提示选择安装语言、用户名、计算机名、选择时区。系统将自行安装后重启。进度条有可能会卡在安装界面等个几分钟重启就好了</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>树莓派也可以装个 web 服务器，要想外网访问可以做个内网穿透，推荐个好用的 <a href="https://www.zerotier.com/" target="_blank" rel="external">ZeroTier</a> 一款非常简单易用的内网穿透工具，不需要配置，就能实现虚拟局域网的组建,支持 Windows、macOS、Linux 三大主流平台，iOS、Android 两大移动平台，以及 QNAP（威连通）、Synology（群晖）、Western Digital MyCloud NAS（西部数据）三个 NAS 平台</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/01/03/ARIA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/03/ARIA/" itemprop="url">
                  ARIA
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-03T22:57:29+08:00">
                2018-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ARIA 是 <code>Accessible Rich Internet Applications</code> 的缩写。它是 W3C 的 Web 无障碍推进组织 <a href="https://www.w3.org/WAI/" target="_blank" rel="external">Web Accessibility Initiative / WAI</a> 在2014年3月20日发布的可访问富互联网应用实现指南。2017年11月2日，发布了 <a href="https://www.w3.org/TR/wai-aria-1.1/" target="_blank" rel="external">WAI-ARIA 1.1</a> 的提案推荐标准,在1.0版本的基础上，添加了一些新机制，使 HTML + ARIA 无障碍模型更加完整，并支持图形及数字出版的无障碍需求。</p>
<ul>
<li>几种场景<ul>
<li>一个由 js 生成的页面</li>
<li>一个不支持鼠标的页面</li>
<li>一个不支持键盘的页面</li>
<li>一部没有字幕的电影</li>
</ul>
</li>
<li>两组数据<ul>
<li>全球目前有超过10亿残疾人 占全球人口约15%</li>
<li>全球网民数量突破30亿约占总人口42%</li>
</ul>
</li>
</ul>
<p>以上这种场景的对于一个视觉或者听觉有障碍的人来说还能正常访问吗？这就是要 <code>WAI-ARIA</code> 的目的。<code>WAI-ARIA</code> 适用于跨越某些领域的障碍，这些领域存在的无障碍问题无法通过原生 HTML 进行管理。它通过允许您指定某些属性来发挥作用，这些属性可以修改元素转换成无障碍树的方式。</p>
<h2 id="ARIA-是怎么做的"><a href="#ARIA-是怎么做的" class="headerlink" title="ARIA 是怎么做的"></a>ARIA 是怎么做的</h2><p>ARIA属性可以被 <a href="https://www.nvaccess.org/" target="_blank" rel="external">NVDA</a> 等读屏软件调用系统API识别， 转化成语音。</p>
<p>例如我们使用列表项作为一种自定义复选框</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>&gt;</span></div><div class="line">  javcscript</div><div class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div></pre></td></tr></table></figure>
<p>正常的人是能正确识别的，但是屏幕阅读器却不会给予任何指示来说明该元素旨在作为复选框使用，因此弱视用户可能会完全错过该元素。<br>如果使用 ARIA 属性，我们就可以为元素提供缺少的信息，以便屏幕阅读器能正确解读它。 我们在以上代码中添加了 role 和 aria-checked 属性，将该元素显式标识为一个复选框，并指定它在默认情况下处于选中状态。该列表项现在将添加到无障碍树中，屏幕阅读器将把它正确地报告为一个复选框。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"checkbox"</span> <span class="attr">role</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span> <span class="attr">aria-checked</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  javcscript</div><div class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div></pre></td></tr></table></figure>
<p>ARIA 通过更改和补充标准 DOM 无障碍树来发挥作用。并且尽可能正确地使用 html 标签，原生标签对 ARIA 支持得更好。在实再自定义控件的时候，添加 ARIA 相关属性可以例控件能正确被读屏软件识别。 html5 语义化标签与 ARIA 有重叠的地方，用新的语义化标签但还是推荐添加 ARIA 属性。<br>例如上面的自定义复选框,标准 HTML <input type="checkbox"> 元素都不需要额外的 role=”checkbox” ARIA 属性就能正确声明。</p>
<h2 id="ARIA-on-HTML"><a href="#ARIA-on-HTML" class="headerlink" title="ARIA on HTML"></a>ARIA on HTML</h2><p>ARIA on HTML 中使用有其自己的规范，在 <a href="http://validator.w3.org/nu/" target="_blank" rel="external">这个</a> 网站可以检测 ARIA 使用的是否标准。</p>
<p>ARIA 属性包括三个方面：角色属性值(roles), 状态属性值(states), 和属性表(properties)  参考网站： <a href="https://www.w3.org/TR/html-aria/#index-aria-main" target="_blank" rel="external">W3C</a></p>
<p>浏览器支持情况参见 <a href="https://caniuse.com/#search=aria" target="_blank" rel="external">caniuse</a> </p>
<ul>
<li><p>HTML5 元素有的不应该重新定义一个添加ARIA</p>
<p>  如果你使用的元素(HTML5)具有语义化，应该使用这些元素，而不应该重新定义一个添加ARIA的角色、状态或属性的元素。</p>
<p>  下面以 role=heading 一个上button元素。这是不允许的，因为该 button 元素具有默认特征与标题角色冲突。</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">role</span>=<span class="string">"heading"</span>&gt;</span>search<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>  哪些情况下可以使用？</p>
<ul>
<li>在HTML(HTML5)元素特性不管支持或不支持，只要不具语义化，就可以使用ARIA</li>
<li>排除视觉设计约束使用一个特定的元素，但不能是样式上所需的元素</li>
<li>目前尚不支持的HTML特性</li>
</ul>
</li>
</ul>
<ul>
<li><p>规所有的ARIA制作控件都必须具有键盘 (keyboard) 事件。</p>
</li>
<li><p>ARIA role的必需属性不可省略</p>
<p>  正确</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;span role=&quot;checkbox&quot; aria-checked=&quot;false&quot; aria-labelledby=&quot;foo&quot; tabindex=&quot;0&quot;&gt;&lt;/span&gt;</div></pre></td></tr></table></figure>
<p>  错误</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;span role=&quot;checkbox&quot; aria-labelledby=&quot;foo&quot; tabindex=&quot;0&quot;&gt;&lt;/span&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>具有ARIA role的元素必须在正确的范围内</p>
<p>  正确</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div role=&quot;list&quot;&gt; </div><div class="line">	&lt;span role=&quot;listitem&quot;&gt;Rainbow Trout&lt;/span&gt; </div><div class="line">	&lt;span role=&quot;listitem&quot;&gt;Brook Trout&lt;/span&gt;</div><div class="line">	&lt;span role=&quot;listitem&quot;&gt;Lake Trout&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>  错误</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt; </div><div class="line">	&lt;span role=&quot;listitem&quot;&gt;Rainbow Trout&lt;/span&gt; </div><div class="line">	&lt;span role=&quot;listitem&quot;&gt;Brook Trout&lt;/span&gt;</div><div class="line">	&lt;span role=&quot;listitem&quot;&gt;Lake Trout&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ARIA-在-HTML-中由组成"><a href="#ARIA-在-HTML-中由组成" class="headerlink" title="ARIA 在 HTML 中由组成"></a>ARIA 在 HTML 中由组成</h2><p>ARIA 在 HTML 中由两部分组成，一个 role ，表示元素的作用；一个是 aria- 表示元素的属性或状态。</p>
<ul>
<li>role</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">role值</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">role值</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">role值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">alert</td>
<td style="text-align:left">警告</td>
<td style="text-align:left">alertdialog</td>
<td style="text-align:left">警告框</td>
<td style="text-align:left">application</td>
<td style="text-align:left">应用</td>
</tr>
<tr>
<td style="text-align:left">button</td>
<td style="text-align:left">按钮</td>
<td style="text-align:left">checkbox</td>
<td style="text-align:left">复选框</td>
<td style="text-align:left">grid</td>
<td style="text-align:left">网格</td>
</tr>
<tr>
<td style="text-align:left">gridcell</td>
<td style="text-align:left">网格单元</td>
<td style="text-align:left">group</td>
<td style="text-align:left">组合</td>
<td style="text-align:left">heading</td>
<td style="text-align:left">应用程序标题</td>
</tr>
<tr>
<td style="text-align:left">listbox</td>
<td style="text-align:left">列表框log    日志</td>
<td style="text-align:left">menu</td>
<td style="text-align:left">菜单</td>
<td style="text-align:left">treeitem</td>
<td style="text-align:left">树结构选项</td>
</tr>
<tr>
<td style="text-align:left">menubar</td>
<td style="text-align:left">菜单栏</td>
<td style="text-align:left">menuitem</td>
<td style="text-align:left">菜单项</td>
<td style="text-align:left">menuitemcheckbox</td>
<td style="text-align:left">可复选的菜单项</td>
</tr>
<tr>
<td style="text-align:left">menuitemradio</td>
<td style="text-align:left">只能单选的菜单项</td>
<td style="text-align:left">option</td>
<td style="text-align:left">选项</td>
<td style="text-align:left">presentation</td>
<td style="text-align:left">陈述</td>
</tr>
<tr>
<td style="text-align:left">progressbar</td>
<td style="text-align:left">进度条</td>
<td style="text-align:left">radio</td>
<td style="text-align:left">单选</td>
<td style="text-align:left">radiogroup</td>
<td style="text-align:left">单选按钮组</td>
</tr>
<tr>
<td style="text-align:left">region</td>
<td style="text-align:left">区域row    行</td>
<td style="text-align:left">separator</td>
<td style="text-align:left">分割</td>
<td style="text-align:left">tree</td>
<td style="text-align:left">树形</td>
</tr>
<tr>
<td style="text-align:left">slider</td>
<td style="text-align:left">滑动条</td>
<td style="text-align:left">spinbutton</td>
<td style="text-align:left">微调</td>
<td style="text-align:left">tab</td>
<td style="text-align:left">tab标签</td>
</tr>
<tr>
<td style="text-align:left">tablist</td>
<td style="text-align:left">标签列表</td>
<td style="text-align:left">tabpanel</td>
<td style="text-align:left">标签面板</td>
<td style="text-align:left">timer</td>
<td style="text-align:left">计数</td>
</tr>
<tr>
<td style="text-align:left">toolbar</td>
<td style="text-align:left">工具栏</td>
<td style="text-align:left">tooltip</td>
<td style="text-align:left">提示文本</td>
</tr>
</tbody>
</table>
<ul>
<li><p>aria 属性或状态</p>
<ul>
<li><p>aria-label</p>
<ul>
<li>视觉上能理解，读屏软件不能理解的可以用 aria-label，和 img alt 属性效果相同。</li>
<li>placeholder 不能被读屏软件识别，如果不带 label 的 form 表单，需要用 aria-label标注。个人测试 iOS10 上 VoiceOver 是可以读 placeholder ，如果两个属性同时存在会先读 aria-label 后读 placeholder ，chrome 插件的 Accessibility Developer Tools 不识别 placeholder。</li>
</ul>
</li>
<li><p>aria-hidden</p>
<p>  隐藏元素的一些对比</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">行为</th>
<th style="text-align:left">读屏软件行为</th>
<th style="text-align:left">兼容性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CSS：visibility:hidden;</td>
<td style="text-align:left">从视觉中隐藏元素，但其原始空间仍然被占用（很像opacity:0）</td>
<td style="text-align:left">不可读</td>
<td style="text-align:left">兼容性好</td>
</tr>
<tr>
<td style="text-align:left">CSS: display:none;</td>
<td style="text-align:left">从视觉中隐藏元素，它的原始空间丢失，下一个元素将取代它的位置</td>
<td style="text-align:left">不可读</td>
<td style="text-align:left">兼容性好</td>
</tr>
<tr>
<td style="text-align:left">HTML5: hidden属性</td>
<td style="text-align:left">类似display：none</td>
<td style="text-align:left">不可读</td>
<td style="text-align:left">IE11+</td>
</tr>
<tr>
<td style="text-align:left">aria-hidden = “true”</td>
<td style="text-align:left">内容显示在浏览器，但读屏软件不可读</td>
<td style="text-align:left">不可读</td>
<td style="text-align:left">IE11+</td>
</tr>
<tr>
<td style="text-align:left">CSS: .visuallyHidden类</td>
<td style="text-align:left">视觉不显示，工作流不存在</td>
<td style="text-align:left">可读</td>
<td style="text-align:left">兼容性好</td>
</tr>
</tbody>
</table>
<pre><code>- aria-pressed

    表示按下的状态，可选值有：true, false, mixed, undfined.默认为undfined, 表示按下状态未知；true表示元素往下（按钮按下）；false表示元素抬起；mixed表示元素同时有按下和没有按下的状态

    <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">role</span>=<span class="string">"button"</span> <span class="attr">tabindex</span>=<span class="string">"0"</span> <span class="attr">aria-pressed</span>=<span class="string">"false"</span> <span class="attr">aria-disabled</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>

- aria-selected

    表示选择状态,可选值有：true, false, undefined。 默认为undefined，表示元素选择状态未知;true表示元素已选择;false表示未被选中。

    <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"tablist"</span> <span class="attr">role</span>=<span class="string">"tablist"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">role</span>=<span class="string">"tab"</span> <span class="attr">aria-selected</span>=<span class="string">"true"</span> <span class="attr">tabindex</span>=<span class="string">"0"</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">role</span>=<span class="string">"tab"</span> <span class="attr">aria-selected</span>=<span class="string">"false"</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span>&gt;</span>美国<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2017/12/28/2017-总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/28/2017-总结/" itemprop="url">
                  2017 总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T12:51:12+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先感谢在这一年给过我帮助的所有@同事，@亲人和@朋友。从毕业到今年算是第一个完整的工作了一个年，也是时候给自己做一个2017年的总结了。</p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul>
<li><p>openlayer</p>
<p>  公司三月份开始有要做一套企业级的 webGIS 中间件，解决老版本 GIS 各种痛点问题。我们组就分配了我一个人来做这个中间件的 JS 端开发，当时全公司只有一个人有过 webGIS3 开发经验，还离职了，所以上半年我的精力主要放在了研究 openlayer 上，仔细研究过 openlayer 的源码以及 openlayer 使用到的依赖，对 openlayer 的实现及原理进行了深入的理解，产出了 openlayer4.0 实用教程 和 中间件的 API。这个中间件也是我第一个主开发的项目，开发后成功支援公司多个产品线。</p>
</li>
<li><p>ES6</p>
<p>  中间件结束后进入业务组开发，时间还算空余，我系统的学习了一下 ES6 的常用模块，看了阮一峰的《ECMAScript6入门》。</p>
</li>
<li><p>React</p>
<p>  之前断断续续的学习了 React 现在已经到 16 ，10月份从北京出差刚回来，公司有个用 React 技术栈开发的同事要离职，确实也是向我们这种传统的互联网公司对这些技术是有些保守，当然也和团队有一定的原因，我们组没有一个有 React 开发经验的，我也是，只是跑过 TODO 的 DEMO。出现了项目无人接手的情况，我申请了接手这个项目，好在过程还算顺利 React+Redux+Route 全家桶加上业务逻辑简单，算是对 React 有个初步的开发经验。</p>
</li>
<li><p>基础建设</p>
<p>  主导配置了 <a href="https://github.com/lennonover/eslint-config-fhfe">eslint</a>、<a href="https://github.com/lennonover/stylelint-config-fhfe">stylelint</a> 代码检查工具，推进团队的代码风格统一，帮助我们发现代码潜在错误，编写适应公司业务的 cssrest <a href="https://github.com/lennonover/uan.css">uancss</a>。并做可视化大片展示调研和预研工作。</p>
</li>
<li><p>其他</p>
<p>  帮公司一个产品线合并各项目组的图标，做了两套支持多组编码的图标库；学了网易云课堂微专业交互设计，其他的零碎知识，比如 Fetch 、Node 、Promise 、Docker 等等。</p>
</li>
</ul>
<h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><ul>
<li><p>JSConf 2017</p>
<p>  团队组织了参加7月在上海的 JSConf 2017。</p>
</li>
<li><p>D2 </p>
<p>  刚刚结束的第十二届前端技术论坛，这届 D2 感觉很棒，缺点就是确实几乎没有设计类的主题了，没记错的 D2 是 <code>Developer</code> and <code>Designer</code> 的意思，但这几年大家都一窝蜂的网大前端的方向，前端的本源是个值得思考的问题。</p>
</li>
</ul>
<p>话说参加大会也就是扩展技术广度和深度、锻炼沟通能力的机会，最后也是来找差距的。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li><p>culture shock</p>
<p>  今年一年看了不少好剧 南国的《红白玫瑰》 、 赖川声的《一仆二主》 、陕西人《白鹿原》、铁三角的《断金》、音乐剧《保镖》等等十几场剧，每次工作累的时候比较喜欢一个人进剧场享受文化冲击，在北京出差那个一个多月也是国家大剧院戏充实了浮躁的出差的时间，还见到了林怀民老先生。<br>  展览最大惊喜是在北京出差有幸遇到 <code>中国美术馆</code> 的世纪豪展，徐悲鸿、齐白石、刘海粟三卫大师的真迹和故宫的 <code>千里江山图</code> 。其他最多就是在 NUA 《潘玉良》、《井上有一》、《复调》等等。</p>
</li>
<li><p>书</p>
<p>  今年算是读书最少了的一年了，好几本都没看完,<br>  《ECMAScript6 入门》<br>  《Javascript 设计模式》<br>  《野草》</p>
</li>
<li><p>其他</p>
<p>  用项目奖给老姐换了个 8P，自己也换了个 MIUI 玩。帮朋友拍过几场婚礼和接了福特的一个广告的后期，和老同学聚了几次，出去了几趟。艺术近年也向新的媒介发出了探索，随着3D、VR、AR 技术的发展新媒体艺术的参与者越来越多，这对于艺术的普及、连接普通⼈和艺术也有着巨⼤的潜⼒，我不懂艺术，这是都是生活的一种状态，就是希望可以在前端领域把这个载体做的更好。</p>
</li>
</ul>
<h2 id="2018-TODO"><a href="#2018-TODO" class="headerlink" title="2018 TODO"></a>2018 TODO</h2><ul>
<li><p>React</p>
</li>
<li><p>前端在交互、视觉上更多的探索</p>
</li>
<li><p>技术水平的提升：宽度和深度</p>
</li>
<li><p>技术类的书籍很多都开了头但没能读完 18年能坚持读完</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2017/12/22/混乱/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/22/混乱/" itemprop="url">
                  混乱
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-22T23:11:30+08:00">
                2017-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在地下墓穴里有一个死去的女人，     </p>
<p>这个死去的女人不愿意死去。           </p>
<p>在书架的某一层上，           </p>
<p>有一些非常古老的书讲述着一段梦想者所不曾经历的过去。          </p>
<p>一段无法忆起的记忆在前世中活动。            </p>
<p>幻想、思想和回忆交织在一起。          </p>
<p>灵魂梦想着，思想着，然后想象着。            </p>
<p>诗人把我们带到了一个临界状态，         </p>
<p>接近一个我们害怕超出的边界，介于疯癫与理性，生者与死者。            </p>
<p>最轻的声响酝酿着一场灾难。           </p>
<p>四面吹来的风酝酿着万物的混乱一片。           </p>
<p>喃喃细语和大声喧哗互相伴随。          </p>
<p>我们学会了预感的存在论。            </p>
<p>我们被放入前听觉中。          </p>
<p>我们被要求留心最细弱的迹象。          </p>
<p>在这宇宙的边界处，一切都是现象前的迹象。            </p>
<p>迹象越是微弱，它就越有意义，因为它预示着起源。         </p>
<p>由于所有的迹象都被理解为起源，         </p>
<p>它们好像不断地反复重新开始着故事。           </p>
<p>我们从中接受了天才的基本教导。         </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2017/12/17/D2-quic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/17/D2-quic/" itemprop="url">
                  D2-QUIC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T22:04:10+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  昨天在参加阿里 D2 的时候听腾讯的黄佳琳老师分享 <code>QQ空间HTTP2加速实践</code> 时她提到在今 QQ 空间 2017年开始使用 QUIC 协议。看到 QUIC 时就想腾讯这么冒进了敢用它！！！至于为什么会这么想，请继续。</p>
<h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>  <a href="https://en.wikipedia.org/wiki/QUIC" target="_blank" rel="external">QUIC 维基百科</a><br>  <a href="https://www.youtube.com/watch?v=hQZ-0mXFmk8" target="_blank" rel="external">Google Develop Live</a></p>
<p>  QUIC 是谷歌在 2013 年实现，2014 推出的一种实验性的传输层网络传输协议。 QUIC 全称是 Quick UDP Internet Connections 就是快速 UDP 网络连接。一个它以UDP为基础，实验性传输层协议。</p>
<h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><p>  web 平台的数据传输都基于 TCP 协议。TCP协议在创建连接之前需要进行三次握手，如果需要提高数据交互的安全性，既增加传输层安全协议（TLS），还会增加更多的握手次数。<br>  正因为TCP协议连接建立的成本相对较高，可以通过TCP快速打开（TCP Fast Open）来减少建立连接时的握手次数。但是该技术目前应用较少。</p>
<p>  UDP协议是无连接协议。客户端发出UDP数据包后，只能“假设”这个数据包已经被服务端接收。这样的好处是在网络传输层无需对数据包进行确认，但存在的问题就是为了确保数据传输的可靠性，应用层协议需要自己完成包传输情况的确认。</p>
<blockquote>
<p>来源维基百科 ： 对于 Google 来说优化 TCP 协议是一个长期目标，QUIC 旨在创建几乎等同于 TCP 的独立连接，但有着低延迟，并对类似 SPDY 的多路复用流协议有更好的支持。 如果 QUIC 协议的特性被证明是有效的，这些特性以后可能会被迁移入后续版本的 TCP 和 TLS 协议（它们都有很长的开发周期）。</p>
</blockquote>
<p>  TCP 协议的实现是高度管制的。TCP 协议栈通常由操作系统实现，如 Linux、Windows 内核或者其他移动设备操作系统。修改 TCP 协议是一项浩大的工程，因为每种设备、系统的实现都需要更新。</p>
<p>  UDP 协议在操作系统层面实现相对简单，基于 UDP 协议实现新的协议以验证 Google 对于 TCP 协议改进的理论，不需要操作系统内核层面的更改，验证成本相对较低。</p>
<p>  可以说 QUIC 是夹在 HTTP2 和 UDP 的中间部分就像汉堡。</p>
<p>  <img src="http://ob6nlbpso.bkt.clouddn.com/053.png" alt="地位"></p>
<h2 id="QUIC-特点"><a href="#QUIC-特点" class="headerlink" title="QUIC 特点"></a>QUIC 特点</h2><p>  QUIC 协议的主要目的，是为了整合 TCP 协议的可靠性和 UDP 协议的速度和效率。</p>
<ul>
<li><p>避免队头阻塞</p>
<p>HTTP 1.1 协议的并发请求并非是直接解决了 HOC 的问题，而是尽可能减少 HOC 造成的影响。 </p>
<p>SPDY 它采用了多路复用(Multiplexing) 技术也是解决不了这个问题。TCP 协议如果发生了丢包或者错包，数据就会被重传，后面的包就得停下来等这个包重新传输，也就是发生了队头阻塞，TCP 协议的设计者们又发明了滑动窗口，滑动窗口的概念大幅度提高了 TCP 传输数据时抗干扰的能力，一般丢失一两个 ACK 根本没关系。但如果是发送的包丢失，或者出错，窗口就无法向前滑动，出现了队头阻塞的现象。       </p>
<p>队头阻塞不仅仅在 HTTP 层存在，在 TCP 层也存在，这也正是 QUIC 协议要解决的问题。QUIC 协议也采用了多路复用思想。</p>
<p>QUIC协议直接通过底层使用 UDP 协议天然的避免了 SPDY 和 HTTP/2 协议由于 TCP 协议在处理包时是有严格顺序而遇到前序包阻塞的问题。由于UDP协议没有严格的顺序，当一个数据包遇到问题需要重传时，只会影响该数据包对应的资源，其他独立的资源不会受到影响。</p>
</li>
<li><p>重传与恢复</p>
<p>丢包恢复一共有两种方法：前向纠错（FEC）和重传。前向纠错可以减少重传，但需要在保重添加冗余信息，用 XOR 实现。如果前向纠错不能回复包，才启用重传，重传的不是旧包，而是重新构造的包。</p>
<p>前向纠错（FEC）：FEC 采用简单异或的方式（也就是相同数字异或成 0，不同数字异或成 1）。每次发送一组数据，包括若干个数据包后，并对这些数据包依次作异或运算，最后的结果作为一个 FEC 包再发送出去。接收方收到一组数据后，根据数据包和 FEC 包即可以进行校验和纠错。</p>
<p>对于某些重要的数据包，如初始密钥协商时的数据包，在建立连接时非常重要，如果这类包丢失会阻塞整体数据流。QUIC 对于这一类数据包在确认发生丢失前就会尝试重传，通常是等待较短的时间(如20ms)没收到确认后就马上再次发送。这样在网络中会有若干个相同的包同时传输，只要有一个能成功抵达就完成了连接，这样降低了丢包率。接收方对于关键数据包的多次发送和普通数据包的超时重传，都采用相同的重复包处理机制</p>
<p>QUIC在拥塞避免算法的基础上还加入了心跳包，用于减少丢包率</p>
</li>
</ul>
<ul>
<li><p>减少数据包</p>
<p>  QUIC协议在创建连接握手时，只需要1到2个数据包对比传统TCP+TLS协议的传输方式，在创建连接时的4个数据包。</p>
</li>
<li><p>TCP 快速打开 0 个 RTT</p>
<p>  核心思想：将当前会话的上下文缓存在客户端。如果以后需要恢复对话，只需要将缓存发给服务器校验，而不必花费一个 RTT 去等待。<br>  QUIC 握手的过程是需要一次数据交互，0-RTT 时延即可完成握手过程中的密钥协商，比 TLS 相比效率提高了5倍，且具有更高的安全性。 QUIC 在握手过程中使用 Diffie-Hellman 算法协商初始密钥，初始密钥依赖于服务器存储的一组配置参数，该参数会周期性的更新。初始密钥协商成功后，服务器会提供一个临时随机数，双方根据这个数再生成会话密钥。</p>
</li>
<li><p>安全性</p>
<p>  QUIC 协议内置了 TLS 栈，实现了自己的传输加密层，QUIC 对每个散装的 UDP 包都进行了加密和认证的保护，并且避免使用前向依赖的处理方法(，这样每个 UDP 包可以独立地根据 IV 进行加密或认证处理。 QUIC 采用了两级密钥机制：初始密钥和会话密钥。初次连接时不加密，并协商初始密钥。初始密钥协商完毕后会马上再协商会话密钥，这样可以保证密钥的前向安全性，之后可以在通信的过程中就实现对密钥的更新。接收方意识到有新的密钥要更新时，会尝试用新旧两种密钥对数据进行解密，直到成功才会正式更新密钥，否则会一直保留旧密钥有效。</p>
<p>  <a href="https://cs.chromium.org/chromium/src/net/quic/?q=quic&amp;sq=package:chromium" target="_blank" rel="external">​QUIC客户端源码</a></p>
<p>  <a href="https://cs.chromium.org/chromium/src/net/tools/quic/?q=quic&amp;sq=package:chromium" target="_blank" rel="external">QUIC服务端源码</a></p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><p>启用</p>
<p>  Chrome 浏览器（版本50.0或更高）中打开地址： <code>chrome://flags/</code> 在Experimental QUIC protocol 项目勾选 Enabled;然后重启。</p>
<p>  <img src="http://ob6nlbpso.bkt.clouddn.com/sp171219_185424.png" alt="tab"></p>
</li>
<li><p>查看站点是否通过 QUIC 通信</p>
<p>  使用Chrome 选项卡 <code>chrome://net-internals/#quic</code></p>
<p>  <img src="http://ob6nlbpso.bkt.clouddn.com/sp171219_193117.png" alt="sea"></p>
</li>
<li><p>Chrome 插件</p>
<p>  插件 <code>HTTP/2 and SPDY indicator</code> HTTP/2显示蓝色标志，HTTP/2 + QUIC 显示绿色,可以看到 QQ 空间没用 HTTP/2 + QUIC。</p>
<p>  <img src="http://ob6nlbpso.bkt.clouddn.com/sp171218_224234.png" alt="QQ 空间"></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>QUIC 目前处于实验阶段国内”不存在”的协议</li>
<li>QUIC 是基于 UDP 的同为传输层</li>
<li>UDP 通信，所以服务器上的防火墙要打开。网站或项目的服务器需要有传入 443/UDP 的策略，对于客户端来说，允许 443/UDP 接入互联网</li>
<li>想想就目前国内宽带运营商的各种 UDP 限制 。。</li>
</ul>
<p>PS： 今天重新看了下黄佳琳老师分享并没有说支持 QUIC 只是说了 2017 在实验 。。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lennonover" />
          <p class="site-author-name" itemprop="name">lennonover</p>
           
              <p class="site-description motion-element" itemprop="description">一丿口石砳磊</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lennonover</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
