<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>lennonover</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一丿口石砳磊">
<meta property="og:type" content="website">
<meta property="og:title" content="lennonover">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lennonover">
<meta property="og:description" content="一丿口石砳磊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lennonover">
<meta name="twitter:description" content="一丿口石砳磊">
  
    <link rel="alternative" href="/atom.xml" title="lennonover" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">lennonover</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">lennonover</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="null" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">lennonover</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-CSS单位EM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/05/CSS单位EM/">CSS单位EM和REM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="em-和-rem"><a href="#em-和-rem" class="headerlink" title="em 和 rem"></a>em 和 rem</h2><p>em和rem是一个相对的大小，我们可以这样来设置1em，0.5em，1.5em等，而且“em”还可以指定到小数点后三位，比如“1.234em”。“相对”的意思是：</p>
<ul>
<li><p>相对的计算必然会一个参考物，那么这里相对所指的是相对于相对于使用em单位的元素的font-size。比如：如果在一个div中设置字体大小为“16px”，此时这个div的后代元素将继承他的字体大小，除非重新在其后代元素中进行过显示的设置。此时，如果你将其子元素的字体大小设置为<code>0.75em</code>，那么其字体大小计算出来后就相当于<code>0.75 X 16px = 12px</code>；</p>
</li>
<li><p>如果用户通过浏览器的UI控件改变了文字的大小，那么我们整个页面也会进行放大（或缩小），不至于用户改变了浏览器的字体后会致使整个页面崩溃。</p>
</li>
</ul>
<p>也就是说em 和 rem都是灵活、 可扩展的单位，由浏览器转换为像素值，具体取决于您的设计中的字体大小设置。 如果你使用值 1em 或 1rem，它可以被浏览器翻译成 从16px到 160px 或其他任意值。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>em 和 rem 单位提供的这种灵活性和工作方式都很相似，所以最大的问题是，我们何时应使用 em 值，何时应使用 rem 值呢</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>em 和 rem 单位之间的区别是浏览器根据谁来转化成px值。</p>
<h3 id="rem-单位如何转换为像素值"><a href="#rem-单位如何转换为像素值" class="headerlink" title="rem 单位如何转换为像素值"></a>rem 单位如何转换为像素值</h3><p>当使用 rem 单位，他们转化为像素大小取决于页根元素的字体大小，即 html 元素的字体大小。 根元素字体大小乘以你 rem 值。<br>例如，根元素的字体大小 16px，10rem 将等同于 160px，即 10 x 16 = 160。</p>
<h3 id="em-单位如何转换为像素值"><a href="#em-单位如何转换为像素值" class="headerlink" title="em 单位如何转换为像素值"></a>em 单位如何转换为像素值</h3><p>当使用em单位时，像素值将是em值乘以使用em单位的元素的字体大小。<br>例如，如果一个 div 有 18px 字体大小，10em 将等同于 180px，即 10 × 18 = 180。</p>
<blockquote>
<p>有一个比较普遍的误解，认为 em 单位是相对于父元素的字体大小。 事实上，根据W3标准 ，它们是相对于使用em单位的元素的字体大小。父元素的字体大小可以影响 em 值，但这种情况的发生，纯粹是因为继承。 让我们看看为什么以及如何起作用。</p>
</blockquote>
<h4 id="em-单位的遗传效果"><a href="#em-单位的遗传效果" class="headerlink" title="em 单位的遗传效果"></a>em 单位的遗传效果</h4><p>使用 em 单位存在继承的时候，情况会变得比较棘手，因为每个元素将自动继承其父元素的字体大小。 继承效果只能被明确的字体单位覆盖，比如px,vw。</p>
<p>使用 em 单位的元素字体大小根据它们来定。 但该元素可能继承其父元素的字体大小，而父元素又继承其父元素的字体大小，等等。 因此，以 em 为单位的元素字体大小可能会受到其任何父元素的字体大小影响。</p>
<h5 id="em-继承的例子"><a href="#em-继承的例子" class="headerlink" title="em 继承的例子"></a>em 继承的例子</h5><p>如果我们的根元素字体大小为 16px (通常是默认值) 一个子元素 div 里面padding值为 1.5em，该 div 将从根元素继承字体大小 16px。 因此padding会翻译成 24px，即 1.5 x 16 = 24。</p>
<p>如果我们加多一个div来包裹原先的div，然后设置其字体大小为 1.25em呢?</p>
<p>我们包裹的 div 继承根元素字体大小 16px ，并乘以它自己的 1.25em 的字体大小。 这将设置包裹 div 字体大小为 20px，即 1.25 x 16 = 20。</p>
<p>现在我们原始的 div 不再直接从根元素继承,而是从其新的父元素继承字体大小为 20px 1.5em 其padding值现在等于 30px，即 1.5 x 20 = 30。</p>
<p>这个继承效应可以更复杂，如果我们向我们原始的 div 添加 em 字体单位，比方说 1.2em。</p>
<p>Div 从其父级继承 20px 字体大小，然后，乘以它自己的 1.2em 设置，给它 24px，即 1.2 × 20 = 24 新字体大小。</p>
<p>div上的1.5em padding 现在将再次改变大小，用新的字体大小，36px，即 1.5 × 24 = 36 。</p>
<p>最后，为了进一步说明那个 em 单位是相对于他们最终获得(不是父元素)的字体大小，让我们来看看设置padding 1.5em 如果我们显式设置 div 使用 14px值，不继承字体大小会发生什么。</p>
<p>现在，我们的padding为 21px，即 1.5 x 14 = 21 已经变小。 它不受父元素的字体大小。</p>
<blockquote>
<p>根 html 元素将继承浏览器中设置的字体大小，除非显式设置固定值去覆盖。所以 html 元素的字体大小虽然是直接确定 rem值，但字体大小可能首先来自浏览器设置。因此浏览器的字体大小设置可以影响每个使用 rem 单元以及每个通过 em 单位继承的值。</p>
</blockquote>
<h3 id="总结与-rem-差异-em"><a href="#总结与-rem-差异-em" class="headerlink" title="总结与 rem 差异 em"></a>总结与 rem 差异 em</h3><ul>
<li><p>rem 单位翻译为像素值是由 html 元素的字体大小决定的。 此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位。</p>
</li>
<li><p>em 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位。</p>
</li>
</ul>
<h3 id="使用rem的目的"><a href="#使用rem的目的" class="headerlink" title="使用rem的目的"></a>使用rem的目的</h3><p>确保无论用户如何设置自己的浏览器，我们的布局都能调整到合适大小。</p>
<h3 id="使用em的目的"><a href="#使用em的目的" class="headerlink" title="使用em的目的"></a>使用em的目的</h3><p>em 单位取决于一个font-size值而非 html 元素的字体大小。<br>em 单位的主要目的应该是允许保持在一个特定的设计元素范围内的可扩展性。根据某个元素的字体大小做缩放而不是根元素的字体大小。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>rem 和 em 单位是由浏览器基于你的设计中的字体大小计算得到的像素值。</li>
<li>em 单位基于使用他们的元素的字体大小。</li>
<li>rem 单位基于 html 元素的字体大小。</li>
<li>em 单位可能受任何继承的父元素字体大小影响</li>
<li>rem 单位可以从浏览器字体设置中继承字体大小。</li>
<li>使用 em 单位应根据组件的字体大小而不是根元素的字体大小。</li>
<li>在不需要使用em单位，并且需要根据浏览器的字体大小设置缩放的情况下使用rem。</li>
<li>使用rem单位，除非你确定你需要 em 单位，包括对字体大小。</li>
<li>媒体查询中使用 rem 单位</li>
<li>不要在多列布局中使用 em 或 rem -改用 %。</li>
<li>不要使用 em 或 rem，如果缩放会不可避免地导致要打破布局元素。</li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/05/CSS单位EM/" class="archive-article-date">
  	<time datetime="2016-11-05T12:58:56.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-05</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Node-js高性能的异步I-O" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/22/Node-js高性能的异步I-O/">Node.js高性能的异步I/O</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Node的单线程异步非阻塞I-O模型"><a href="#Node的单线程异步非阻塞I-O模型" class="headerlink" title="Node的单线程异步非阻塞I/O模型"></a>Node的单线程异步非阻塞I/O模型</h1><p><br></p>
<blockquote>
<p>  Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.</p>
</blockquote>
<p>说异步之前先了解几个名词</p>
<ul>
<li><p>I/O的阻塞与非阻塞：阻塞模式的I/O会造成应用程序等待，直到I/O完成。同时操作系统也支持将I/O操作设置为非阻塞模式，这时应用程序的调用将可能在没有拿到真正数据时就立即返回了，为此应用程序需要多次调用才能确认I/O操作完全完成，这就是一个轮训的过程。</p>
</li>
<li><p>I/O的同步与异步：I/O的同步与异步出现在应用程序中。如果做阻塞I/O调用，应用程序等待调用的完成的过程就是一种同步状况。相反，I/O为非阻塞模式时，应用程序则是异步的。</p>
</li>
<li><p>事件驱动：当事件被检测到发生时才回调调用会到函数，通过事件循环加事件触发的方式来运行程序。</p>
</li>
<li><p>事件循环：当有大量异步操作时需要调用相应的回调函数，需要用一种机制来管理同一个队列。</p>
</li>
</ul>
<p>Node的单线程异步非阻塞I/O模型利用单线程，远离多线程的死锁、状态同步等问题避免不必要的内存开销和上下文切换开销。 利用异步I/O，让单线程远离阻塞，更好的利CPU。</p>
<p>一个异步 I/O 的大致流程如下：</p>
<ul>
<li><p>发起 I/O 调用</p>
<ul>
<li>用户通过 Javascript 代码调用 Node 核心模块，将参数和回调函数传入到核心模块；</li>
<li>Node 核心模块会将传入的参数和回调函数封装成一个请求对象；</li>
<li>将这个请求对象推入到 I/O 线程池等待执行；</li>
<li>Javascript 发起的异步调用结束，Javascript 线程继续执行后续操作。</li>
</ul>
</li>
<li><p>执行回调</p>
<ul>
<li>I/O 操作完成后，会将结果储存到请求对象的 result 属性上，并发出操作完成的通知；</li>
<li>每次事件循环时会检查是否有完成的 I/O 操作，如果有就将请求对象加入到 I/O 观察者队列中，之后当做事件处理；</li>
<li>处理 I/O 观察者事件时，会取出之前封装在请求对象中的回调函数，执行这个回调函数，并将 result 当参数，以完成 Javascript 回调的目的。</li>
</ul>
</li>
</ul>
<p>这里面涉及到了一个设计理念:事件循环（Event Loop），它是一个类似于 while true 的无限循环,它会维护一系列的监视器,这些监视器都有对应着一种异步操作，它们注册事件监听以及相应的回调。事件循环除了维护那些观察者队列，还维护了一个 time 字段，在初始化时会被赋值为0，每次循环都会更新这个值。所有与时间相关的操作，都会和这个值进行比较，来决定是否执行。与 timer 相关的过程如下：</p>
<ul>
<li>更新当前循环的 time 字段，即当前循环下的“现在”；</li>
<li>检查循环中是否还有需要处理的任务（handlers/requests），如果没有就不必循环了，即是否 alive。</li>
<li>检查注册过的 timer，如果某一个 timer 中指定的时间落后于当前时间了，说明该 timer 已到期，于是执行其对应的回调函数；</li>
<li>执行一次 I/O polling（即阻塞住线程，等待 I/O 事件发生），如果在下一个 timer 到期时还没有任何 I/O 完成，则停止等待，执行下一个 timer 的回调。如果发生了 I/O 事件，则执行对应的回调；由于执行回调的时间里可能又有 timer 到期了，这里要再次检查 timer 并执行回调。</li>
</ul>
<p>Node.js它的单线程指的是自身 Javascript 运行环境的单线程，Node.js 并没有给 Javascript 执行时创建新线程的能力，最终的实际操作是通过事件循环来执行的。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/22/Node-js高性能的异步I-O/" class="archive-article-date">
  	<time datetime="2016-10-22T13:58:23.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-22</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-PrES6之Promise对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/12/PrES6之Promise对象/">ES6之Promise对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h3 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h3><p>ECMAScript 6中的Promise规范来源于Promises/A+社区。Promise是一个用于异步处理对象，其中包含了对异步进行各种操作的组件。Promise把JavaScript中的异步处理对象和处理规则进行了规范化，并按照统一的接口来编写，使用规定方法之外的写法会出现错误。</p>
<h3 id="一个promise有下面三个不同状态："><a href="#一个promise有下面三个不同状态：" class="headerlink" title="一个promise有下面三个不同状态："></a>一个promise有下面三个不同状态：</h3><ul>
<li>pending待承诺         - 初始状态</li>
<li>fulfilled实现承诺  - 一个承诺成功实现状态</li>
<li>rejected拒绝承诺   - 一个承诺失败的状态</li>
</ul>
<h3 id="promise必须实现-then-方法"><a href="#promise必须实现-then-方法" class="headerlink" title="promise必须实现 then 方法"></a>promise必须实现 then 方法</h3><ul>
<li>then必须返回一个promise</li>
<li>可以调用多次</li>
<li>then方法接受两个参数</li>
</ul>
<h3 id="Promise基本语法"><a href="#Promise基本语法" class="headerlink" title="Promise基本语法"></a>Promise基本语法</h3><h4 id="1、创建一个Promise对象"><a href="#1、创建一个Promise对象" class="headerlink" title="1、创建一个Promise对象"></a>1、创建一个Promise对象</h4><p>使用 new 来调用Promise的构造器来进行实例化</p>
<p>new Promise(fn) 返回一个promise对象<br>在fn 中指定异步等处理<br>处理结果正常的话，调用resolve(处理结果值)<br>处理结果错误的话，调用reject(Error对象)</p>
<pre><code>var promise = new Promise(function(resolve, reject) {
// 异步处理
// 处理结束后、调用resolve 或 reject
});
</code></pre><h4 id="2、了解Promise的状态"><a href="#2、了解Promise的状态" class="headerlink" title="2、了解Promise的状态"></a>2、了解Promise的状态</h4><p>用 new Promise 实例化的promise对象有以下三个状态。</p>
<pre><code>&quot;has-resolution&quot; - Fulfilled
</code></pre><p>resolve(成功)时。此时会调用 onFulfilled</p>
<pre><code>&quot;has-rejection&quot; - Rejected
</code></pre><p>reject(失败)时。此时会调用 onRejected</p>
<pre><code>&quot;unresolved&quot; - Pending
</code></pre><p>既不是resolve也不是reject的状态。<br>也就是promise对象刚被创建后的初始化状态等</p>
<p>关于上面这三种状态的读法，其中 左侧为在 ES6 Promises 规范中定义的术语， 而右侧则是在 Promises/A+ 中描述状态的术语。</p>
<h4 id="3、Promise-then"><a href="#3、Promise-then" class="headerlink" title="3、Promise.then()"></a>3、Promise.then()</h4><p>对通过 new 生成的promise对象为了设置其值在 resolve(成功) / reject(失败) 时调用的 回调函数 可以使用 promise.then() 实例方法。</p>
<pre><code>promise.then(onFulfilled, onRejected)
resolve(成功)时
onFulfilled 会被调用

reject(失败)时
onRejected 会被调用
</code></pre><p>onFulfilled、onRejected 两个都为可选参数。<br>promise.then 成功和失败时都可以使用。 如果只想对异常进行处理时可以采用 promise.then(undefined, onRejected) 这种方式，只指定reject时的回调函数即可。 不过这种情况下 promise.catch(onRejected) 应该是个更好的选择。</p>
<pre><code>var promise = new Promise(function(resolve, reject){
    resolve(&quot;传递给then的值&quot;);
});
// 写法一
promise.then(function (value) {
    console.log(value);
}, function (error) {
    console.error(error);
});
// 写法二（使用catch)
promise.then(function (value) {
    console.log(value);
}).catch(function (error) {
    console.error(error);
});
</code></pre><h4 id="4、使用快捷方式"><a href="#4、使用快捷方式" class="headerlink" title="4、使用快捷方式"></a>4、使用快捷方式</h4><p>静态方法 Promise.resolve(value) 和 Promise.reject(error) 可以认为是 new Promise() 方法的快捷方式。</p>
<h5 id="4-1-Promise-resolve"><a href="#4-1-Promise-resolve" class="headerlink" title="4.1 Promise.resolve()"></a>4.1 Promise.resolve()</h5><p>比如 Promise.resolve(1) 可以认为是以下代码的语法糖。</p>
<pre><code>new Promise(function(resolve){
    resolve(1);
});
</code></pre><p>在这段代码中的 resolve(1)会让这个promise对象立即进入确定（即resolved）状态，并将 1 传递给后面then里所指定的 onFulfilled 函数。</p>
<p>方法 Promise.resolve(value) 的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。</p>
<pre><code>Promise.resolve(1).then(function(value){
    console.log(value); // 1
});
</code></pre><p>运用场景：Promise.resolve()在promise对象的初始化或者编写测试代码的时候都非常方便。</p>
<h5 id="4-2-Promise-reject"><a href="#4-2-Promise-reject" class="headerlink" title="4.2 Promise.reject()"></a>4.2 Promise.reject()</h5><p>比如 Promise.reject(new Error(“出错了”)) 就是下面代码的语法糖形式。</p>
<pre><code>new Promise(function(resolve,reject){
    reject(new Error(&quot;出错了&quot;));
});
</code></pre><p>方法 Promise.reject(error) 的返回值也是一个promise对象，所以可以将错误（Error）对象传递到catch里的函数中。</p>
<pre><code>Promise.reject(new Error(&quot;BOOM!&quot;)).catch(function(error){
    console.error(error);
});
</code></pre><h4 id="5、Promise-all"><a href="#5、Promise-all" class="headerlink" title="5、Promise.all()"></a>5、Promise.all()</h4><p>Promise.all 接收一个 promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用 .then 方法。</p>
<p>运用场景: 批量请求</p>
<pre><code>var p1 = Promise.resolve(1),
    p2 = Promise.resolve(2),
    p3 = Promise.resolve(3);
Promise.all([p1, p2, p3]).then(function (results) {
    console.log(results);  // [1, 2, 3]
});
传递给 Promise.all 的promise并不是一个个的顺序执行的，而是同时开始、并行执行的。

可以从以下例子的运行结果看出：

// `delay`毫秒后执行resolve
function timerPromisefy(delay) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            resolve(delay);
        }, delay);
    });
}
var startDate = Date.now();
// 所有promise变为resolve后程序退出
Promise.all([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
]).then(function (values) {
    console.log(Date.now() - startDate + &apos;ms&apos;);
    // 約128ms
    console.log(values);    // [1,32,64,128]
});
</code></pre><h4 id="6、Promise-race"><a href="#6、Promise-race" class="headerlink" title="6、Promise.race()"></a>6、Promise.race()</h4><p>Promise.race 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</p>
<pre><code>var p1 = Promise.resolve(1),
    p2 = Promise.resolve(2),
    p3 = Promise.resolve(3);
Promise.race([p1, p2, p3]).then(function (value) {
    console.log(value);  // 1
});
进一步分析, 当第一个promise对象变为确定（FulFilled）状态后，它之后的promise对象是否还在继续运行。

// `delay`毫秒后执行resolve
function timerPromisefy(delay) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            console.log(delay)
            resolve(delay);
        }, delay);
    });
}
// 任何一个promise变为resolve或reject 的话程序就停止运行
Promise.race([
    timerPromisefy(1),
    timerPromisefy(10),
    timerPromisefy(20),
]).then(function (value) {
    console.log(value);    // =&gt; 1
});
//整体运行结果
1
1
10
20
</code></pre><p>执行上面代码，我们会看到setTimeout 方法都会执行完毕， console.log 也会分别输出它们的信息。也就是说， Promise.race 在第一个promise对象变为Fulfilled之后，并不会取消其他promise对象的执行。</p>
<h4 id="Promise实例练习"><a href="#Promise实例练习" class="headerlink" title="Promise实例练习"></a>Promise实例练习</h4><p>考虑本文一开始的场景，进行小进阶练习，实现每隔一秒依次输出1-10。</p>
<pre><code>//利用for循环 避免一长串的.then写法
function log(i) {
    return new Promise(function(resolve) {
        setTimeout(function() {
            console.log(i)
            resolve();
        }, 1000)
    })
}
function printN(n) {
    var p = log(1);
    for (var i = 2; i &lt;= n; i++) {
        var a = function(x) { // 注意回调函数闭包的问题
            return function() {
                return log(x);
            }
        }
        p = p.then(a(i));
    }
}
printN(10);
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/12/PrES6之Promise对象/" class="archive-article-date">
  	<time datetime="2016-10-12T12:58:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-12</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Promise/">Promise</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-关于前后端开发模思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/19/关于前后端开发模思考/">对于前后端开发模式一点点思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题的起因"><a href="#问题的起因" class="headerlink" title="问题的起因"></a>问题的起因</h2><p>很多东西真的是用起来才会发现问题，问题是前两天交互需要改一个业务，另个部门A同事发我让我去修改，这页面静态确实是我写的，我也抽时间把它写好重新发给A同事。</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>我们公司目前的开发模式是：交互根据PM出高保真，视觉出视觉稿、切图，然后交给前端出静态，最后交给另一个部门同事把它转换成服务端模板。</p>
<p>这样问题就来了当出现上述交互要改业务的情况，A同事改不了只能发回前端改，如果A把他已经搞成服务端模板的代码返回给前端，前端没环境也没法下手，只能去改以前的静态，改好后重新发给A，这时候A又麻烦了，他要对比两次修改的部分，把自己前一阵的修改合并进去。这样开发效率会慢很多。</p>
<h2 id="基于NodeJS的全栈式开发"><a href="#基于NodeJS的全栈式开发" class="headerlink" title="基于NodeJS的全栈式开发"></a>基于NodeJS的全栈式开发</h2><p>这是2014年杭JS，淘宝赫门做的分享（那时候我还在玩泥巴o(╯□╰)o），特意去找了当年的文档，中途岛(Midway Framework)的架构，淘宝的前端团队真的很厉害。</p>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/T1xW8OFrXkXXXK71TW-590-611.png" alt="Alt text"></p>
<p>多加了一层中间层。<br>前后端共享模板，前端来决定某个模板是服务端渲染还是客户端渲染，当首屏的时候，就在服务器渲染，次屏和局部刷新的时候，就在浏览器端渲染展示。<br>加入NodeJs还有很多好处，比如NodeJs的高并发特性，请求合并等。同时使用nodeJs做桥梁，前端可以自己决定获取什么格式的数据。</p>
<p><img src="http://ob6nlbpso.bkt.clouddn.com/sp160926_225215.png" alt="Alt text"></p>
<p>这样还分清了职责</p>
<h2 id="我们该怎么做"><a href="#我们该怎么做" class="headerlink" title="我们该怎么做"></a>我们该怎么做</h2><p>在公司产品的角度，觉得我们公司并不需要。其实适合自己就好，没必要占领中间层。相对来说我们公司的前端比较弱，产品线又横向发展并没太深入的产品，分离的还是业务逻辑JS该谁写，把这些都应该交给前端前，端负责展现交互逻辑，去掉A那部分，后端专注于数据接口就好，对于接口接口风格是面向业务 还是面相页面有待统一。这样必然导致前端人员工作量的增加，和水平的相应自我提升。对于数据Mock，可以采用RAP之类接口自动化工具。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/19/关于前后端开发模思考/" class="archive-article-date">
  	<time datetime="2016-09-19T14:41:51.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-19</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-编码规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/13/编码规范/">编码规范</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端编码规范"><a href="#前端编码规范" class="headerlink" title="前端编码规范"></a>前端编码规范</h1><pre><code>最近写的项目越来越大，代码堆积的太多，自己看着都头疼下决心整理了下，  
着实一个浩大的工程hh，花了我三个晚上，效果还是有那么点的，
顺便把遇到的整理下，写博客在于记忆，以后回来看看好知道我曾经这么菜。
</code></pre><h2 id="JS篇"><a href="#JS篇" class="headerlink" title="JS篇"></a>JS篇</h2><ul>
<li>三元条件判断<br>用三元操作符分配或返回语句替换简单的if语句      </li>
</ul>
<p><strong>不推荐</strong></p>
<pre><code>if(x === 0) {    
    return &apos;00&apos;;   
    } else {    
     return x; 
}       
</code></pre><p><strong>推荐</strong>      </p>
<pre><code>return x === 4 ? &apos;00&apos; : x;      
</code></pre><ul>
<li>for循环<br>数组的长度，使用一个变量来接收     </li>
</ul>
<p><strong>不推荐</strong></p>
<pre><code>for(var i=0;i&lt;arr.length,i++){
}       
</code></pre><p><strong>推荐</strong> </p>
<pre><code>for(var i=0,len=arr.length;i&lt;len,i++){
}    
</code></pre><ul>
<li>DOM操作<br>对于重复的dom操作，使用一个变量来进行接收      </li>
</ul>
<p><strong>不推荐</strong></p>
<pre><code>$(&apos;.onSelect&apos;).text(&apos;1&apos;);
$(&apos;.onSelect&apos;).text(&apos;2&apos;);
$(&apos;.onSelect&apos;).text(&apos;3&apos;);
$(&apos;.onSelect&apos;).text(&apos;4&apos;);
</code></pre><p><strong>推荐</strong> </p>
<pre><code>var sel=$(&apos;.onSelect&apos;);
sel.text(&apos;1&apos;);
sel.text(&apos;2&apos;);
sel.text(&apos;3&apos;);
sel.text(&apos;4&apos;);
</code></pre><ul>
<li>立即执行函数<br>推荐在立即执行函数开始跟结尾都添加上分号，避免在合并时因为别人的代码不规范而影响到我们自己的代码,如果有用到全局变量应该通过变量传递的方式，让立即执行函数的函数体在调用时，能以局部变量的形式调用，在一定程度上提升程序性能。         </li>
</ul>
<p><strong>不推荐</strong></p>
<pre><code>(function(){
&apos;use strict&apos;;
var x = 10,
    y = 100,
    c,
    elem=$(&apos;body&apos;);
console.log(window.x + &apos; &apos; + window.y);
$(document).on(&apos;click&apos;,function(){
});
if(typeof c===&apos;undefined&apos;){
    //你的代码
}
}());
</code></pre><p><strong>推荐</strong></p>
<pre><code>;(function($,window,document,undefined){
&apos;use strict&apos;;
var x = 10,
    y = 100,
    c,
    elem=$(&apos;body&apos;);
console.log(window.x + &apos; &apos; + window.y);
$(document).on(&apos;click&apos;,function(){});
if(typeof c===&apos;undefined&apos;){
    //你的代码
}
}(jQuery,window,document));
</code></pre><ul>
<li>类型转换</li>
</ul>
<p>number to string的转换，建议使用 1 + ‘’或String(1)，不使用new String(1)或1.toString()的方式。<br>string to number的转换，建议使用parseInt，必须显式指定第二个参数的进制。下面的例子展示了不指定进制的风险：       </p>
<pre><code>parseInt(&apos;08&apos;); // 0 
parseInt(&apos;08&apos;, 10); //8
</code></pre><p>float to integer的转换，建议使用Math.floor/Math.round/Math.ceil方法，不使用parseInt。</p>
<ul>
<li>使用命名空间</li>
</ul>
<p>使用多个命名空间，其中的内容互不干扰</p>
<pre><code>//全局对象
var Wrox = {};
//一个命名空间
Wrox.ProAjax = {};
Wrox.ProAjax.EventUtil = {};
Wrox.ProAjax.CookieUtil = {};
//另一个命名空间
Wrox.ProJS = {};
Wrox.ProJS.EventUtil = {};
Wrox.ProJS.CookieUtil = {};
</code></pre><ul>
<li>字符串拼接<br>字符串拼接，应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。如:        </li>
</ul>
<p><strong>不推荐</strong></p>
<pre><code>var str = &apos;&apos;; 
for (var i = 0, len = list.length; i &lt; len; i++) { 
  str+= &apos;&lt;div&gt;&apos; + list[i] + &apos;&lt;/div&gt;&apos;; 
} 
dom.innerHTML = str;
</code></pre><p><strong>推荐</strong></p>
<pre><code>var str = []; 
for (var i = 0, len = list.length; i &lt; len; i++) { 
  str.push(&apos;&lt;div&gt;&apos;+ list[i] + &apos;&lt;/div&gt;&apos;); 
} 
dom.innerHTML = str.join(&apos;&apos;);
</code></pre><ul>
<li>尽量避免全局变量和函数</li>
</ul>
<p><strong>不推荐</strong></p>
<pre><code>var name = &quot;&quot;;
function setName(value) {
    name = value;
}
function sayName() {
    console.log(name);
}
</code></pre><p><strong>推荐</strong></p>
<pre><code>var setPersonName = {
    name: &quot;&quot;,
    setName: function (value) {
        this.name = value;
    },
    sayName: function () {
        console.log(this.name);
    }
};
setPersonName.setName(&quot;Oli&quot;);
setPersonName.sayName();
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/13/编码规范/" class="archive-article-date">
  	<time datetime="2016-09-13T14:48:41.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-13</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JS继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/29/JS继承/">JS继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>一种减少重复性代码的一种设计模式，尽量弱化对象间耦合。在学习JS中继承过程中，遇到坑比较多，抽点时间记录下。由于javascript的语言特性，它的继承也被分为了3中实现方式。</p>
<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>说道继承先来看看对象的创建</p>
<pre><code>//第一种，手动创建
var a={&apos;name&apos;:&apos;hahaha&apos;};   
//第二种，构造函数
function A(){
    this.name=&apos;hahaha&apos;;
}
var a=new A();
//第三种，class (ES6标准写法)
class A{
    constructor(){
        super();
        this.name=&apos;hahaha&apos;;
    }
}
var a=new A()
//其实后面两种方法本质上是一种写法
</code></pre><p>这三种写法创建的对象的原型（父对象）都是Object,需要提到的是，ES6通过引入class ,extends等关键字，以一种语法糖的形式把构造函数包装成类的概念，更便于大家理解。是希望开发者不再花精力去关注原型以及原型链，也充分说明原型的设计意图和类是一样的。</p>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>在子类型构造函数的内部调用超类构造函数，通过使用call()和apply()方法可以在新创建的对象上执行构造函数。</p>
<pre><code>function Father(name){
    this.name =name;
    this.age=5;
}
function Children(name){
    Father.call(this,name);
}
let jc = new Children(&quot;jicheng&quot;);
let jc2 = new Children(&quot;jicheng2&quot;);
jc2.age = 10;
console.log(jc.name + jc.age);  //jicheng 5
console.log(jc2.name + jc2.age);  //jicheng2 10
</code></pre><p>当我们new这个构造函数的时候，就会生成一个Children对象的实例。<br>但是通过上面的例子你会发现用构造函数生成实例对象，它有一个缺点，那就是无法共享属性和方法。<br>因为这两个对象的age属性是独立的，修改其中一个，不会影响到另一个。<br>这样做的坏处就是会造成资源浪费，那么我们要如何来解决这件事呢，那就需要prototype出场了。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>就是融合了原型和构造器的一种继承方法。 这个应该算是一种比较稳妥的继承方式.即能排除引用类型造成的问题，又可以实现共享的效果。</p>
<pre><code>function Father(name){
    this.name =name;
}
Father.prototype.age=5;
function Children(name){
    Father.call(this,name);
}
Children.prototype = new Father();
Children.prototype.constructor = Children;
let jc = new Children(&quot;jicheng&quot;);
let jc2 = new Children(&quot;jicheng2&quot;);
Father.prototype.age = 10;
console.log(jc.name + jc.age);  //jicheng 10
console.log(jc2.name + jc2.age);  //jicheng2 10
</code></pre><p>age属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。<br>这样会两次调用到父类型，对内存影响还是比较大的。但是es6 class  的出现，解决了这一问题。</p>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>在使用class的使用，你完全可以不去写，constructor, prototype之类的东西了</p>
<pre><code>//原生继承方式   
function Father(name){
    this.name =name;
}
Father.prototype.age=function(){
    return &quot;4&quot;
};
var father = new Father(&quot;张三&quot;)
//使用class
class Father(){
    constructor(name){
        this.name = name;
    }
    age(){
        return &quot;4&quot;
    }
}
var father = new Father(&quot;张三&quot;)
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/29/JS继承/" class="archive-article-date">
  	<time datetime="2016-08-29T14:59:32.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-29</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原型/">原型</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-DOM编程总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/DOM编程总结/">DOM编程总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h3><ul>
<li>父子关系<ul>
<li>parentNode</li>
<li>firstChild/lastChild/childNodes</li>
<li>childNodes/children</li>
</ul>
</li>
<li>兄弟关系<ul>
<li>previousSibling/nextSibling</li>
<li>previousElementSibling/nextElementSibling</li>
</ul>
</li>
<li>选择器   <ul>
<li>element=document.getElementById(id)</li>
<li>collection=element.getElementByTagName(tarName)<ul>
<li>collection 是个动态的随着节点改变而改变</li>
<li>tarName=*代表获取所有</li>
</ul>
</li>
<li>collection=element.getElementByClassName(className)</li>
<li>list=element.querySelect/All(selector)</li>
</ul>
</li>
<li><p>现代浏览器中内置的可以等效替代jQuery的功能</p>
<ul>
<li><p>创建全局的 ‘$’ 变量</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">window.$ = function(selector) &#123;   </div><div class="line">  return document.querySelector(selector);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><ul>
<li>element=document.createElement(tagName)</li>
</ul>
<h3 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h3><ul>
<li>element.textContent 获取节点以及后面的文本内容</li>
<li>element.textContent = “修改内容”</li>
<li>element.innerText 不规范不推荐使用</li>
</ul>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><ul>
<li>element.appendChild(a) 在指定元素后追加a</li>
<li>element.insertBefore(h,a) 在指定元素h之前添加a</li>
</ul>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li>element.removeChild</li>
</ul>
<h3 id="innerHtml"><a href="#innerHtml" class="headerlink" title="innerHtml"></a>innerHtml</h3><ul>
<li>节点的HTML内容</li>
</ul>
<h2 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h2><ul>
<li>element.style.cssText=’color:red;’ 一条语句设置样式</li>
<li>element.className =’clasname’ 编辑类名一次修改多个样式</li>
<li>element.style.color 获取颜色样式 不一定是它实际样式 当元素上有设置颜色的才获取到实际的<pre><code>* window.getComputedStyle(element).color 获取到的是实际
</code></pre></li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><ul>
<li>elem.addEventListener(type,function,false/true)</li>
</ul>
<h3 id="浏览器兼容型事件注册"><a href="#浏览器兼容型事件注册" class="headerlink" title="浏览器兼容型事件注册"></a>浏览器兼容型事件注册</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function addEvent(element,type,handler)&#123;</div><div class="line">  if (element.addEventListener) &#123;</div><div class="line">    element.addEventListener(type,handler,false);</div><div class="line">  &#125;else if (element.attachEvent) &#123;</div><div class="line">    element.attachEvent(&apos;on&apos;+type,handler);</div><div class="line">  &#125;else&#123;</div><div class="line">    element[&apos;on&apos;+type]=handler;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="取消事件注册"><a href="#取消事件注册" class="headerlink" title="取消事件注册"></a>取消事件注册</h3><ul>
<li>elem.removeEventListener(type,function,false/true)</li>
</ul>
<h3 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h3><ul>
<li>elem.dispatchEvent(type)</li>
</ul>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ul>
<li><p>属性</p>
<ul>
<li>type</li>
<li><p>target </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">//兼容        </div><div class="line">var event=e || window.event;         </div><div class="line">var target=event.target || event.srcElement;</div></pre></td></tr></table></figure>
</li>
<li><p>currentTarget</p>
</li>
</ul>
</li>
<li>方法<ul>
<li>stopPropagation（W3C） 阻止事件传播 cancelBubble（IE低版本）</li>
<li>preventDefault（W3C） 阻止默认行为  returnValue=false（IE低版本）</li>
<li>stopImmediatePropagation</li>
</ul>
</li>
</ul>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><ul>
<li>Event<ul>
<li>load</li>
<li>unload</li>
<li>error</li>
<li>select</li>
<li>abort</li>
</ul>
</li>
<li>UIEvent   //继承自Event<ul>
<li>resize</li>
<li>scroll</li>
</ul>
</li>
<li>FocusEvent    //继承自UIevent<ul>
<li>blur</li>
<li>focus</li>
<li>focusin</li>
<li>focusout</li>
</ul>
</li>
<li>InputEvent    //继承自UIevent<ul>
<li>beforeinput</li>
<li>input</li>
</ul>
</li>
<li>KeyboarEvent  //继承自UIevent<ul>
<li>keydown</li>
<li>keyup</li>
</ul>
</li>
<li>MouseEvent    //继承自UIevent<ul>
<li>click</li>
<li>dbclick</li>
<li>mousedown</li>
<li>mouseleave</li>
<li>mousemove</li>
<li>mouseout</li>
<li>mouseup</li>
</ul>
</li>
<li>wheelEvent    //继承自MouseEvent<ul>
<li>wheel</li>
</ul>
</li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/02/DOM编程总结/" class="archive-article-date">
  	<time datetime="2016-08-02T14:48:59.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-02</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-CSS布局" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/27/CSS布局/">CSS布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><h3 id="布局–display"><a href="#布局–display" class="headerlink" title="布局–display"></a>布局–display</h3><h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><ul>
<li>默认宽度是父元素宽度</li>
<li>可设置宽高</li>
<li>换行显示</li>
<li>常见块状元素 div p h1-h6 ul from</li>
</ul>
<h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><ul>
<li>默认宽度是内容宽度</li>
<li>不可设置宽高</li>
<li>同行显示</li>
<li>常见行内元素 span a label cite em</li>
</ul>
<h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><ul>
<li>默认宽度是内容宽度</li>
<li>可设置宽高</li>
<li>同行显示</li>
<li>常见的行内块状元素 input textarea select button</li>
</ul>
<h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><ul>
<li>隐藏不占位置</li>
<li>visiblity：hidden隐藏占位置</li>
</ul>
<h3 id="布局–position"><a href="#布局–position" class="headerlink" title="布局–position"></a>布局–position</h3><h4 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h4><ul>
<li>在文档流中</li>
<li>参照物是本身</li>
</ul>
<h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><ul>
<li>默认宽度是内容宽度</li>
<li>脱离文档流</li>
<li>参照物是第一个定位的祖先元素</li>
</ul>
<h4 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h4><ul>
<li>默认宽度是内容宽度</li>
<li>脱离文档流</li>
<li>参照物是视窗 </li>
</ul>
<h3 id="布局–float"><a href="#布局–float" class="headerlink" title="布局–float"></a>布局–float</h3><ul>
<li>默认宽度为内容宽度</li>
<li>半脱离文档流，对元素脱离文档流，对内容在文档流</li>
<li>向指定方向移动   </li>
</ul>
<h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.clearfix:before,.clearfix:after&#123;</div><div class="line">    content: &quot;&quot;;</div><div class="line">    display: table;</div><div class="line">&#125;</div><div class="line">.clearfix:after&#123;</div><div class="line">    clear: both;</div><div class="line">    overflow: hidden;</div><div class="line">&#125;</div><div class="line">.clearfix&#123;</div><div class="line">    zoom:1; /*for IE6 IE7*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">    &lt;div class=&quot;child&quot;&gt;DEMO&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">body&#123;margin:20px;&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>inline-block + text-align</p>
<pre><code>优点：兼容性好；缺点：子元素会继承父元素的居中
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">    text-align: center;</div><div class="line">&#125;</div><div class="line">.child&#123;</div><div class="line">    display: inline-block;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>table + margin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.child&#123;</div><div class="line">    display: table;</div><div class="line">    margin: 0 auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>absolute + transform</p>
<pre><code>优点：脱离文档流对其它元素没有影响。缺点：兼容性问题
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">    height:1.5em;</div><div class="line">    position: relative;</div><div class="line">    &#125;</div><div class="line">.child&#123;</div><div class="line">    position: absolute;</div><div class="line">    left: 50%;</div><div class="line">    transform: translateX(-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>flex + justify-content</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">    display: flex;</div><div class="line">    justify-content: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">    &lt;div class=&quot;child&quot;&gt;DEMO&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">body&#123;margin:20px;&#125;</div><div class="line">    .parent&#123;width:4em;height:500px;&#125;</div><div class="line">    .child&#123;width:100%;&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>table-cell + vertical-align</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">    display: table-cell;</div><div class="line">    vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>absolute + transform</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">    position: relative;</div><div class="line">&#125;</div><div class="line">.child&#123;</div><div class="line">    position: absolute;</div><div class="line">    top: 50%;</div><div class="line">    transform: translateY(-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>flex + align-items</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">    display: flex;</div><div class="line">    align-items: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="垂直水平居中"><a href="#垂直水平居中" class="headerlink" title="垂直水平居中"></a>垂直水平居中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">    &lt;div class=&quot;child&quot;&gt;DEMO&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">body&#123;margin:20px;&#125;</div><div class="line">.parent&#123;width:200px;height:300px;&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>inline-block + text-aligin + table-cell + vertical-align</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">    text-align: center; </div><div class="line">    display: table-cell; </div><div class="line">    vertical-align: middle;</div><div class="line">&#125;</div><div class="line">.child&#123;</div><div class="line">    display: inline-block;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>absolute + transform</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">    position: relative;</div><div class="line">&#125;</div><div class="line">.child&#123;</div><div class="line">    position: absolute; </div><div class="line">    left: 50%; </div><div class="line">    top: 50%; </div><div class="line">    transform: </div><div class="line">    translate(-50%,-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>flex + justify-content + align-items</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">    display: flex; </div><div class="line">    justify-content: center; </div><div class="line">    align-items: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h3><h4 id="定宽自适应"><a href="#定宽自适应" class="headerlink" title="定宽自适应"></a>定宽自适应</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">    &lt;div class=&quot;left&quot;&gt;</div><div class="line">        &lt;p&gt;left&lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div class=&quot;right&quot;&gt;</div><div class="line">        &lt;p&gt;right&lt;/p&gt;</div><div class="line">        &lt;p&gt;right&lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h5 id="左侧定宽右侧自适应"><a href="#左侧定宽右侧自适应" class="headerlink" title="左侧定宽右侧自适应"></a>左侧定宽右侧自适应</h5><ul>
<li><p>float + margin </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.left&#123;</div><div class="line">    float: left;</div><div class="line">    width: 100px;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">    margin-left: 120px;</div><div class="line">&#125;</div><div class="line">//在IE6中因为right是没有浮动的所以right里面的文字会往右边缩进3像素</div></pre></td></tr></table></figure>
</li>
<li><p>float + overflow</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.left&#123;</div><div class="line">    float: left;</div><div class="line">    width: 100px;</div><div class="line">    margin-right: 20px;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">    overflow: hidden;</div><div class="line">&#125;</div><div class="line">//IE6不支持</div></pre></td></tr></table></figure>
</li>
<li><p>table</p>
<pre><code>table默认宽度内容宽度、且对margin无效、响应padding
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">    display: table; </div><div class="line">    width: 100%;</div><div class="line">    table-layout: fixed;//布局优先、且加速table渲染</div><div class="line">&#125;</div><div class="line">.left,.right&#123;</div><div class="line">    display: table-cell;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">    width: 100px;</div><div class="line">    padding-right: 20px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>flex</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">    display: flex;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">    width: 100px;</div><div class="line">    margin-right: 20px;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">    flex: 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="左侧不定宽右侧自适应"><a href="#左侧不定宽右侧自适应" class="headerlink" title="左侧不定宽右侧自适应"></a>左侧不定宽右侧自适应</h5><ul>
<li>float + overflow</li>
<li>table</li>
<li>flex</li>
</ul>
<h4 id="等分布局"><a href="#等分布局" class="headerlink" title="等分布局"></a>等分布局</h4><ul>
<li><p>float</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">    &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">.parent&#123;</div><div class="line">    margin-left: -20px;</div><div class="line">&#125;</div><div class="line">.column&#123;</div><div class="line">    float: left;</div><div class="line">    width: 25%;</div><div class="line">    padding-left: 20px;</div><div class="line">    box-sizing: border-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>table </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div class=&quot;parent-fix&quot;&gt;</div><div class="line">    &lt;div class=&quot;parent&quot;&gt;</div><div class="line">        &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt;</div><div class="line">        &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;</div><div class="line">        &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;</div><div class="line">        &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">.parent-fix&#123;</div><div class="line">    margin-left: -20px;</div><div class="line">&#125;</div><div class="line">.parent&#123;</div><div class="line">    display: table;</div><div class="line">    width:100%;</div><div class="line">    table-layout: fixed;//平分单元格</div><div class="line">&#125;</div><div class="line">.column&#123;</div><div class="line">    display: table-cell;</div><div class="line">    padding-left: 20px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>flex</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">    &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">.parent&#123;</div><div class="line">    display: -flex;</div><div class="line">&#125;</div><div class="line">.column&#123;</div><div class="line">   flex:1;</div><div class="line">&#125;</div><div class="line">.column+.column&#123;</div><div class="line">    margin-left:20px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="等高布局"><a href="#等高布局" class="headerlink" title="等高布局"></a>等高布局</h4><ul>
<li>table</li>
<li>flex</li>
<li>float<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//float的伪等高</div><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">    &lt;div class=&quot;left&quot;&gt;</div><div class="line">        &lt;p&gt;left&lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div class=&quot;right&quot;&gt;</div><div class="line">        &lt;p&gt;right&lt;/p&gt;</div><div class="line">        &lt;p&gt;right&lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">body&#123;margin:20px;&#125;</div><div class="line">p&#123;background: none!important;&#125;</div><div class="line">.left,.right&#123;background: #444;&#125;</div><div class="line">.parent&#123;</div><div class="line">    overflow: hidden;</div><div class="line">&#125;</div><div class="line">.left,.right&#123;</div><div class="line">    padding-bottom: 9999px;</div><div class="line">    margin-bottom: -9999px;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">    float: left; width: 100px;</div><div class="line">    margin-right: 20px;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">    overflow: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/07/27/CSS布局/" class="archive-article-date">
  	<time datetime="2016-07-27T15:42:41.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-07-27</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/居中/">居中</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/布局/">布局</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-用Gulp优化项目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/11/用Gulp优化项目/">用Gulp优化项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>公司的项目性能很差,由于刚来实习老大让我尝试优化下就当给我练练手</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>发现这个项目是JSP写的动态网页并没有模块化预加载什么的单纯的引入JS/CSS，每次访问请求用太多时间</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>想到就先合并请求，并压缩代码之类的 工具是基于流的Gulp<br>//然并没用过</p>
<h2 id="首先安装Gulp"><a href="#首先安装Gulp" class="headerlink" title="首先安装Gulp"></a>首先安装Gulp</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install -g gulp</div></pre></td></tr></table></figure>
<h2 id="安装相应的插件"><a href="#安装相应的插件" class="headerlink" title="安装相应的插件"></a>安装相应的插件</h2><p>为了解决插件和模块依赖被重复的引入进来我用了ulp-load-plugins<br>为了以后项目的升级我也进行了参数配置全局化在gulp.config.js<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install gulp-minify-css gulp-uglify gulp-concat gulp-rename ulp-load-plugins through2 vinyl-source-stream gulp-marked --save-dev gulp</div></pre></td></tr></table></figure></p>
<h2 id="由于是jsp写的路径useref方法无法识别"><a href="#由于是jsp写的路径useref方法无法识别" class="headerlink" title="由于是jsp写的路径useref方法无法识别"></a>由于是jsp写的路径useref方法无法识别</h2><p>用到filesystem模块先读到index.jsp然后用正则替换路径<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gulp.task(&apos;readBuffer&apos;, function() &#123;</div><div class="line">    return gulp.src(&apos;app/index.jsp&apos;)</div><div class="line">    .pipe(modify(swapStuff))</div><div class="line">    .pipe(modify(swapStuff_))</div><div class="line">    .pipe(gulp.dest(config.build));</div><div class="line"></div><div class="line">&#125;)</div><div class="line">function modify(modifier) &#123;</div><div class="line">    return through2.obj(function(file, encoding, done) &#123;</div><div class="line">        var content = modifier(String(file.contents));</div><div class="line">        file.contents = new Buffer(content);</div><div class="line">        this.push(file);</div><div class="line">        done();</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">//正则</div><div class="line">function swapStuff(data) &#123;</div><div class="line">    return data.replace(/\$\&#123;pageContext\.request\.contextPath\s*\&#125;/g, &apos;..&apos;);</div><div class="line">&#125;</div><div class="line">function swapStuff_(data) &#123;</div><div class="line">    return data.replace(/window\.ContextPath \= \&quot;\.\.\/\&quot;/, &apos;window.ContextPath = &quot;$&#123;pageContext.request.contextPath&#125;/&quot;&apos;)</div><div class="line">               .replace(/base\shref\=\&quot;\.\.\/\&quot;/,&apos;base href=&quot;dist/&quot;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="然后用useref方法读到所有内容，进行压缩合并等步骤"><a href="#然后用useref方法读到所有内容，进行压缩合并等步骤" class="headerlink" title="然后用useref方法读到所有内容，进行压缩合并等步骤"></a>然后用useref方法读到所有内容，进行压缩合并等步骤</h2><p>这里需要在index.jsp根据你的需求页面配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- build:css css/lib.css --&gt;</div><div class="line">&lt;!-- endbuild --&gt;</div><div class="line">&lt;!-- build:css css/app.css --&gt;</div><div class="line">&lt;!-- endbuild --&gt;</div><div class="line">&lt;!-- build:js js/lib.js --&gt;</div><div class="line">&lt;!-- endbuild --&gt;</div><div class="line">&lt;!-- build:js js/app.js --&gt;</div><div class="line">&lt;!-- endbuild --&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gulp.task(&apos;optimize&apos;,[&apos;readBuffer&apos;],function() &#123;</div><div class="line">   return gulp</div><div class="line">            .src(&apos;dist/index.jsp&apos;)</div><div class="line">            .pipe($.useref())  // 解析jsp中build，将里面引用到的文件合并传过来</div><div class="line">            .pipe($.if(&apos;js/app.js&apos;, $.ngAnnotate()))</div><div class="line">            .pipe($.if(&apos;js/*.js&apos;, $.uglify()))</div><div class="line">            .pipe($.if(&apos;css/*.css&apos;, $.minifyCss()))</div><div class="line">            .pipe($.if(&apos;!index.jsp&apos;, $.rev()))</div><div class="line">            .pipe($.revReplace())</div><div class="line">            .pipe(gulp.dest(config.build))</div><div class="line">            .pipe($.rev.manifest())</div><div class="line">            .pipe(gulp.dest(&apos;dist/rev/&apos;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="给资源文件加时间戳"><a href="#给资源文件加时间戳" class="headerlink" title="给资源文件加时间戳"></a>给资源文件加时间戳</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gulp.task(&apos;rev&apos;, [&apos;optimize&apos;],function() &#123;</div><div class="line">    return gulp.src([&apos;dist/rev/*.json&apos;, &apos;dist/index.jsp&apos;])  </div><div class="line">        .pipe($.revCollector())                                   </div><div class="line">        .pipe(gulp.dest(config.build));                     </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="由于所有图片都合并到一起、路径就会发生变化这里对路径做个统一"><a href="#由于所有图片都合并到一起、路径就会发生变化这里对路径做个统一" class="headerlink" title="由于所有图片都合并到一起、路径就会发生变化这里对路径做个统一"></a>由于所有图片都合并到一起、路径就会发生变化这里对路径做个统一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gulp.task(&apos;images&apos;, function() &#123;</div><div class="line">  return gulp</div><div class="line">      .src(config.images)</div><div class="line">      .pipe($.rename(function(path) &#123;</div><div class="line">        path.dirname = path.dirname.replace(/.*\\images(.*)/, &apos;images$1&apos;);</div><div class="line">        path.dirname = path.dirname.replace(/.*\\img(.*)/, &apos;img$1&apos;);</div><div class="line">      &#125;))</div><div class="line">    .pipe(gulp.dest(config.build + &apos;images/&apos;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="最后调用任务"><a href="#最后调用任务" class="headerlink" title="最后调用任务"></a>最后调用任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gulp.task(&apos;default&apos;, [&apos;rev&apos;,&apos;images&apos;]);</div></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>刚接触gulp目前只是实现了更能，代码还有很多不足和优化地方欢迎指正O(∩_∩)O哈哈~<br><a href="https://github.com/lennonover/Gulp" target="_blank" rel="external">源码</a> </p>
<h3 id="注：任务依赖要处理好"><a href="#注：任务依赖要处理好" class="headerlink" title="注：任务依赖要处理好"></a>注：任务依赖要处理好</h3>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/07/11/用Gulp优化项目/" class="archive-article-date">
  	<time datetime="2016-07-11T12:49:47.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-07-11</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Gulp/">Gulp</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JS作用域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/08/JS作用域/">JS作用域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript的作用域链"><a href="#JavaScript的作用域链" class="headerlink" title="JavaScript的作用域链"></a>JavaScript的作用域链</h2><p>JavaScript需要查询一个变量x时，首先会查找作用域链的第一个对象，如果以第一个对象没有定义x变量，JavaScript会继续查找有没有定义x变量，如果第二个对象没有定义则会继续查找，以此类推。下面的代码涉及到了三个作用域链对象，依次是：inner、rainman、window。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var rain = 1;</div><div class="line">function rainman()&#123;</div><div class="line">    var man = 2;</div><div class="line">    function inner()&#123;</div><div class="line">        var innerVar = 4;</div><div class="line">        //var rain = 5;//函数体内部，局部变量的优先级比同名的全局变量高。</div><div class="line">        alert(rain);</div><div class="line">    &#125;</div><div class="line">    inner();    //调用inner函数 1</div><div class="line">&#125;</div><div class="line">rainman();    //调用rainman函数</div></pre></td></tr></table></figure></p>
<h2 id="JavaScript没有块级作用域"><a href="#JavaScript没有块级作用域" class="headerlink" title="JavaScript没有块级作用域"></a>JavaScript没有块级作用域</h2><p>比如if条件语句，就不算一个独立的作用域.<br>为了解决块级作用域，<br>ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量.<br>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function func() &#123;</div><div class="line">  if (true) &#123;</div><div class="line">    var tmp = 123;</div><div class="line">  &#125;</div><div class="line">  console.log(tmp); // 123 var关键字声明的变量有一个变量提升的过程</div><div class="line">&#125;</div><div class="line"></div><div class="line">function func() &#123;</div><div class="line">  if (true) &#123;</div><div class="line">    let tmp = 123;</div><div class="line">  &#125;</div><div class="line">  console.log(tmp); // ReferenceError: tmp is not defined</div><div class="line">&#125;</div><div class="line"></div><div class="line">const PI = 3.14;</div><div class="line">PI = 3; // 某些浏览器不报错，但是无效果！</div><div class="line">PI; // 3.14</div></pre></td></tr></table></figure></p>
<h2 id="函数中声明的变量在整个函数中都有定义"><a href="#函数中声明的变量在整个函数中都有定义" class="headerlink" title="函数中声明的变量在整个函数中都有定义"></a>函数中声明的变量在整个函数中都有定义</h2><p>由于在函数rain内局部变量x在整个函数体内都有定义（ var x= ‘rain-man’，进行了声明），所以在整个rain函数体内隐藏了同名的全局变量x。这里之所以会弹出’undefined’是因为，第一个执行alert(x)时，局部变量x仍未被初始化。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var x = 1;</div><div class="line">   function rain()&#123;</div><div class="line">       alert( x );        //弹出 &apos;undefined&apos;，而不是1</div><div class="line">       var x = &apos;rain-man&apos;;</div><div class="line">       alert( x );        //弹出 &apos;rain-man&apos;</div><div class="line">   &#125;</div><div class="line">   rain();</div><div class="line">   //等效于下面</div><div class="line">   var x = 1;</div><div class="line">   function rain()&#123;</div><div class="line">    var x;</div><div class="line">    alert( x );</div><div class="line">    x = &apos;rain-man&apos;;</div><div class="line">    alert( x );</div><div class="line">&#125;</div><div class="line">   rain();</div></pre></td></tr></table></figure></p>
<h2 id="未使用var关键字定义的变量都是全局变量、全局变量都是window对象的属性"><a href="#未使用var关键字定义的变量都是全局变量、全局变量都是window对象的属性" class="headerlink" title="未使用var关键字定义的变量都是全局变量、全局变量都是window对象的属性"></a>未使用var关键字定义的变量都是全局变量、全局变量都是window对象的属性</h2>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/07/08/JS作用域/" class="archive-article-date">
  	<time datetime="2016-07-08T15:53:28.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-07-08</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 lennonover
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Gulp/" style="font-size: 10px;">Gulp</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/原型/" style="font-size: 10px;">原型</a> <a href="/tags/居中/" style="font-size: 10px;">居中</a> <a href="/tags/布局/" style="font-size: 10px;">布局</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>