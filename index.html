<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一丿口石砳磊">
<meta property="og:type" content="website">
<meta property="og:title" content="lennonover">
<meta property="og:url" content="https://github.com/lennonover/index.html">
<meta property="og:site_name" content="lennonover">
<meta property="og:description" content="一丿口石砳磊">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lennonover">
<meta name="twitter:description" content="一丿口石砳磊">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/lennonover/"/>





  <title> lennonover </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lennonover</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2022/01/29/figmabot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2022/01/29/figmabot/" itemprop="url">
                  Icon 图标交付-我们有了最友好的方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-29T20:51:44+08:00">
                2022-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为了解决在维护 Web 图标库时所面临的痛苦，期望打造最友好的从设计到研发图标交付方案，我希望它们能让更多的开发者和设计师受益，让网站建设更简单、更快速，更高效。</p>
<h2 id="之前的方案"><a href="#之前的方案" class="headerlink" title="之前的方案"></a>之前的方案</h2><p>目前团队没有统一的图标库，对于图标的使用根据业务有两种，针对移动端（H5）设计交付设计稿后研发图片形式集成到项目中使用；对于 web 端设计同学有在 Iconfont 维护字体图标也就是 IconFont 但是在维护过程比较繁琐。</p>
<h3 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h3><p>在移动端场景，开发同学目前都是根据设计交付的设计稿在 Figma 导出图片资源使用，为了解决图片上传问题也开发相应 chrome 插件自动上传。再此场景使用图片也是可以的也是最基础的处理方式，问题就是相同图标无法复用。</p>
<h3 id="IconFont"><a href="#IconFont" class="headerlink" title="IconFont"></a>IconFont</h3><p>Web Font 的发展得益于 CSS3 的 @font-face 属性。我们通常看到的图标都是以图片形式集成到项目中使用，Iconfont 是一套字体图标由<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里妈妈</a>团队出品，和我们使用自定义字体的方式是一样的，并且它是一种矢量图标，在 web 端用到 iconfont 相对较多，但是很少移动端很少采用 iconfont；<br>IconFont 的使用支持 unicode 引用、 font-class 引用和 symbol 引用<a href="https://www.iconfont.cn/help/detail?helptype=code" target="_blank" rel="noopener">三种</a>，简单总结一下 iconfont 的优缺点：</p>
<ul>
<li>优点</li>
<li>缩放不会模糊</li>
<li>跨平台一套资源可在 web、iOS、Android 等多个平台使用</li>
<li>体积小包含几十个图标的字体包比一个 svg 图标资源的体积还要小</li>
<li>缺点</li>
<li>更新成本高，目前没有特别友好的解决方案这样是本文最重要的原因</li>
<li>毕竟是字体图标在没有目前浏览器还没实现渐进式字体前还是有体验问题</li>
<li>虽然支持了彩色图标，但是无法和单色共存，也是依赖浏览器的彩色字体（COLR）规范的实现<br>随着我们前端一体化平台建设，我们在开发平台 icon 库遇到最大的问题组件库的更新，也就是如何和设计协作，针对现有的 Iconfont 的协作方式目前无法满足，尤其针对在后续的更新维护。我们期望有个高效的协作方式，参考了业界 <a href="https://github.com/leadream/Figma-icon-automation">Juuun</a>开源 和 github icon 的技术方案实现了以下方案。</li>
</ul>
<h2 id="现在的方案"><a href="#现在的方案" class="headerlink" title="现在的方案"></a>现在的方案</h2><p>现在我们采用 Figma + Figma 插件 + gitlab CI 生成 SVG React/Vue 组件库。 1.对于设计只需要在 Figma Icon 页面运行插件<br>由于我们公司当前设计工作都迁移在 Figma ，所以对于设计只需要在 Figma 维护一个 Icon 资源页面，当 Icon 需要更新时运行插件：<br><img src="https://cdn.poizon.com/node-common/fba7ff8860e15e6b484aec1ca1b50ae6.png" alt=""><br><img src="https://cdn.poizon.com/node-common/63f710ce37a1b35c80da5cfcd3427891.png" alt=""> 2.开发在飞书群收到 MR 通知<br><img src="https://cdn.poizon.com/node-common/7cfea293016a78e8be0f4c1741d005fe.png" alt=""><br>对于研发可以从机器人了解到操作人、修改的内容，我们会根据仓库 ID 配置 MR 同步到多仓库，同时对比当前版本和私服最新版本的差异避免误操作。 3.审核修改内容合并 MR 执行 gitlab CI<br><img src="https://cdn.poizon.com/node-common/9a953485449d131d4c9f6a331b5b68f0.png" alt=""><br>开发根据修改内容决定是否合并，如果合并 CI 会执行三个 Stages 分别是 install 获取依赖；build 通过 Figma API 获取 svg 图标并构建成 React 和 Vue 版本组件库；publish 推送到 npm 同时将图标站点推送到静态服务方便查找图标。<br><img src="https://cdn.poizon.com/node-common/7e3f39c484a2b6a99ca156e2462ebf42.png" alt=""><br>4.CI 发布到 npm 仓库、静态站点成功后飞书再次通知完成<br>这时候开发界面可以根据版本预览到图标使用<br><img src="https://cdn.poizon.com/node-common/8c33b16da002fd1995bdcd08ed55082a.png" alt=""> 5.开发使用时只需要更新对应的 npm 包（React、Vue）</p>
<h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>为什么选择 svg 方案，回看图标演进从雪碧图到 iconfont，再到 SVG 图片，以及内联 SVG 代码的 React/Vue 组件，组件无疑是目前最方便的模式。参考 Vite 的核心理念就是一切都是按需的，模块只有在被请求时才会被转换。通过将所有图标编译成多个文件并将它们作为 npm 包分发来解决这个问题，因此我们开发 react 和 vue 两个版本的 npm 包。同时 svg 也有着以下特点：</p>
<ul>
<li>svg 可缩放矢量图形可以无损放大，也不会出现字体渲染锯齿问题表现最好</li>
<li>可着色能力我们可以使用 fill=”currentColor” 来为 SVG 着色（ CSS filters 和 CSS Mask 也可以）</li>
<li>灵活性 Inline svg 直接写进 html 特别适合组件化<br><a href="https://css-tricks.com/icon-fonts-vs-svg/" target="_blank" rel="noopener">Inline SVG vs Icon Fonts</a> 也给出了详细的 Inline Svg 与 Icon Fonts 之间的区别。当然 svg 还有很多可玩比如：张老师的<a href="https://www.zhangxinxu.com/wordpress/2018/08/css-svg-background-image-base64-encode/" target="_blank" rel="noopener">《学习了，CSS 中内联 SVG 图片有比 Base64 更好的形式》</a>等等，这里不过多介绍。</li>
</ul>
<h3 id="Figma"><a href="#Figma" class="headerlink" title="Figma"></a>Figma</h3><p>Figma 是一个 基于浏览器 的协作式 UI 设计工具，从推出至今越来越受到 UI 设计师的青睐很多的设计团队投入了 Figma 的怀抱。同时它已经推出的 Web API，通过 API 可以快速轻松地对内部公司工作流程进行脚本改进，或将 Figma 与其他工具集成。也就为我们从 Figma 图标文件生成 React/Vue 组件代码提供了能力。</p>
<h3 id="Figma-插件"><a href="#Figma-插件" class="headerlink" title="Figma 插件"></a>Figma 插件</h3><p>Figma 插件类似于浏览器插件，使用 Web 技术（HTML/CSS/JS）进行开发。Figma 为插件提供的沙箱环境，可以访问到 Figma 全局变量用于获取文档内容，但是屏蔽了其它的各种全局变量，如 window、document 以及 fetch 等，可以避免恶意插件越权访问未授权的内容或破坏程序运行环境，提升安全性，你可以理解成 main 和 ui，其中 main 代码运行在沙箱之中，ui 部分代码运行在 iframe 之中。编程过程涉及到两个窗口之间的通信用 postMessage，其他详见<a href="https://www.Figma.com/plugin-docs/intro/" target="_blank" rel="noopener">官方文档</a>。<br>在设计执行插件通知时，为了避免删除或者重命名 ICON 而造成更新后老版本不兼容，新增了版本对比及时提醒：<br><img src="https://cdn.poizon.com/node-common/83dcc404cd2c2207d0c727de82734a43.png" alt=""></p>
<h3 id="Figma-Web-Api"><a href="#Figma-Web-Api" class="headerlink" title="Figma Web Api"></a>Figma Web Api</h3><p>通过 <a href="https://www.figma.com/developers/api" target="_blank" rel="noopener">web api</a> 就可以拿到原始的 svg 图标资源，通过脚本对 svg 图标处理，因此我们和设计定了一些规则：</p>
<ol>
<li>确保图标基础尺寸是 24*24</li>
<li>每个图标必须编组 create component（Option+Command+K）</li>
<li>如果是彩色图标可以在命名中包含 <code>colr</code> 例如 social-wechatcolr-origin</li>
<li>图标命名请使用英文（不可以含 /）和 -，例如 dewu-logo-original</li>
<li>图标一般有描边（stroke）和填充（fill）两种样式，一个图标只能采用一种形式，不可以混合，默认 fill。想要转为 fill 样式，你可以使用 Outline Stroke（Shift+Command+O） 将图标转换为填充形状。<br>通过图标命名我们对 svg 处理成单色（去掉原始颜色设置 fill=”currentColor”）、彩色（保留原始颜色）。</li>
</ol>
<h3 id="Gitlab-Api"><a href="#Gitlab-Api" class="headerlink" title="Gitlab Api"></a>Gitlab Api</h3><p>通过 GitLab API 获取、操作 GitLab 项目，详见官方文档。我们主要用到了 repository 、merge_requests 两个模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getPackageContent();</span><br><span class="line">updatePackage();</span><br><span class="line">createBranch();</span><br><span class="line">createMRequest();</span><br></pre></td></tr></table></figure>
<h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>在通过 Figma Web Api 获取 svg 文件并根据规则处理 svg 文件后，我们需要编码把 svg icon 转换成 React 和 Vue 的组件库。对于 svg 文件处理使用了第三方 svgo，svgo 是 SVG Optimizer 的简写，是一个基于 Nodejs 的 SVG 文件优化工具，简单使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">constSvgo = <span class="built_in">require</span>(<span class="string">"svgo"</span>);</span><br><span class="line">constsvgo = newSvgo(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    &#123; <span class="attr">convertShapeToPath</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">mergePaths</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">removeAttrs</span>: &#123; <span class="attr">attrs</span>: <span class="string">"(fill|stroke.*)"</span> &#125; &#125;,</span><br><span class="line">    &#123; <span class="attr">removeTitle</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line">svgo.optimize(svg);</span><br></pre></td></tr></table></figure>
<p>这里面的 <code>{ removeAttrs: { attrs: &#39;(fill|stroke.*)&#39; } }</code> 是为了都给图标去色，当然对于彩色图标是不要去色。后面就是真的单个 svg 文件生成组件，过程不再赘述。</p>
<h3 id="Gitlab-CI"><a href="#Gitlab-CI" class="headerlink" title="Gitlab CI"></a>Gitlab CI</h3><p>GitLab CI 是 GitLab 内置的进行持续集成的工具，只需要在仓库根目录下创建 .gitlab-ci.yml 文件，并配置 GitLab Runner；每次提交的时候，gitlab 将自动识别到.gitlab-ci.yml 文件，并且使用 Gitlab Runner 执行该脚本。公司部署的 Gitlab 已有公共 Runner 所以我们只需编写 .gitlab-ci.yml 文件即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">image: node:14.13.1</span><br><span class="line"><span class="meta">#</span> 定义 stages</span><br><span class="line">stages:</span><br><span class="line"> - install</span><br><span class="line"> - build</span><br><span class="line"> - publish</span><br><span class="line"><span class="meta">#</span> 定义 job</span><br><span class="line">install-staging:dep:</span><br><span class="line"> stage: install</span><br><span class="line"> tags:</span><br><span class="line"> - ep-share</span><br><span class="line"> only:</span><br><span class="line"> - master</span><br><span class="line"> script:</span><br><span class="line"> - echo"=====start install======"</span><br><span class="line"> - yarn</span><br><span class="line"> - echo"=====end install======"</span><br><span class="line"> artifacts:</span><br><span class="line"> expire_in: 60 mins</span><br><span class="line"> paths:</span><br><span class="line"> - node_modules/</span><br><span class="line">build-staging:dep:</span><br><span class="line"><span class="meta">#</span> 省略 build 代码</span><br><span class="line">publish-staging:dep:</span><br><span class="line"><span class="meta">#</span> 省略 publish 代码</span><br></pre></td></tr></table></figure>
<p>我们设置 master 变化是执行：<br><img src="https://cdn.poizon.com/node-common/f2a2913706486582d9de34704f05d404.png" alt=""></p>
<h3 id="图标文档站点"><a href="#图标文档站点" class="headerlink" title="图标文档站点"></a>图标文档站点</h3><p>我们通过把构建后的静态站点和组件包同步到 npm 私服上，由于我们内网部署了 unpkg 的 CDN 服务，所以我们只需要根据版本就能访问到相应的文档，例如：<a href="https://unpkg.shizhuang-inc.com/poizon-react-icon@1.0.6/docs/index.html" target="_blank" rel="noopener">https://unpkg.shizhuang-inc.com/poizon-react-icon@1.0.6/docs/index.html</a><br><code>poizon-react-icon</code> 的 <code>1.0.6</code> 版本文档，这样好处是不用再关心文档部署，同时也提供了文档版本管理的能力。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们再来回顾完整交付更新流程，设计和研发整个过程只需要在自己工作流中简单操作即可完成图标交付，非常高效！当然任何技术方案都有它的优劣，最重要的还是根据需求取舍，未来渐进式字体和彩色字体的推进我们也可能会拥抱 font 同时也会有新的交付方案，但是对于我们目前阶段最合适的还是这套。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/leadream/Figma-icon-automation">https://github.com/leadream/Figma-icon-automation</a></li>
<li><a href="https://www.Figma.com/plugin-docs/intro/" target="_blank" rel="noopener">https://www.Figma.com/plugin-docs/intro/</a></li>
<li><a href="https://www.iconfont.cn/help/detail?helptype=code" target="_blank" rel="noopener">https://www.iconfont.cn/help/detail?helptype=code</a></li>
<li><a href="https://gist.github.com/banyudu/f7472f935897adfbb54cc8eb38dc5373" target="_blank" rel="noopener">https://gist.github.com/banyudu/f7472f935897adfbb54cc8eb38dc5373</a></li>
<li><a href="https://github.blog/2018-04-12-driving-changes-from-designs/" target="_blank" rel="noopener">https://github.blog/2018-04-12-driving-changes-from-designs/</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/11/15/的顺序机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/11/15/的顺序机制/" itemprop="url">
                  你不知道的 for in 中 key 的顺序机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-15T22:39:11+08:00">
                2021-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近开发业务遇到一个需求:<br><img src="https://cdn.poizon.com/node-common/f5a595aaf7c5546bb0fe4115b0ef33e2.png" alt="图片"><br>产品希望把公司按照他希望的顺序排列，我们当前的实现逻辑是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sectionMapToArray = <span class="function">(<span class="params"><span class="built_in">Object</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> _arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = <span class="built_in">Object</span>[key];</span><br><span class="line">      _arr.push(&#123;</span><br><span class="line">        label: element,</span><br><span class="line">        value: key,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很简单的一个循环操作，但是它引发了什么问题呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  <span class="string">"010101"</span>: <span class="string">"识装信息"</span>,</span><br><span class="line">  <span class="number">102</span>: <span class="string">"识装集团"</span>,</span><br><span class="line">  <span class="number">101</span>: <span class="string">"得物集团"</span>,</span><br><span class="line">  A01: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 '101'、'102'、'010101'、‘A01’</span></span><br></pre></td></tr></table></figure>
<p>我们看到输出的顺序变了,理想状态下是输出 ‘010101’、’102’、’101’、‘A01’</p>
<ul>
<li>猜想一 按照 key 的 ASC 码</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  A: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">  <span class="string">"010101"</span>: <span class="string">"识装信息"</span>,</span><br><span class="line">  识装集团: <span class="string">"识装集团"</span>,</span><br><span class="line">  <span class="number">101</span>: <span class="string">"得物集团"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 '101'、'A'、'010101'、‘识装集团’</span></span><br></pre></td></tr></table></figure>
<p>对象的遍历输出并不是按照属性的 ASC 码升序排序。</p>
<ul>
<li>猜想二 按照 key 转换成整数的大小</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  <span class="string">"010101"</span>: <span class="string">"识装信息"</span>,</span><br><span class="line">  <span class="number">102</span>: <span class="string">"识装集团"</span>,</span><br><span class="line">  <span class="number">101</span>: <span class="string">"得物集团"</span>,</span><br><span class="line">  A01: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 '101'、'102'、'010101'、‘A01’</span></span><br></pre></td></tr></table></figure>
<p>我们在再看开头的例子好像是按照 key 的整数大小，测试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  <span class="string">"010101"</span>: <span class="string">"识装信息"</span>,</span><br><span class="line">  <span class="number">102</span>: <span class="string">"识装集团"</span>,</span><br><span class="line">  <span class="number">101</span>: <span class="string">"得物集团"</span>,</span><br><span class="line">  <span class="string">"-100"</span>: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 '101'、'102'、'010101'、‘-100’</span></span><br></pre></td></tr></table></figure>
<p>看结果 -100 应该是第一个但是并没有，在猜测一下是非负数整数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  <span class="string">"010101"</span>: <span class="string">"识装信息"</span>,</span><br><span class="line">  <span class="number">102</span>: <span class="string">"识装集团"</span>,</span><br><span class="line">  <span class="number">101</span>: <span class="string">"得物集团"</span>,</span><br><span class="line">  测试: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">  <span class="string">"-100"</span>: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 '101'、'102'、'010101'、'测试'、‘-100’</span></span><br></pre></td></tr></table></figure>
<p>看结果似乎似乎接近真相了,我们在试试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  <span class="string">"010101"</span>: <span class="string">"识装信息"</span>,</span><br><span class="line">  <span class="string">"0101"</span>: <span class="string">"识装信息"</span>,</span><br><span class="line">  <span class="number">102</span>: <span class="string">"识装集团"</span>,</span><br><span class="line">  <span class="number">101</span>: <span class="string">"得物集团"</span>,</span><br><span class="line">  测试: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">  <span class="string">"-100"</span>: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 '101'、'102'、'010101'、'0101'、'测试'、‘-100’</span></span><br></pre></td></tr></table></figure>
<p>我们发现 ‘010101’、’0101’ 这两个位置并不对，但是到这里已经没有什么头绪只能去查资料。</p>
<h2 id="排序机制"><a href="#排序机制" class="headerlink" title="排序机制"></a>排序机制</h2><blockquote>
<p>integer properties are sorted, others appear in creation order.<br>通过查阅资料发现这么定义：当 key 整数类型会做一层排序，其他类型则按创建顺序来排。<br>但是我们通过最后例子可以发现 ‘010101’、’0101’ 转换成 number 后并不符合，所以如何定义 integer 整数？<br>通过上 integer 关键词在 <a href="https://262.ecma-international.org/6.0" target="_blank" rel="noopener"></a> 查找：<br>An integer index is a String-valued property key that is a canonical numeric String (see 7.1.16) and whose numeric value is either +0 or a positive integer ≤ 2^53−1. An array index is an integer index whose numeric value i is in the range +0 ≤ i &lt; 2^32−1.<br>我们发现 <code>canonical numeric String (see 7.1.16)</code> 有定义 integer :<br>The abstract operation CanonicalNumericIndexString returns argument converted to a numeric value if it is a String representation of a Number that would be produced by ToString, or the string “-0”. Otherwise, it returns undefined. This abstract operation functions as follows:<br>1.Assert: Type(argument) is String.<br>2.If argument is “-0”, return −0.<br>3.Let n be ToNumber(argument).<br>4.If SameValue(ToString(n), argument) is false, return undefined.<br>5.Return n.<br>A canonical numeric string is any String value for which the CanonicalNumericIndexString abstract operation does not return undefined.&gt;<br>通过 7.1.16 我们知道会把 key 转换成数字，由于转换数字过程，第四条规则：<br>SameValue(ToString(n), argument)<br>我们知道 SameValue 是 Object.is() 内部采用的比较算法类似于 ===，区别保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true。<br>所以也就出现了 SameValue(TOString(10101),’010101’) 为 false 的情况就解释了</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  <span class="string">"010101"</span>: <span class="string">"识装信息"</span>,</span><br><span class="line">  <span class="string">"0101"</span>: <span class="string">"识装信息"</span>,</span><br><span class="line">  <span class="number">102</span>: <span class="string">"识装集团"</span>,</span><br><span class="line">  <span class="number">101</span>: <span class="string">"得物集团"</span>,</span><br><span class="line">  测试: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">  <span class="string">"-100"</span>: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 '101'、'102'、'010101'、'0101'、'测试'、‘-100’</span></span><br></pre></td></tr></table></figure>
<p>‘010101’、’0101’ 的顺序问题</p>
<h2 id="2-32−1"><a href="#2-32−1" class="headerlink" title="2^32−1"></a>2^32−1</h2><p>我们回过来在看文档中 2^32−1 代表什么意思，在看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  <span class="string">"010101"</span>: <span class="string">"识装信息"</span>,</span><br><span class="line">  <span class="number">10188988888</span>: <span class="string">"识装信息"</span>,</span><br><span class="line">  <span class="number">102</span>: <span class="string">"识装集团"</span>,</span><br><span class="line">  <span class="number">101</span>: <span class="string">"得物集团"</span>,</span><br><span class="line">  测试: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">  <span class="string">"-100"</span>: <span class="string">"JiaWu Pro"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 '101'、'102'、'010101'、'10188988888'、'测试'、‘-100’</span></span><br></pre></td></tr></table></figure>
<p>我们发现 <code>10188988888</code> 在 <code>010101</code> 的前面，按照之前的逻辑应该是反着来的，所以就要介绍下 2^32−1：<br>32 位无符号整数的最大值。<br>为什么会有 2^32−1 边界限制，这里又涉及到 V8 的排序实现，大概意思是因为性能原因 详见：<a href="https://zhuanlan.zhihu.com/p/26169639" target="_blank" rel="noopener">从 Chrome 源码看 JS Object 的实现</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当 key 整数类型会做一层排序，其他类型则按创建顺序来排，关于什么是整数类型要同时满足 <code>canonical numeric String</code> 和 <code>+0 ≤ i &lt; 2^32−1</code></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring" target="_blank" rel="noopener">https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26169639" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26169639</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/11/07/物料市场组件monorepo架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/11/07/物料市场组件monorepo架构/" itemprop="url">
                  物料市场-组件 monorepo 架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-07T15:35:30+08:00">
                2021-11-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近平台启动了物料市场技术项目，目的是通过提供丰富可复用物料、一体化物料解决方案、全链路研发来实现对研发体验和研发效率的提升。在设计公共组件架构时平台采用了多包架构（Monorepo），一套灵活的组件研发体系，并且天然支持按需使用。</p>
<h2 id="什么是-Monorepo"><a href="#什么是-Monorepo" class="headerlink" title="什么是 Monorepo"></a>什么是 Monorepo</h2><p>monorepo 是一种将多个项目代码存储在一个仓库里的软件开发策略，这种方式在一个项目仓库（repo）中管理多个模块/包（package）。很多出名开源的项目都是采纳的 monorepo 的组织形式，比如 Babel，React ,Jest, create-react-app, react-router 、 npm@7 也带来一流的 monorepo 支持等等。</p>
<h2 id="monorepo-的优劣"><a href="#monorepo-的优劣" class="headerlink" title="monorepo 的优劣"></a>monorepo 的优劣</h2><h3 id="monorepo-的优势"><a href="#monorepo-的优势" class="headerlink" title="monorepo 的优势"></a>monorepo 的优势</h3><ul>
<li>代码重用将变得非常容易</li>
<li>依赖管理将变得非常简单</li>
<li>代码重构将变得非常便捷</li>
</ul>
<h3 id="monorepo-的劣势"><a href="#monorepo-的劣势" class="headerlink" title="monorepo 的劣势"></a>monorepo 的劣势</h3><ul>
<li>项目粒度的权限管理变得非常复杂（既是优点也是缺点）</li>
<li>学习成本变高</li>
<li>库体积超大，目录结构复杂度上升<br>基于两者的优缺点，结合我们当前组件库的特点：<br>● 每个包之间是有相关依赖的。<br>● 统一的构建工具，统一发版。<br>● 对版本的说明要求较高<br>所以我们推荐采用 Monorepo 对组件库进行管理，目前最常见的 Monorepo 解决方案是 Lerna 和 Yarn 的 workspaces 特性。我们采用 Yarn 官方推荐的做法，用 Yarn 来处理依赖问题，用 Lerna 来处理发布问题。</li>
</ul>
<h2 id="lerna"><a href="#lerna" class="headerlink" title="lerna"></a>lerna</h2><blockquote>
<p>A tool for managing JavaScript projects with multiple packages. Lerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm.<br>基于上文我们可以知道 lerna 是最出名的 monorepo 的管理工具，也是当前项目采用的方案<br>通过 lerna 创建的项目结构</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- packages(目录)</span><br><span class="line">- lerna.json(配置文件)</span><br><span class="line">- package.json(工程描述文件)</span><br></pre></td></tr></table></figure>
<p>lerna.json 文件，默认内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;packages&quot;: [&quot;packages/*&quot;],</span><br><span class="line">&quot;version&quot;: &quot;0.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们根据需求修改之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;packages&quot;: [&quot;packages/*&quot;],</span><br><span class="line">&quot;npmClient&quot;: &quot;yarn&quot;,</span><br><span class="line">&quot;version&quot;: &quot;independent&quot;,</span><br><span class="line">&quot;useWorkspaces&quot;: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>npmClient<br>我们显示声明了我们的包客户端为 yarn。</li>
<li>useWorkspaces<br>让 Lerna 追踪我们 workspaces 设置的目录。</li>
<li>version<br>independent 将每个子项目的版本号看作是相互独立的。</li>
</ul>
<h3 id="Verdaccio"><a href="#Verdaccio" class="headerlink" title="Verdaccio"></a>Verdaccio</h3><p>一个 npm 包本地发布工具，使用 Verdaccio 可以在本地创建一个 npm 仓库作为代理用来测试 lerna。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global verdaccio</span><br></pre></td></tr></table></figure>
<p>在您的项目根目录创建 .npmrc 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry=&quot;http://localhost:4873/&quot;</span><br></pre></td></tr></table></figure>
<p>每当您执行 lerna publish 时，子项目所构建成的 package 将会发布在本地 npm 仓库中，而当您执行 lerna bootstrap 时，Verdaccio 将会放行，让您成功从远程 npm 仓库中拉取相应的代码。</p>
<h3 id="lerna-常用命令"><a href="#lerna-常用命令" class="headerlink" title="lerna 常用命令"></a>lerna 常用命令</h3><ul>
<li>lerna init<br>初始化 lerna 项目</li>
<li>lerna create <name><br>创建一个新的由 lerna 管理的包。</name></li>
<li>lerna add axios<br>增加模块包到最外层的公共 node_modules 中</li>
<li>lerna add A –scope=B<br>增加模块包到 packages 中指定项目，例如将 A 模块增加到 B 项目中</li>
<li>lerna list<br>显示所有的安装的包</li>
<li>lerna clean<br>从所有包中删除 node_modules 目录</li>
<li>lerna publish<br>在当前项目中发布包 publish 不会发布 package.json 中 private 为 true 的包</li>
<li>lerna bootstrap<br>lerna 提供了可以将子项目的依赖包提升到最顶层的方式 ，我们可以执行 lerna clean 先删除每个子项目的 node_modules , 然后执行命令 lerna bootstrop –hoist。<br>基于上面的命令我们的脚手架 duwork 也同步实现</li>
</ul>
<h3 id="物料按照-Monorepo-的方式组织代码结构"><a href="#物料按照-Monorepo-的方式组织代码结构" class="headerlink" title="物料按照 Monorepo 的方式组织代码结构"></a>物料按照 Monorepo 的方式组织代码结构</h3><p>包的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- packages</span><br><span class="line">- buttonA 组件 A</span><br><span class="line">- __test__ //存放测试相关代码</span><br><span class="line">- dist // 打包的目录</span><br><span class="line">- doc // 组件的文档</span><br><span class="line">- src // 存放源码</span><br><span class="line">- index.js // 打包的入口文件</span><br><span class="line">- LICENSE // 版权信息（MIT）</span><br><span class="line">- package.json // 组件的描述信息</span><br><span class="line">- buttonB 组件 B</span><br></pre></td></tr></table></figure>
<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建</span><br><span class="line">duwork create -c</span><br><span class="line">打包</span><br><span class="line">duwork build</span><br><span class="line">发布</span><br><span class="line">duwork publish</span><br></pre></td></tr></table></figure>
<p>正常的开发流程是每个人新建一个 git branch，通过代码审核之后进行合并。从上面可以看到整套流程在 monorepo 架构下变得非常清晰。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文我们介绍了 monorepo，以及最佳实践，monorepo 给我们带来的收益是非常可观的，可能您的场景并不试用 monorepo，所以说脱离实际情况谈最优解都是不切实际的想法，一个模式的提出必定面对解决一个问题，但是即使您的场景并不试用 monorepo，还是希望工具和思想也可以运用到工作之中。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://github.com/lerna/lerna/tree/main/utils/create-symlink">https://github.com/lerna/lerna/tree/main/utils/create-symlink</a></li>
<li><a href="https://jishuin.proginn.com/p/763bfbd5505d" target="_blank" rel="noopener">https://jishuin.proginn.com/p/763bfbd5505d</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/10/04/我们是如何保证前端项目质量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/10/04/我们是如何保证前端项目质量/" itemprop="url">
                  我们是如何保证前端项目质量
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-04T17:12:58+08:00">
                2021-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本篇文章主要介绍一下我们团队开发过程中，如何做代码质量的把控和提升。</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>代码质量是一个项目最重要部分，更好的质量的代码，能够产生更少的 bug，从而让项目的质量得到提升。业务快速增长，随之而来的前端需求激增，同时经过我们的分析，发现当前我们开发流程存在的一些问题：</p>
<ul>
<li>如何高效团队 CR？</li>
<li>开发人员怎么衡量项目的质量？</li>
<li>每个公司都有一个安全团队，他们负责公司一些代码安全，但是如果他万一发生一些问题的时候，通知到我们团队的时候，我们如何响应他们？</li>
<li>团队沉淀、基建落地如何量化提供一个参考依据</li>
<li>重构后的代码，除了一些我们通过一些生产或者性能对比，如何从代码层面来展示我们的量化结果。<br>面对上面的问题，就需要我们通过一些技术手段来实现，通过代码的扫描来找到潜在的问题。我们构建出衡量项目质量的模型，通过模型对项目分析输出评估结果反馈对进行质量趋势分析来推动优化。</li>
</ul>
<h2 id="如何定义质量模型？"><a href="#如何定义质量模型？" class="headerlink" title="如何定义质量模型？"></a>如何定义质量模型？</h2><p>衡量质量基础是要可量化，结合我们目前项目常用的标准主要从、技术选型、开发规范、可维护性和安全四个方面：</p>
<ul>
<li>技术选型<br>主要关注框架的技术选型是否先进、主流、收敛，例如：框架、请求库、UI 库。</li>
<li>编码规范<br>主要包含是否遵守了最佳实践和团队编码规范（readme<br>、npm script、git 工作流、Mock、Eslint、团队最佳实践<br>）。</li>
<li>可维护性<br>代码分层、模块化、圈复杂度、重复率、大文件、文档等得出可读性及复杂度评分。</li>
<li>安全<br>基于团队开发规范，检测可能存在的安全风险（外链、敏感成词、token、npm 包等）。</li>
</ul>
<h2 id="如何检测？"><a href="#如何检测？" class="headerlink" title="如何检测？"></a>如何检测？</h2><p>通过代码静态分析的方式检测代码质量，平台整体架构分成四部分：</p>
<ul>
<li>代码分析计算服务：用于仓库代码元数据采集和规则检测，质量计算</li>
<li>数据平台后端服务：用于存储采集的数据，为前端展示提供数据</li>
<li>数据平台前端服务：用于对采集的数据可视化分析展示</li>
<li>数据平台 web 可视化界面<br>系统工作流程主要分为两种：</li>
<li>自动脚本服务定时拉取分析仓库代码，通过代码静态分析匹配规则生成检测结果计算出质量分，通过邮件、飞书等形式发送本次扫描报告，开发人员可以通过报告查看负责的项目详情做进一步处理。</li>
<li>开发人员主动触发，通过指定项目分支主动触发分析脚本，根据检测结果分析。<br>同时为了能够实现编码事前修改，我们将部分检测规则的 lint 继承的本地开发环境来保证做到事前检测提升效率。</li>
</ul>
<h2 id="质量分计算"><a href="#质量分计算" class="headerlink" title="质量分计算"></a>质量分计算</h2><p>根据质量模型把各项指标加权求和，可以得到一个工程的度总分，代表它的综合评估结果，同时对质量分的历史趋势做出预判。</p>
<h2 id="实践效果"><a href="#实践效果" class="headerlink" title="实践效果"></a>实践效果</h2><h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><p>未来我们会进一步的在检测维度上继续增加，同时持续优化可视化界面的用户体验，最终目标是打造一个完善的项目质量保障平台，能够为团队项目质量带来更大的提升。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/09/22/cookies/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/09/22/cookies/" itemprop="url">
                  cookies
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-22T19:12:58+08:00">
                2021-09-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前置解释"><a href="#前置解释" class="headerlink" title="前置解释"></a>前置解释</h2><ul>
<li>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互，要求协议，端口和主机都相同。</li>
<li>HTTP 是一个无状态的协议，所谓无状态协议，简单的理解就是即使同一个客户端连续两次发送请求给服务器，服务器也识别不出这是同一个客户端发送的请求</li>
<li>Cookie 是客户端保存用户信息的一种机制，保存在客户机硬盘上。可以由服务器响应报文 Set-Cookie 的首部字段信息或者客户端 document.cookie 来设置，并随着每次请求发送到服务器。子域名可以获取父级域名 Cookie。</li>
</ul>
<h2 id="SameSite-来源"><a href="#SameSite-来源" class="headerlink" title="SameSite 来源"></a>SameSite 来源</h2><p>熟悉 web 安全攻击 CSRF 的都知道 CSRF 的本质实际上是利用了 Cookie 会自动在请求中携带的特性，诱使用户在第三方站点发起请求的行为。针对这个问题浏览器厂商对此给 cookie 加了 SameSite 属性。 Chrome 于 2015 年 6 月支持了该属性，Firefox 和 Safari 紧随其后也增加了支持。</p>
<h3 id="同域和同站"><a href="#同域和同站" class="headerlink" title="同域和同站"></a>同域和同站</h3><ul>
<li>同域是指两个 URL 的协议/主机名/端口一致，判断比较严格。</li>
<li>同站判断就比较宽松，根据 Mozilla 维护的公共后缀表（Pulic Suffix List[2]）使用有效顶级域名(eTLD)+1 的规则查找得到的一级域名是否相同来判断是否是同站请求。<br>例如：<br>.org 是在 PSL 中记录的有效顶级域名，imnerd.org 则是一级域名。所以 <a href="https://blog.imnerd.org" target="_blank" rel="noopener">https://blog.imnerd.org</a> 和 <a href="https://www.imnerd.org" target="_blank" rel="noopener">https://www.imnerd.org</a> 是同站域名。<br>.github.io 也是在 PSL 中记录的有效顶级域名，所以 <a href="https://lizheming.github.io" target="_blank" rel="noopener">https://lizheming.github.io</a> 和 <a href="https://blog.github.io" target="_blank" rel="noopener">https://blog.github.io</a> 得到的一级域名是不一样的，他们两个是跨域请求。</li>
</ul>
<h2 id="SameSite-值"><a href="#SameSite-值" class="headerlink" title="SameSite 值"></a>SameSite 值</h2><p>SameSite 属性有以下几个值：</p>
<ul>
<li>SameSite=None：无论是否跨站都会发送 Cookie</li>
<li>SameSite=Lax：允许部分第三方请求携带 Cookie</li>
<li>SameSite=Strict：只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。</li>
</ul>
<h3 id="Strict"><a href="#Strict" class="headerlink" title="Strict"></a>Strict</h3><p>Strict 最为严格只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。浏览器做了仅针对 HTTPS 域名才支持 SameSite=None 配置。所以如果你要设置 SameSite=None 的话，则必须还要携带 Secure 属性才行。<br>例如对于一个普通的站点，如果一个已经登录的用户跟踪一个在电子邮件上的网站链接，这个站点将不会收到 Cookie ，用户访问该站点还需要重新登陆。</p>
<h3 id="Lax"><a href="#Lax" class="headerlink" title="Lax"></a>Lax</h3><p>对于允许用户从外部链接到达本站并使用已有会话的网站站，默认的 Lax 值在安全性和可用性之间提供了合理的平衡。 Lax 属性只会在使用危险 HTTP 方法发送跨域 Cookie 的时候进行阻止，例如 POST 方式。同时，使用 JavaScript 脚本发起的请求也无法携带 Cookie。<br><a href="https://cdn.poizon.com/node-common/93a0229b7baac5aa63b3b4fc06efec7f.png" target="_blank" rel="noopener">lax</a><br>从上图可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送。</p>
<h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>浏览器会在同站请求、跨站请求下继续发送 Cookies，不区分大小写。</p>
<h3 id="策略改变带来的影响"><a href="#策略改变带来的影响" class="headerlink" title="策略改变带来的影响"></a>策略改变带来的影响</h3><p>在 Chrome 80+ 版本中，SameSite 的默认属性是 SameSite=Lax。如果想要指定 Cookies 在同站、跨站请求都被发送，那么需要明确指定 SameSite 为 None。Chrome 也宣布，将在下个版本也就是 Chrome 83 版本，在访客模式下禁用三方 Cookie，在 2023 年全面禁用三方 Cookie。</p>
<ul>
<li>使用的三方埋点数据异常</li>
<li>依赖 cookie 智能广告推荐失败</li>
<li>跨站请求 cookie 丢失、统一登录、支付等失败</li>
</ul>
<h2 id="FLoC"><a href="#FLoC" class="headerlink" title="FLoC"></a>FLoC</h2><p>FLoC 通过获取浏览器的浏览记录将用户加入 “相似” 用户的分组内，每个分组拥有对应的 FLoC ID。有别于之前使用 Cookie ID 标记直接将用户行为数据传递到广告商网站处理的方式。它提出了 document.interestCohort() 这个新的 API，将用户的行为在本地转换成了不带个人隐私的关键词，既规避了用户隐私问题，同时又解决了广告的精准投放问题。<br>谷歌在 Chrome 浏览器的 89 版本上小规模测试了代替 cookie 的 FLoC（Federated Learning of Cohorts, 联邦学习群组）技术。<br>微软、Opera、Firefox、GitHub，EFF 等都对此表达了反对意见。<br>如果不想启用你可以：</p>
<ul>
<li>给站点添加相关的拒绝标头：Permissions-Policy: interest-cohort=() 可以屏蔽</li>
<li>使用表示拒绝的浏览器：Brave、Vivaldi</li>
<li>使用表示暂时不会跟进的浏览器：Mozilla Firefox、Microsoft Edge</li>
</ul>
<h2 id="Cookie-作用域处理"><a href="#Cookie-作用域处理" class="headerlink" title="Cookie 作用域处理"></a>Cookie 作用域处理</h2><ul>
<li>同域名<br>当访问同域名下的页面时，Cookie 会正常携带，后台服务即可直接获取到对应的 SessionID 值，后台为单服务还是多服务无差别。</li>
<li>不同子域名<br>子域名间 Cookie 是不共享的，但各子域名均可获取到父级域名的 Cookie，即 m.dewu.com 与 jiawu.dewu.com 均可以获取 dewu.com 域名下的 Cookie。所以可以通过将 Cookie 设置在父级域名上，可以达到子域名共享的效果。</li>
<li>完全不同域名<br>不同域名是无法直接共享 Cookie ，可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage 中，也可以通过特殊手段将它写入多个其他域下的 LocalStorage 中，让前端在每次向后端发送请求时，主动将 LocalStorage 的数据传递给服务端。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 获取 token</span><br><span class="line">var token = result.data.token;</span><br><span class="line">// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML</span><br><span class="line">var iframe = document.createElement(&quot;iframe&quot;);</span><br><span class="line">iframe.src = &quot;http://app1.com/localstorage.html&quot;;</span><br><span class="line">document.body.append(iframe);</span><br><span class="line">// 使用postMessage()方法将token传递给iframe</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">iframe.contentWindow.postMessage(token, &quot;http://app1.com&quot;);</span><br><span class="line">&#125;, 4000);</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">iframe.remove();</span><br><span class="line">&#125;, 6000);</span><br><span class="line">// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage</span><br><span class="line">window.addEventListener(&apos;message&apos;, function (event) &#123;</span><br><span class="line">localStorage.setItem(&apos;token&apos;, event.data)</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>
<p>前端通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取 Token 并在请求中携带，这样就实现了同一份 Token 被多个域所共享。<br>也可以 CAS（Central Authentication Service）中央认证服务，是 Yale 大学发起的一个开源项目，旨在为 Web 应用系统提供一种可靠的单点登录方法。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.chromestatus.com/feature/5088147346030592" target="_blank" rel="noopener">https://www.chromestatus.com/feature/5088147346030592</a></li>
<li><a href="https://www.chromium.org/updates/same-site" target="_blank" rel="noopener">https://www.chromium.org/updates/same-site</a></li>
<li><a href="https://hacks.mozilla.org/2020/08/changes-to-samesite-cookie-behavior/" target="_blank" rel="noopener">https://hacks.mozilla.org/2020/08/changes-to-samesite-cookie-behavior/</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/157#">https://github.com/mqyqingfeng/Blog/issues/157#</a></li>
<li><a href="https://mp.weixin.qq.com/s/QZkOXhQIg2LqDWpi7mzCdQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QZkOXhQIg2LqDWpi7mzCdQ</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/08/09/top/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/08/09/top/" itemprop="url">
                  Top-level await
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-09T17:15:27+08:00">
                2021-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>背景： chrome 于 5 月 4 号发布 v9.1 版本 ，带来了 Top-level await 新特新，我们可以在模块顶级中使用 await，不需要在额外的加入 async。</p>
</blockquote>
<h2 id="什么是-Top-level-await"><a href="#什么是-Top-level-await" class="headerlink" title="什么是 Top-level await"></a>什么是 Top-level await</h2><p>如果我们试图在一个 async 函数外面使用 await 关键字，将会引起语法错误，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="built_in">console</span>.log(<span class="string">'执行'</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>会产生如下报错：</p>
<blockquote>
<p>await is only valid in async functions and the top level bodies of modules<br>但是在 v9.1 我们可以在模块顶级中使用 await，不需要额外的加入 async。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span>&gt;<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="built_in">console</span>.log(<span class="string">'执行'</span>))&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>并且它有着如下特点：</p>
<ul>
<li>顶层 await 在模块图的执行阶段发挥作用，此时所有的资源都已经获取并链接了，不存在资源被阻塞的风险；</li>
<li>顶层 await 只限于在 ES6 模块中使用，不支持普通脚本或者 CommonJS 模块</li>
</ul>
<h3 id="先看一个例子"><a href="#先看一个例子" class="headerlink" title="先看一个例子"></a>先看一个例子</h3><p>在使用 ES6 模块化的时候，经常会遇到需要导入导出的场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; getSum &#125; <span class="keyword">from</span> <span class="string">"./a.js"</span>;</span><br><span class="line"><span class="keyword">let</span> sum;</span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  sum = getSum(<span class="number">2</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125;;</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./b.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// undefined</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(sum), <span class="number">2000</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们在文件之间进行变量的导入导出。<br>通过分析代码我们可以发现第一次打印的都是 undefined 第二次打印得到的是 4。因为在 async 函数执行完毕之前，c.js 就已经访问了 b.js 导出的变量。name 怎么解决呢？</p>
<h4 id="导出-IIFE-promise"><a href="#导出-IIFE-promise" class="headerlink" title="导出 IIFE promise"></a>导出 IIFE promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; getSum &#125; <span class="keyword">from</span> <span class="string">"./a.js"</span>;</span><br><span class="line"><span class="keyword">let</span> sum;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  sum = getSum(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123; sum &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">import</span> promise <span class="keyword">from</span> <span class="string">"./b.js"</span>;</span><br><span class="line">promise.then(<span class="function">(<span class="params">&#123; sum &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum); <span class="comment">// 4</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(sum), <span class="number">2000</span>); <span class="comment">// 4</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们将变量作为 async IIFE 的返回值返回。这样的话，c.js 只需简单地等待 promise 被 resolve，之后获取变量。<br>但是从静态分析、可测试性、工程学以及其它角度来讲，这种做法相比 ES2015 的模块化来说是一种显而易见的倒退。</p>
<h3 id="Top-level-await-怎么解决"><a href="#Top-level-await-怎么解决" class="headerlink" title="Top-level await 怎么解决"></a>Top-level await 怎么解决</h3><p>我们仍然异步地初始化我们的导出，但是我们可以通过 Top-level await 来正常地使用 sum。<br>我们可以导入 b.js，而不需要知道它会异步初始化的导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; getSum &#125; <span class="keyword">from</span> <span class="string">"./a.js"</span>;</span><br><span class="line"><span class="keyword">let</span> sum;</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">sum = getSum(<span class="number">2</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125;;</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./b.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 4</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(sum), <span class="number">2000</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>await promise 被 resolve 之前， c.js 中任意一条语句都不会执行。</p>
<h2 id="Top-level-await-是怎么工作的"><a href="#Top-level-await-是怎么工作的" class="headerlink" title="Top-level await 是怎么工作的"></a>Top-level await 是怎么工作的</h2><p>JavaScript 会静态地确认哪些模块是异步的，这些模块导出的 Promise 都会放到 Promise.all() 中。其余的导入仍然照常处理，并且拒绝（reject）和同步的异常都会被转为异步函数。</p>
<h2 id="Top-level-await-还可以做些什么"><a href="#Top-level-await-还可以做些什么" class="headerlink" title="Top-level await 还可以做些什么"></a>Top-level await 还可以做些什么</h2><h3 id="资源初始化"><a href="#资源初始化" class="headerlink" title="资源初始化"></a>资源初始化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//connect() return a promise.</span></span><br><span class="line"><span class="keyword">const</span> connection = <span class="keyword">await</span> dbConnector.connect();</span><br></pre></td></tr></table></figure>
<h3 id="动态加载模块"><a href="#动态加载模块" class="headerlink" title="动态加载模块"></a>动态加载模块</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`./file<span class="subst">$&#123;v&#125;</span>.js`</span>);</span><br></pre></td></tr></table></figure>
<h3 id="资源加载备选方案"><a href="#资源加载备选方案" class="headerlink" title="资源加载备选方案"></a>资源加载备选方案</h3><p>如果 CDN A 无法导入 Vue，那么会尝试从 CDN B 中导入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Vue = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">"https://cdn-a.dewu.com/Vue"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  Vue = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">"https://cdn-b.dewu.com/Vue"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.bitsrc.io/why-should-you-use-top-level-await-in-javascript-a3ba8139ef23" target="_blank" rel="noopener">https://blog.bitsrc.io/why-should-you-use-top-level-await-in-javascript-a3ba8139ef23</a></li>
<li><a href="https://javascript.plainenglish.io/javascript-top-level-await-in-a-nutshell-4e352b3fc8c8" target="_blank" rel="noopener">https://javascript.plainenglish.io/javascript-top-level-await-in-a-nutshell-4e352b3fc8c8</a></li>
<li><a href="https://2ality.com/2020/09/ecmascript-2021.html" target="_blank" rel="noopener">https://2ality.com/2020/09/ecmascript-2021.html</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/06/14/ployfill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/06/14/ployfill/" itemprop="url">
                  如何实现个在线的按需的 ployfill
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-14T21:10:04+08:00">
                2021-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>polyfill 在英文中有垫片的意思，意为兜底的东西。在计算机科学中，指的是对未能实现进行的”兜底”操作。简单的说就是它可以让你可以毫无顾虑地使用最新的 JavaScript 特性，而不需要关注浏览器兼容性。<br>我们用最多的 polyfill 方式都是基于 core-js 正常使用方式一般是这两种： 1.通过 cdn 不考虑按需引入整个 core-js 文件非常大，最新的 3.15.2 版本大小 742 kB。 2.用 babel 处理，通过设置 @babel/preset-env 加上 useBuiltins 配置来按需裁剪 core-js。<br>目前主流做法都是选择方案 2 通过 @babel/preset-env 裁剪，事实上，在 CDN 的缓存的作用下收益会比方案 2 剪裁有更好的性能。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>根据 babel 的做原理，如果能可以根据浏览器的兼容性配置动态的生成裁剪后的 core-js，然后只引入 CDN 上剪裁后的 core-js 文件。</p>
<h3 id="如何根据浏览器的兼容性动态剪裁"><a href="#如何根据浏览器的兼容性动态剪裁" class="headerlink" title="如何根据浏览器的兼容性动态剪裁"></a>如何根据浏览器的兼容性动态剪裁</h3><p>很简单，只需要按照 babel 的处理方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"core-js"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"regenerator-runtime/runtime"</span>;</span><br></pre></td></tr></table></figure>
<p>配一个 .browserlisrc 浏览器信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome <span class="number">86</span></span><br></pre></td></tr></table></figure>
<p>利用 rollup 打包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">"@rollup/plugin-babel"</span>;</span><br><span class="line"><span class="keyword">import</span> nodeResolve <span class="keyword">from</span> <span class="string">"@rollup/plugin-node-resolve"</span>;</span><br><span class="line"><span class="comment">// CommonJS格式</span></span><br><span class="line"><span class="keyword">import</span> commonJS <span class="keyword">from</span> <span class="string">"@rollup/plugin-commonjs"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; terser &#125; <span class="keyword">from</span> <span class="string">"rollup-plugin-terser"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  input: <span class="string">"index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    file: <span class="string">"dist.js"</span>,</span><br><span class="line">    format: <span class="string">"iife"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    babel(&#123; <span class="attr">babelHelpers</span>: <span class="string">"bundled"</span> &#125;),</span><br><span class="line">    nodeResolve(),</span><br><span class="line">    commonJS(),</span><br><span class="line">    terser(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经过 rollup 打包后就会生成一个根据浏览器裁剪后的 ployfill 文件了。</p>
<h3 id="如何云化"><a href="#如何云化" class="headerlink" title="如何云化"></a>如何云化</h3><p>上面我们通过 babel 工具去生成 polyfill，然后上传到 CDN 并修改引用地址，当需要不同浏览器兼容性的时又要重复上面的操作，成本很高，所以我们希望运用云函数的能力来实现在线生成，生成的逻辑在线化，目前云服务上都提供 Serverless 计算服务像阿里云 <a href="https://www.aliyun.com/product/fc" target="_blank" rel="noopener">函数计算 FC</a> 。</p>
<h4 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h4><p>只需要将 rollup 调用方式改成 api，通过 url 传参方式传递浏览器信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; encode &#125; = <span class="built_in">require</span>(<span class="string">"js-base64"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; rollup &#125; = <span class="built_in">require</span>(<span class="string">"rollup"</span>);</span><br><span class="line"><span class="keyword">const</span> rollupConfig = <span class="built_in">require</span>(<span class="string">"./factory/rollupConfig"</span>);</span><br><span class="line"><span class="keyword">const</span> terser = <span class="built_in">require</span>(<span class="string">"terser"</span>);</span><br><span class="line"><span class="keyword">const</span> respond = <span class="function">(<span class="params">body, statusCode = <span class="number">200</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    statusCode,</span><br><span class="line">    body,</span><br><span class="line">    isBase64Encoded: <span class="literal">false</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">"Content-Type"</span>:</span><br><span class="line">        statusCode === <span class="number">200</span></span><br><span class="line">          ? <span class="string">"application/javascript; charset=utf-8"</span></span><br><span class="line">          : <span class="string">"text/plain; charset=utf-8"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">exports.handler = <span class="keyword">async</span> (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; targets &#125; = event.queryStringParameters;</span><br><span class="line">  <span class="keyword">if</span> (!targets) &#123;</span><br><span class="line">    <span class="keyword">return</span> respond(<span class="string">"No targets specified"</span>, <span class="number">400</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> key = encode(targets, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> bundle = <span class="keyword">await</span> rollup(rollupConfig(targets));</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      output: [asset],</span><br><span class="line">    &#125; = <span class="keyword">await</span> bundle.generate(&#123; <span class="attr">file</span>: <span class="string">"dist.js"</span>, <span class="attr">format</span>: <span class="string">"iife"</span> &#125;);</span><br><span class="line">    <span class="keyword">const</span> minified = <span class="keyword">await</span> terser.minify(asset.code);</span><br><span class="line">    <span class="keyword">return</span> respond(minified.code);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(ex);</span><br><span class="line">    <span class="keyword">return</span> respond(ex.message, <span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样在线生成搞定了，但是每次生成时间巨长，真实启动的服务并不可用，所以我们需要在生成的前面加一个 CDN 配置，需要在上线前预热 CDN 就能达到秒开。当然业界也有成熟的在线服务例如 <a href="https://polyfill.io/v3/" target="_blank" rel="noopener">https://polyfill.io/v3/</a></p>
<h2 id="现实"><a href="#现实" class="headerlink" title="现实"></a>现实</h2><p>这样就完成了加载按需剪裁 CDN 资源的 ployfill，减少了资源大小，同时增加了缓存命中。<br>但是 <a href="https://developers.google.com/web/updates/2020/10/http-cache-partitioning" target="_blank" rel="noopener">chrome 85</a> 版本之后更新了缓存策略，新的策略生效后会大大降低缓存命中,新的策略：</p>
<ul>
<li>之前，单资源的缓存是以 URL 来作为键，并不关心请求 URL 的来源；</li>
<li>目前，缓存的键由 URL、顶部 window 域名、当前 window 域名三元组构成；<br>其他浏览器支持情况：</li>
<li>Safari 实现了顶部 window 域名 + URL 的键控制机制；</li>
<li>Firefox 即将实现同粒度的缓存键；<br>更新缓存机制后，缓存未命中的情形增加了 3.6%，整体网络加载字节数增加了 4%。</li>
</ul>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>虽然由于浏览器的缓存策略更新从而导致跨站缓存无法共享，但是本站的收益还是很大的。另外也可以采用更加细致的方案，把每一个 core-js 的所有 api 都在线化编译成独立的 ES 模块，然后项目采用 ES 模块的方式打包，让浏览器去加载最小粒度的 polyfill，精细度更大。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/03/26/IntersectionObserver实现高性能的交互动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/03/26/IntersectionObserver实现高性能的交互动画/" itemprop="url">
                  IntersectionObserver实现高性能的交互动画
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-26T21:07:55+08:00">
                2021-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>背景：以前我们在写滚动动画的时候通常判断元素是否显示通常会通过 getBoundingClientRect 获取位置，但是 getBoundingClientRect 将触发重排，利用此技术可能会很快造成性能瓶颈。</p>
</blockquote>
<h2 id="关于-IntersectionObserver"><a href="#关于-IntersectionObserver" class="headerlink" title="关于 IntersectionObserver"></a>关于 IntersectionObserver</h2><p>IntersectionObserver 是 web 领域众多观察器中的一个，是用来是观察元素和窗体相交的状态，很适合用在滚动交互事件，像是懒加载、埋点等场景。</p>
<blockquote>
<p>除了 IntersectionObserver ，我们常用的还有用来观察 DOM 变化的 MutationObserver；用来观察元素的尺寸变化 ResizeObserver。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>创建一个 intersection observer</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [entry] = entries;</span><br><span class="line">  <span class="keyword">if</span> (entry.isIntersecting) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"元素曝光了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  root: <span class="built_in">document</span>.querySelector(<span class="string">"#scrollArea"</span>), <span class="comment">// 指定根(root)元素，必须是目标元素的父级元素，如果未指定或者为null，则默认为浏览器视窗。</span></span><br><span class="line">  rootMargin: <span class="string">"0px"</span>, <span class="comment">// 根(root)元素的外边距</span></span><br><span class="line">  threshold: <span class="number">1.0</span>, <span class="comment">// 阈值为1.0意味着目标元素完全出现在root选项指定的元素中可见时，回调函数将会被执行。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(callback, options);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ele = <span class="built_in">document</span>.querySelector(<span class="string">".animatedElement"</span>);</span><br><span class="line"></span><br><span class="line">observer.observe(ele);</span><br></pre></td></tr></table></figure>
<p>callback 回调函数将会在主线程中被执行, 其中 entry 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entry.boundingClientRect 目标元素的区域信息</span><br><span class="line">entry.intersectionRatio 目标元素的可见比率</span><br><span class="line">entry.intersectionRect 目标元素与根元素交叉的区域信息</span><br><span class="line">entry.isIntersecting 是否进入可视区域</span><br><span class="line">entry.rootBounds 根元素的矩形区域信息</span><br><span class="line">entry.target 被观察的目标，是一个DOM节点</span><br><span class="line">entry.time 可见性发生变化的时间,相交发生时距离页面打开时的毫秒数.精度为微秒。</span><br></pre></td></tr></table></figure>
<p>Intersection Observer 可用的方法有 observe()，unobserve() 和 disconnect()。</p>
<ul>
<li>observe()：用来添加观察者要监视的目标元素，观察者可以具有多个目标元素，但是此方法一次只能接受一个目标。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const element = document.querySelector(&apos;.animatedElement&apos;);</span><br><span class="line">observer.observe(element);</span><br></pre></td></tr></table></figure>
<ul>
<li>unobserve()：用来从观察的元素列表中移除元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.unobserve(element);</span><br></pre></td></tr></table></figure>
<ul>
<li>disconnect()：用来停止观察其所有目标元素。观察者本身仍处于活动状态，但没有目标。在 disconnect() 之后，目标元素仍然可以通过 observe() 传递给观察者。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure>
<h2 id="利用-getBoundingClientRect-实现动画"><a href="#利用-getBoundingClientRect-实现动画" class="headerlink" title="利用 getBoundingClientRect 实现动画"></a>利用 getBoundingClientRect 实现动画</h2><p>通常是监听滚动，通过获取元素位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, () =&gt; checkForVisibility);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, () =&gt; checkForVisibility);</span><br></pre></td></tr></table></figure>
<p>根据元素的位置触发动画</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkForVisibility</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = <span class="built_in">document</span>.querySelector(<span class="string">".animatedElement"</span>);</span><br><span class="line">  <span class="keyword">const</span> distTop = element.getBoundingClientRect().top;</span><br><span class="line">  <span class="keyword">const</span> distBottom = element.getBoundingClientRect().bottom;</span><br><span class="line">  <span class="keyword">const</span> distPercentTop = <span class="built_in">Math</span>.round((distTop / <span class="built_in">window</span>.innerHeight) * <span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> distPercentBottom = <span class="built_in">Math</span>.round((distBottom / <span class="built_in">window</span>.innerHeight) * <span class="number">100</span>);</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 getBoundingClientRect 将触发重排也就会造成性能问题，那 getBoundingClientRect() 为什么会触发 Reflow 呢？<br>在 chromium 的源码中搜索 getBoundingClientRect 可以看到代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOMRect* Range::getBoundingClientRect() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> DOMRect::FromFloatRect(BoundingRect());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BoundingRect() 中调用了 UpdateStyleAndLayout</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FloatRect Range::BoundingRect() <span class="keyword">const</span> &#123;</span><br><span class="line">owner_document_-&gt;UpdateStyleAndLayout(DocumentUpdateReason::kJavaScript);</span><br><span class="line"></span><br><span class="line">Vector&lt;FloatQuad&gt; quads;</span><br><span class="line">GetBorderAndTextQuads(quads);</span><br><span class="line"></span><br><span class="line">FloatRect result;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> FloatQuad&amp; quad : quads)</span><br><span class="line">result.Unite(quad.BoundingBox()); <span class="comment">// Skips empty rects.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If all rects are empty, return the first rect.</span></span><br><span class="line"><span class="keyword">if</span> (result.IsEmpty() &amp;&amp; !quads.IsEmpty())</span><br><span class="line"><span class="keyword">return</span> quads.front().BoundingBox();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 UpdateStyleAndLayout 方法调用之后将会触发 LayoutTree 的重新渲染，也就是 Reflow。</p>
<h2 id="利用-IntersectionObserver-实现动画"><a href="#利用-IntersectionObserver-实现动画" class="headerlink" title="利用 IntersectionObserver 实现动画"></a>利用 IntersectionObserver 实现动画</h2><p>通过 Intersection Observer API 获取到两个元素重叠部分的准确值，只需几行代码即可设置根据元素可见性触发动画：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animationObserver = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> entries) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    entry.target.classList.toggle(<span class="string">"animating"</span>, entry.isIntersecting);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> querySelectorAll(<span class="string">".animatedElement"</span>)) &#123;</span><br><span class="line">  animationObserver.observe(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IntersectionObserver-polyfill"><a href="#IntersectionObserver-polyfill" class="headerlink" title="IntersectionObserver-polyfill"></a>IntersectionObserver-polyfill</h2><p>对于不支持的浏览器可以引入 w3c 官方创建的 polyfill <a href="https://github.com/w3c/IntersectionObserver。">https://github.com/w3c/IntersectionObserver。</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>• <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API</a><br>• <a href="https://www.zhangxinxu.com/wordpress/2020/12/js-intersectionobserver-nav/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2020/12/js-intersectionobserver-nav/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/02/07/代码质量-代码重复/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/02/07/代码质量-代码重复/" itemprop="url">
                  代码质量-代码重复
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-07T19:37:34+08:00">
                2021-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>背景:重复率是 oasis（衡量前端工程质量平台）的检测指标之一，对项目定期进行代码重复率检测是一个很有意义的事，可以帮助开发人员发现冗余代码，进行代码抽象和重构。</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>代码重复（英文：duplicate code，也叫代码克隆）在程序设计中表示一段源代码在一个程序，或者一个团体所维护的不同程序中重复出现，是不希望出现的现象。为避免巧合，只有一定数量的代码完全相同才能判定为代码重复。 – 维基百科</p>
</blockquote>
<p>代码重复一般分为两大类：</p>
<ul>
<li>句法重复<br>两个函数的代码片段基本一致，只是参数名、函数名、字符等做了修改，或是多/少了某一行多代码，这种改动只是文本层面的改动，也被称为。</li>
<li>语义重复<br>两个函数的代码实现不同，从文本层面看区别较大，但实现的都是同一个功能。</li>
</ul>
<p>基于句法重复、语义重复两大类，然后被划分为四小类：</p>
<ul>
<li>完全一致的代码或者只修改了空格和评论（句法克隆）。</li>
<li>结构上和句法上一致的代码，例如只是修改了变量名 （句法克隆）。</li>
<li>插入和删除了部分代码（句法克隆）。</li>
<li>功能和逻辑上一致的代码，语义上的拷贝（语义克隆）。<br>其中前三种为句法克隆，第四种为语义克隆。检测难度也是一次递增，目前对前三种代码重复的检测已颇为成熟； 而对第四种的检测准确率仍不高，无法达到应用标准。<br>重复代码未必就是 copy-paste 产生的，可能就是不同人重复写的，就算是 copy-paste 产生的，在 paste 之后可能代码也会发生变化。</li>
</ul>
<h2 id="前端重复检测"><a href="#前端重复检测" class="headerlink" title="前端重复检测"></a>前端重复检测</h2><h3 id="检测代码重复的手段"><a href="#检测代码重复的手段" class="headerlink" title="检测代码重复的手段"></a>检测代码重复的手段</h3><ul>
<li>Textual：代码片段以文本/字符串/词法的形式相互比较，并且只有在两个代码片段在文本内容方面确实相同时才被发现被克隆。</li>
<li>Token：在编译器的词法分析阶段，所有源代码行都被划分为一系列 Token。 然后将所有 Token 转换回 Token 序列。</li>
<li>Syntactic（句法分析）：<ul>
<li>基于树: 提取的 AST 用于子树比较以识别相似区域。</li>
<li>基于度量：通过源代码收集度量，然后使用这些度量为每个代码片段生成向量。然后使用向量对代码的相似度进行对比。</li>
</ul>
</li>
<li>Semantic（语义克隆）：主要检测代码片段不同，但功能相同的函数。</li>
<li>Learning : 通过机器学习和统计分析的方式来进行克隆检测。</li>
</ul>
<h3 id="检测代码重复的流程"><a href="#检测代码重复的流程" class="headerlink" title="检测代码重复的流程"></a>检测代码重复的流程</h3><ol>
<li>将源码拆分为对比单元（comparison units, 如 class，function，block，statement）。</li>
<li>将对比单元转化为中间表达（IR, Intermediate Representation，如 token，AST, PDG）。</li>
<li>再对这些对比单元的 IR 进行 match detection（对比），通常是将对比单元组成 clone pair 的形式：一次对比两个（c1, c2）或是多个（c1, c2, c3）。</li>
</ol>
<h3 id="检测工具"><a href="#检测工具" class="headerlink" title="检测工具"></a>检测工具</h3><ul>
<li>jsinspect<br>利用 babylon 对于 JavaScript 或者 JSX 代码构建 AST 语法树，根据不同的 AST 节点类型，标记相似结构的代码块，检测效果比较好。</li>
<li>jscpd：其重复率判定依据为一定长度标识符的 MD5 值是否相同，虽然结果没有 jsinspect 好，但是支持文件格式广泛，如 java、oc、js、jsx、vue、ts、less 等。</li>
<li>PMD：支持 js 文件检测，也可以自己开发扩展包来解析指定的语言（需要安装 java 环境，npm 不支持，无法匹配前端脚手架）。</li>
</ul>
<p>由于前端文件类型众多所以 oasis 最终选择了 jscpd 作为代码重复率检测工具。</p>
<h3 id="重复率标准"><a href="#重复率标准" class="headerlink" title="重复率标准"></a>重复率标准</h3><p>重复率标准的制定需要参考的因素有很多，例如 tokens、项目、架构、时间等等,目前 oasis 平台是 10%，具体数值还会在运行一段时间后观察调整。<br>代码重复率 = 重复的行数 / 扫描的文件总行数。</p>
<h3 id="降低重复率"><a href="#降低重复率" class="headerlink" title="降低重复率"></a>降低重复率</h3><p>应用中，可以参考《重构》（Refactoring）中说的三次原则（Rule of three），即同样的代码将要出现第三次前，考虑抽象它，复用它。具备小而美的工程思想，随着前端生态的完善，前端的组件化开发效率已经有了很大的提升。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码重复会让项目失控，重复代码不仅让代码量大增，造成编译速度慢，占用大量存储空间，造成了代码可维护性差，代码质量下降。通过重构从而降低代码的耦合性，这样不仅提高代码的灵活性、健壮性以及可读性，也方便后期的维护。我们也不是单纯地追求公共代码地完全剥离化，过度的抽象反而会降低代码的可读性与可理解性。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>oasisV0.1 beta 版本目前已经完成大文件、重复代码块，圈复杂度、最佳实践、基础库落地、 npm 依赖库的安全分析功能，接入 0 成本目前已经上线欢迎大家体验、建议、吐槽。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/01/03/代码质量-圈复杂度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/03/代码质量-圈复杂度/" itemprop="url">
                  代码质量-圈复杂度
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-03T21:27:05+08:00">
                2021-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>圈复杂度是 oasis（衡量前端工程质量平台）的检测指标之一，目的是为了检测出逻辑复杂，可能质量低，且难于测试和维护的模块，提高 CR 效率和推动优化提升前端工程质量。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>圈复杂度（Cyclomatic complexity，CC）也称为条件复杂度，其符号为 V(G),是衡量计算机程序复杂程度的一种措施。它根据程序从开始到结束的线性独立路径的数量计算得来的,其数量上为独立路径的条数，也可理解为覆盖所有的可能情况最少使用的测试用例个数。</p>
<h2 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h2><p>圈复杂度大说明程序代码的判断逻辑复杂，可能质量低，且难于测试和维护。 代码复杂度低，代码不一定好，但代码复杂度高，代码一定不好。</p>
<table>
<thead>
<tr>
<th>圈复杂度</th>
<th>代码状况</th>
<th>可测性</th>
<th>维护成本</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 - 10</td>
<td>清晰</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>10 - 20</td>
<td>复杂</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>20 - 30</td>
<td>非常复杂</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>&gt; 30</td>
<td>不可读</td>
<td>不可测</td>
<td>非常高</td>
</tr>
</tbody>
</table>
<p>同时测试驱动的开发和圈复杂度存在紧密的关系。一个好的测试用例是创建数量与被测代码圈复杂度值相等的测试用例，以此提升测试用例对代码的分支覆盖率。</p>
<h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p>圈复杂度有两种计算方法：点边计算法和节点判定法。</p>
<h3 id="节点判定法"><a href="#节点判定法" class="headerlink" title="节点判定法"></a>节点判定法</h3><p>因为圈复杂度所反映的是“判定条件”的数量，所以圈复杂度实际上就是等于判定节点的数量再加上 1。从 1 开始，一直往下通过程序,一但遇到 P 关键字，或者其它同类的词，就加 1。</p>
<blockquote>
<p>V (G) = P + 1</p>
</blockquote>
<p>其中 P 为判定节点数，常见的判定节点有：</p>
<p>if 语句、while 语句、for 语句、case 语句、catch 语句、and 和 or 布尔操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function test(a) &#123;</span><br><span class="line">    let b = 1;</span><br><span class="line">    if (a &lt; 0 || a &gt; 100) &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (a &lt; 30 ) &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 31:</span><br><span class="line">            b++ ;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return b === 1 ? 0 : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 个 if ，1 个 or ，1 个 for ，1 个 while，1 个 case，1 个三元 所以代码复杂度 7</p>
<h3 id="点边计算法"><a href="#点边计算法" class="headerlink" title="点边计算法"></a>点边计算法</h3><p>圈复杂度由程序的控制流图来计算：节点对应程序中个别的代码，而若一个程序运行后会立刻运行另一代码，则会有边连接另一代码对应的节点。</p>
<blockquote>
<p>V(G) = E - N + 2</p>
</blockquote>
<p>E 表示控制流图中边的数量，N 表示控制流图中节点的数量。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glhni7agy2j30wm0p4753.jpg" alt=""></p>
<p>如上图正常顺序的圈复杂度为 1；if else 的圈复杂度为 2；while 的圈复杂度也为 2。</p>
<h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><h3 id="es6-plato"><a href="#es6-plato" class="headerlink" title="es6-plato"></a>es6-plato</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev es6-plato</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot; : &#123;</span><br><span class="line">    &quot;complexity-report&quot;: &quot;./node_modules/.bin/es6-plato -r -d ./report src&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run complexity-report</span><br></pre></td></tr></table></figure>
<h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>oasis 用的是 eslint 提供了检测代码圈复杂度的 rules ，根据 eslint 的 api 会自动检测出所有函数的代码复杂度输出检测信息，通过解析检测信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CLIEngine(&#123;</span><br><span class="line">  baseConfig: &#123;</span><br><span class="line">    root: <span class="literal">true</span>,</span><br><span class="line">    parser: <span class="string">"vue-eslint-parser"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: <span class="number">9</span>,</span><br><span class="line">    sourceType: <span class="string">"module"</span>,</span><br><span class="line">    ecmaFeatures: &#123;</span><br><span class="line">      experimentalObjectRestSpread: <span class="literal">true</span>,</span><br><span class="line">      jsx: <span class="literal">true</span>,</span><br><span class="line">      globalReturn: <span class="literal">true</span>,</span><br><span class="line">      impliedStrict: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    parser: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  useEslintrc: <span class="literal">false</span>,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    complexity: [<span class="string">"error"</span>, &#123; <span class="attr">max</span>: <span class="number">0</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="降低圈复杂度"><a href="#降低圈复杂度" class="headerlink" title="降低圈复杂度"></a>降低圈复杂度</h2><p>降低复杂度有的是把函数的一部分提取成另一个子函数，不会降低整个项目的复杂度，只是把决策点移到其他地方，但是这样做可以降低你在同一时间必须关注的复杂度。</p>
<h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><blockquote>
<p>函数应该做一件事，做好这件事，只做这一件事。 — 代码整洁之道</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a === <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b === <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> calcA(a) + calcB(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcA</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// dosomething</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a === <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// dosomething</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcB</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// dosomething</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b === <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// dosomething</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (f(a, b, c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g(a, b, c)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (h(a, b, c)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j(a, b, c)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k(a, b, c)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rules = &#123;</span><br><span class="line">  x: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">  y: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">  z: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> action = determineAction(a, b, c)</span><br><span class="line">  <span class="keyword">return</span> rules[action](a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="职责链"><a href="#职责链" class="headerlink" title="职责链"></a>职责链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (f(a, b, c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g(a, b, c)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (h(a, b, c)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j(a, b, c)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k(a, b, c)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rules = [</span><br><span class="line">  &#123;</span><br><span class="line">    match: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">    action: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    match: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">    action: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    match: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">    action: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rules.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rules[i].match(a, b, c)) &#123;</span><br><span class="line">      <span class="keyword">return</span> rules[i].action(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>圈复杂度低，代码不一定好，但圈复杂度很高，代码一定不好，所以圈复杂度才作为一个 oasis 的指标之一。圈复杂度还需要具体情况具体分析，其只作为重构的一个度量指标，作为决策的一个参考依据。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>oasisV0.1 beta 版本目前已经完成大文件、重复代码块，圈复杂度、最佳实践、基础库落地、 npm 依赖库的安全分析功能，接入 0 成本目前已经上线欢迎大家体验、建议、吐槽。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lennonover" />
          <p class="site-author-name" itemprop="name">lennonover</p>
           
              <p class="site-description motion-element" itemprop="description">一丿口石砳磊</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">69</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lennonover</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
