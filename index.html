<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一丿口石砳磊">
<meta property="og:type" content="website">
<meta property="og:title" content="lennonover">
<meta property="og:url" content="https://github.com/lennonover/index.html">
<meta property="og:site_name" content="lennonover">
<meta property="og:description" content="一丿口石砳磊">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lennonover">
<meta name="twitter:description" content="一丿口石砳磊">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/lennonover/"/>





  <title> lennonover </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lennonover</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/11/07/物料市场组件monorepo架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/11/07/物料市场组件monorepo架构/" itemprop="url">
                  物料市场-组件 monorepo 架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-07T15:35:30+08:00">
                2021-11-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近平台启动了物料市场技术项目，目的是通过提供丰富可复用物料、一体化物料解决方案、全链路研发来实现对研发体验和研发效率的提升。在设计公共组件架构时平台采用了多包架构（Monorepo），一套灵活的组件研发体系，并且天然支持按需使用。</p>
<h2 id="什么是-Monorepo"><a href="#什么是-Monorepo" class="headerlink" title="什么是 Monorepo"></a>什么是 Monorepo</h2><p>monorepo 是一种将多个项目代码存储在一个仓库里的软件开发策略，这种方式在一个项目仓库（repo）中管理多个模块/包（package）。很多出名开源的项目都是采纳的 monorepo 的组织形式，比如 Babel，React ,Jest, create-react-app, react-router 、 npm@7 也带来一流的 monorepo 支持等等。</p>
<h2 id="monorepo-的优劣"><a href="#monorepo-的优劣" class="headerlink" title="monorepo 的优劣"></a>monorepo 的优劣</h2><h3 id="monorepo-的优势"><a href="#monorepo-的优势" class="headerlink" title="monorepo 的优势"></a>monorepo 的优势</h3><ul>
<li>代码重用将变得非常容易</li>
<li>依赖管理将变得非常简单</li>
<li>代码重构将变得非常便捷</li>
</ul>
<h3 id="monorepo-的劣势"><a href="#monorepo-的劣势" class="headerlink" title="monorepo 的劣势"></a>monorepo 的劣势</h3><ul>
<li>项目粒度的权限管理变得非常复杂（既是优点也是缺点）</li>
<li>学习成本变高</li>
<li>库体积超大，目录结构复杂度上升<br>基于两者的优缺点，结合我们当前组件库的特点：<br>● 每个包之间是有相关依赖的。<br>● 统一的构建工具，统一发版。<br>● 对版本的说明要求较高<br>所以我们推荐采用 Monorepo 对组件库进行管理，目前最常见的 Monorepo 解决方案是 Lerna 和 Yarn 的 workspaces 特性。我们采用 Yarn 官方推荐的做法，用 Yarn 来处理依赖问题，用 Lerna 来处理发布问题。</li>
</ul>
<h2 id="lerna"><a href="#lerna" class="headerlink" title="lerna"></a>lerna</h2><blockquote>
<p>A tool for managing JavaScript projects with multiple packages. Lerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm.<br>基于上文我们可以知道 lerna 是最出名的 monorepo 的管理工具，也是当前项目采用的方案<br>通过 lerna 创建的项目结构</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- packages(目录)</span><br><span class="line">- lerna.json(配置文件)</span><br><span class="line">- package.json(工程描述文件)</span><br></pre></td></tr></table></figure>
<p>lerna.json 文件，默认内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;packages&quot;: [&quot;packages/*&quot;],</span><br><span class="line">&quot;version&quot;: &quot;0.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们根据需求修改之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;packages&quot;: [&quot;packages/*&quot;],</span><br><span class="line">&quot;npmClient&quot;: &quot;yarn&quot;,</span><br><span class="line">&quot;version&quot;: &quot;independent&quot;,</span><br><span class="line">&quot;useWorkspaces&quot;: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>npmClient<br>我们显示声明了我们的包客户端为 yarn。</li>
<li>useWorkspaces<br>让 Lerna 追踪我们 workspaces 设置的目录。</li>
<li>version<br>independent 将每个子项目的版本号看作是相互独立的。</li>
</ul>
<h3 id="Verdaccio"><a href="#Verdaccio" class="headerlink" title="Verdaccio"></a>Verdaccio</h3><p>一个 npm 包本地发布工具，使用 Verdaccio 可以在本地创建一个 npm 仓库作为代理用来测试 lerna。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global verdaccio</span><br></pre></td></tr></table></figure>
<p>在您的项目根目录创建 .npmrc 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry=&quot;http://localhost:4873/&quot;</span><br></pre></td></tr></table></figure>
<p>每当您执行 lerna publish 时，子项目所构建成的 package 将会发布在本地 npm 仓库中，而当您执行 lerna bootstrap 时，Verdaccio 将会放行，让您成功从远程 npm 仓库中拉取相应的代码。</p>
<h3 id="lerna-常用命令"><a href="#lerna-常用命令" class="headerlink" title="lerna 常用命令"></a>lerna 常用命令</h3><ul>
<li>lerna init<br>初始化 lerna 项目</li>
<li>lerna create <name><br>创建一个新的由 lerna 管理的包。</name></li>
<li>lerna add axios<br>增加模块包到最外层的公共 node_modules 中</li>
<li>lerna add A –scope=B<br>增加模块包到 packages 中指定项目，例如将 A 模块增加到 B 项目中</li>
<li>lerna list<br>显示所有的安装的包</li>
<li>lerna clean<br>从所有包中删除 node_modules 目录</li>
<li>lerna publish<br>在当前项目中发布包 publish 不会发布 package.json 中 private 为 true 的包</li>
<li>lerna bootstrap<br>lerna 提供了可以将子项目的依赖包提升到最顶层的方式 ，我们可以执行 lerna clean 先删除每个子项目的 node_modules , 然后执行命令 lerna bootstrop –hoist。<br>基于上面的命令我们的脚手架 duwork 也同步实现</li>
</ul>
<h3 id="物料按照-Monorepo-的方式组织代码结构"><a href="#物料按照-Monorepo-的方式组织代码结构" class="headerlink" title="物料按照 Monorepo 的方式组织代码结构"></a>物料按照 Monorepo 的方式组织代码结构</h3><p>包的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- packages</span><br><span class="line">- buttonA 组件 A</span><br><span class="line">- __test__ //存放测试相关代码</span><br><span class="line">- dist // 打包的目录</span><br><span class="line">- doc // 组件的文档</span><br><span class="line">- src // 存放源码</span><br><span class="line">- index.js // 打包的入口文件</span><br><span class="line">- LICENSE // 版权信息（MIT）</span><br><span class="line">- package.json // 组件的描述信息</span><br><span class="line">- buttonB 组件 B</span><br></pre></td></tr></table></figure>
<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建</span><br><span class="line">duwork create -c</span><br><span class="line">打包</span><br><span class="line">duwork build</span><br><span class="line">发布</span><br><span class="line">duwork publish</span><br></pre></td></tr></table></figure>
<p>正常的开发流程是每个人新建一个 git branch，通过代码审核之后进行合并。从上面可以看到整套流程在 monorepo 架构下变得非常清晰。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文我们介绍了 monorepo，以及最佳实践，monorepo 给我们带来的收益是非常可观的，可能您的场景并不试用 monorepo，所以说脱离实际情况谈最优解都是不切实际的想法，一个模式的提出必定面对解决一个问题，但是即使您的场景并不试用 monorepo，还是希望工具和思想也可以运用到工作之中。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://github.com/lerna/lerna/tree/main/utils/create-symlink">https://github.com/lerna/lerna/tree/main/utils/create-symlink</a></li>
<li><a href="https://jishuin.proginn.com/p/763bfbd5505d" target="_blank" rel="noopener">https://jishuin.proginn.com/p/763bfbd5505d</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/10/04/我们是如何保证前端项目质量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/10/04/我们是如何保证前端项目质量/" itemprop="url">
                  我们是如何保证前端项目质量
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-04T17:12:58+08:00">
                2021-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本篇文章主要介绍一下我们团队开发过程中，如何做代码质量的把控和提升。</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>代码质量是一个项目最重要部分，更好的质量的代码，能够产生更少的 bug，从而让项目的质量得到提升。业务快速增长，随之而来的前端需求激增，同时经过我们的分析，发现当前我们开发流程存在的一些问题：</p>
<ul>
<li>如何高效团队 CR？</li>
<li>开发人员怎么衡量项目的质量？</li>
<li>每个公司都有一个安全团队，他们负责公司一些代码安全，但是如果他万一发生一些问题的时候，通知到我们团队的时候，我们如何响应他们？</li>
<li>团队沉淀、基建落地如何量化提供一个参考依据</li>
<li>重构后的代码，除了一些我们通过一些生产或者性能对比，如何从代码层面来展示我们的量化结果。<br>面对上面的问题，就需要我们通过一些技术手段来实现，通过代码的扫描来找到潜在的问题。我们构建出衡量项目质量的模型，通过模型对项目分析输出评估结果反馈对进行质量趋势分析来推动优化。</li>
</ul>
<h2 id="如何定义质量模型？"><a href="#如何定义质量模型？" class="headerlink" title="如何定义质量模型？"></a>如何定义质量模型？</h2><p>衡量质量基础是要可量化，结合我们目前项目常用的标准主要从、技术选型、开发规范、可维护性和安全四个方面：</p>
<ul>
<li>技术选型<br>主要关注框架的技术选型是否先进、主流、收敛，例如：框架、请求库、UI 库。</li>
<li>编码规范<br>主要包含是否遵守了最佳实践和团队编码规范（readme<br>、npm script、git 工作流、Mock、Eslint、团队最佳实践<br>）。</li>
<li>可维护性<br>代码分层、模块化、圈复杂度、重复率、大文件、文档等得出可读性及复杂度评分。</li>
<li>安全<br>基于团队开发规范，检测可能存在的安全风险（外链、敏感成词、token、npm 包等）。</li>
</ul>
<h2 id="如何检测？"><a href="#如何检测？" class="headerlink" title="如何检测？"></a>如何检测？</h2><p>通过代码静态分析的方式检测代码质量，平台整体架构分成四部分：</p>
<ul>
<li>代码分析计算服务：用于仓库代码元数据采集和规则检测，质量计算</li>
<li>数据平台后端服务：用于存储采集的数据，为前端展示提供数据</li>
<li>数据平台前端服务：用于对采集的数据可视化分析展示</li>
<li>数据平台 web 可视化界面<br>系统工作流程主要分为两种：</li>
<li>自动脚本服务定时拉取分析仓库代码，通过代码静态分析匹配规则生成检测结果计算出质量分，通过邮件、飞书等形式发送本次扫描报告，开发人员可以通过报告查看负责的项目详情做进一步处理。</li>
<li>开发人员主动触发，通过指定项目分支主动触发分析脚本，根据检测结果分析。<br>同时为了能够实现编码事前修改，我们将部分检测规则的 lint 继承的本地开发环境来保证做到事前检测提升效率。</li>
</ul>
<h2 id="质量分计算"><a href="#质量分计算" class="headerlink" title="质量分计算"></a>质量分计算</h2><p>根据质量模型把各项指标加权求和，可以得到一个工程的度总分，代表它的综合评估结果，同时对质量分的历史趋势做出预判。</p>
<h2 id="实践效果"><a href="#实践效果" class="headerlink" title="实践效果"></a>实践效果</h2><h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><p>未来我们会进一步的在检测维度上继续增加，同时持续优化可视化界面的用户体验，最终目标是打造一个完善的项目质量保障平台，能够为团队项目质量带来更大的提升。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/09/22/cookies/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/09/22/cookies/" itemprop="url">
                  cookies
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-22T19:12:58+08:00">
                2021-09-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前置解释"><a href="#前置解释" class="headerlink" title="前置解释"></a>前置解释</h2><ul>
<li>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互，要求协议，端口和主机都相同。</li>
<li>HTTP 是一个无状态的协议，所谓无状态协议，简单的理解就是即使同一个客户端连续两次发送请求给服务器，服务器也识别不出这是同一个客户端发送的请求</li>
<li>Cookie 是客户端保存用户信息的一种机制，保存在客户机硬盘上。可以由服务器响应报文 Set-Cookie 的首部字段信息或者客户端 document.cookie 来设置，并随着每次请求发送到服务器。子域名可以获取父级域名 Cookie。</li>
</ul>
<h2 id="SameSite-来源"><a href="#SameSite-来源" class="headerlink" title="SameSite 来源"></a>SameSite 来源</h2><p>熟悉 web 安全攻击 CSRF 的都知道 CSRF 的本质实际上是利用了 Cookie 会自动在请求中携带的特性，诱使用户在第三方站点发起请求的行为。针对这个问题浏览器厂商对此给 cookie 加了 SameSite 属性。 Chrome 于 2015 年 6 月支持了该属性，Firefox 和 Safari 紧随其后也增加了支持。</p>
<h3 id="同域和同站"><a href="#同域和同站" class="headerlink" title="同域和同站"></a>同域和同站</h3><ul>
<li>同域是指两个 URL 的协议/主机名/端口一致，判断比较严格。</li>
<li>同站判断就比较宽松，根据 Mozilla 维护的公共后缀表（Pulic Suffix List[2]）使用有效顶级域名(eTLD)+1 的规则查找得到的一级域名是否相同来判断是否是同站请求。<br>例如：<br>.org 是在 PSL 中记录的有效顶级域名，imnerd.org 则是一级域名。所以 <a href="https://blog.imnerd.org" target="_blank" rel="noopener">https://blog.imnerd.org</a> 和 <a href="https://www.imnerd.org" target="_blank" rel="noopener">https://www.imnerd.org</a> 是同站域名。<br>.github.io 也是在 PSL 中记录的有效顶级域名，所以 <a href="https://lizheming.github.io" target="_blank" rel="noopener">https://lizheming.github.io</a> 和 <a href="https://blog.github.io" target="_blank" rel="noopener">https://blog.github.io</a> 得到的一级域名是不一样的，他们两个是跨域请求。</li>
</ul>
<h2 id="SameSite-值"><a href="#SameSite-值" class="headerlink" title="SameSite 值"></a>SameSite 值</h2><p>SameSite 属性有以下几个值：</p>
<ul>
<li>SameSite=None：无论是否跨站都会发送 Cookie</li>
<li>SameSite=Lax：允许部分第三方请求携带 Cookie</li>
<li>SameSite=Strict：只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。</li>
</ul>
<h3 id="Strict"><a href="#Strict" class="headerlink" title="Strict"></a>Strict</h3><p>Strict 最为严格只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。浏览器做了仅针对 HTTPS 域名才支持 SameSite=None 配置。所以如果你要设置 SameSite=None 的话，则必须还要携带 Secure 属性才行。<br>例如对于一个普通的站点，如果一个已经登录的用户跟踪一个在电子邮件上的网站链接，这个站点将不会收到 Cookie ，用户访问该站点还需要重新登陆。</p>
<h3 id="Lax"><a href="#Lax" class="headerlink" title="Lax"></a>Lax</h3><p>对于允许用户从外部链接到达本站并使用已有会话的网站站，默认的 Lax 值在安全性和可用性之间提供了合理的平衡。 Lax 属性只会在使用危险 HTTP 方法发送跨域 Cookie 的时候进行阻止，例如 POST 方式。同时，使用 JavaScript 脚本发起的请求也无法携带 Cookie。<br><a href="https://cdn.poizon.com/node-common/93a0229b7baac5aa63b3b4fc06efec7f.png" target="_blank" rel="noopener">lax</a><br>从上图可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送。</p>
<h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>浏览器会在同站请求、跨站请求下继续发送 Cookies，不区分大小写。</p>
<h3 id="策略改变带来的影响"><a href="#策略改变带来的影响" class="headerlink" title="策略改变带来的影响"></a>策略改变带来的影响</h3><p>在 Chrome 80+ 版本中，SameSite 的默认属性是 SameSite=Lax。如果想要指定 Cookies 在同站、跨站请求都被发送，那么需要明确指定 SameSite 为 None。Chrome 也宣布，将在下个版本也就是 Chrome 83 版本，在访客模式下禁用三方 Cookie，在 2023 年全面禁用三方 Cookie。</p>
<ul>
<li>使用的三方埋点数据异常</li>
<li>依赖 cookie 智能广告推荐失败</li>
<li>跨站请求 cookie 丢失、统一登录、支付等失败</li>
</ul>
<h2 id="FLoC"><a href="#FLoC" class="headerlink" title="FLoC"></a>FLoC</h2><p>FLoC 通过获取浏览器的浏览记录将用户加入 “相似” 用户的分组内，每个分组拥有对应的 FLoC ID。有别于之前使用 Cookie ID 标记直接将用户行为数据传递到广告商网站处理的方式。它提出了 document.interestCohort() 这个新的 API，将用户的行为在本地转换成了不带个人隐私的关键词，既规避了用户隐私问题，同时又解决了广告的精准投放问题。<br>谷歌在 Chrome 浏览器的 89 版本上小规模测试了代替 cookie 的 FLoC（Federated Learning of Cohorts, 联邦学习群组）技术。<br>微软、Opera、Firefox、GitHub，EFF 等都对此表达了反对意见。<br>如果不想启用你可以：</p>
<ul>
<li>给站点添加相关的拒绝标头：Permissions-Policy: interest-cohort=() 可以屏蔽</li>
<li>使用表示拒绝的浏览器：Brave、Vivaldi</li>
<li>使用表示暂时不会跟进的浏览器：Mozilla Firefox、Microsoft Edge</li>
</ul>
<h2 id="Cookie-作用域处理"><a href="#Cookie-作用域处理" class="headerlink" title="Cookie 作用域处理"></a>Cookie 作用域处理</h2><ul>
<li>同域名<br>当访问同域名下的页面时，Cookie 会正常携带，后台服务即可直接获取到对应的 SessionID 值，后台为单服务还是多服务无差别。</li>
<li>不同子域名<br>子域名间 Cookie 是不共享的，但各子域名均可获取到父级域名的 Cookie，即 m.dewu.com 与 jiawu.dewu.com 均可以获取 dewu.com 域名下的 Cookie。所以可以通过将 Cookie 设置在父级域名上，可以达到子域名共享的效果。</li>
<li>完全不同域名<br>不同域名是无法直接共享 Cookie ，可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage 中，也可以通过特殊手段将它写入多个其他域下的 LocalStorage 中，让前端在每次向后端发送请求时，主动将 LocalStorage 的数据传递给服务端。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 获取 token</span><br><span class="line">var token = result.data.token;</span><br><span class="line">// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML</span><br><span class="line">var iframe = document.createElement(&quot;iframe&quot;);</span><br><span class="line">iframe.src = &quot;http://app1.com/localstorage.html&quot;;</span><br><span class="line">document.body.append(iframe);</span><br><span class="line">// 使用postMessage()方法将token传递给iframe</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">iframe.contentWindow.postMessage(token, &quot;http://app1.com&quot;);</span><br><span class="line">&#125;, 4000);</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">iframe.remove();</span><br><span class="line">&#125;, 6000);</span><br><span class="line">// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage</span><br><span class="line">window.addEventListener(&apos;message&apos;, function (event) &#123;</span><br><span class="line">localStorage.setItem(&apos;token&apos;, event.data)</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>
<p>前端通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取 Token 并在请求中携带，这样就实现了同一份 Token 被多个域所共享。<br>也可以 CAS（Central Authentication Service）中央认证服务，是 Yale 大学发起的一个开源项目，旨在为 Web 应用系统提供一种可靠的单点登录方法。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.chromestatus.com/feature/5088147346030592" target="_blank" rel="noopener">https://www.chromestatus.com/feature/5088147346030592</a></li>
<li><a href="https://www.chromium.org/updates/same-site" target="_blank" rel="noopener">https://www.chromium.org/updates/same-site</a></li>
<li><a href="https://hacks.mozilla.org/2020/08/changes-to-samesite-cookie-behavior/" target="_blank" rel="noopener">https://hacks.mozilla.org/2020/08/changes-to-samesite-cookie-behavior/</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/157#">https://github.com/mqyqingfeng/Blog/issues/157#</a></li>
<li><a href="https://mp.weixin.qq.com/s/QZkOXhQIg2LqDWpi7mzCdQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QZkOXhQIg2LqDWpi7mzCdQ</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/08/09/top/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/08/09/top/" itemprop="url">
                  Top-level await
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-09T17:15:27+08:00">
                2021-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>背景： chrome 于 5 月 4 号发布 v9.1 版本 ，带来了 Top-level await 新特新，我们可以在模块顶级中使用 await，不需要在额外的加入 async。</p>
</blockquote>
<h2 id="什么是-Top-level-await"><a href="#什么是-Top-level-await" class="headerlink" title="什么是 Top-level await"></a>什么是 Top-level await</h2><p>如果我们试图在一个 async 函数外面使用 await 关键字，将会引起语法错误，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="built_in">console</span>.log(<span class="string">'执行'</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>会产生如下报错：</p>
<blockquote>
<p>await is only valid in async functions and the top level bodies of modules<br>但是在 v9.1 我们可以在模块顶级中使用 await，不需要额外的加入 async。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span>&gt;<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="built_in">console</span>.log(<span class="string">'执行'</span>))&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>并且它有着如下特点：</p>
<ul>
<li>顶层 await 在模块图的执行阶段发挥作用，此时所有的资源都已经获取并链接了，不存在资源被阻塞的风险；</li>
<li>顶层 await 只限于在 ES6 模块中使用，不支持普通脚本或者 CommonJS 模块</li>
</ul>
<h3 id="先看一个例子"><a href="#先看一个例子" class="headerlink" title="先看一个例子"></a>先看一个例子</h3><p>在使用 ES6 模块化的时候，经常会遇到需要导入导出的场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; getSum &#125; <span class="keyword">from</span> <span class="string">"./a.js"</span>;</span><br><span class="line"><span class="keyword">let</span> sum;</span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  sum = getSum(<span class="number">2</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125;;</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./b.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// undefined</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(sum), <span class="number">2000</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们在文件之间进行变量的导入导出。<br>通过分析代码我们可以发现第一次打印的都是 undefined 第二次打印得到的是 4。因为在 async 函数执行完毕之前，c.js 就已经访问了 b.js 导出的变量。name 怎么解决呢？</p>
<h4 id="导出-IIFE-promise"><a href="#导出-IIFE-promise" class="headerlink" title="导出 IIFE promise"></a>导出 IIFE promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; getSum &#125; <span class="keyword">from</span> <span class="string">"./a.js"</span>;</span><br><span class="line"><span class="keyword">let</span> sum;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  sum = getSum(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123; sum &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">import</span> promise <span class="keyword">from</span> <span class="string">"./b.js"</span>;</span><br><span class="line">promise.then(<span class="function">(<span class="params">&#123; sum &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum); <span class="comment">// 4</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(sum), <span class="number">2000</span>); <span class="comment">// 4</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们将变量作为 async IIFE 的返回值返回。这样的话，c.js 只需简单地等待 promise 被 resolve，之后获取变量。<br>但是从静态分析、可测试性、工程学以及其它角度来讲，这种做法相比 ES2015 的模块化来说是一种显而易见的倒退。</p>
<h3 id="Top-level-await-怎么解决"><a href="#Top-level-await-怎么解决" class="headerlink" title="Top-level await 怎么解决"></a>Top-level await 怎么解决</h3><p>我们仍然异步地初始化我们的导出，但是我们可以通过 Top-level await 来正常地使用 sum。<br>我们可以导入 b.js，而不需要知道它会异步初始化的导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; getSum &#125; <span class="keyword">from</span> <span class="string">"./a.js"</span>;</span><br><span class="line"><span class="keyword">let</span> sum;</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">sum = getSum(<span class="number">2</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125;;</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./b.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 4</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(sum), <span class="number">2000</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>await promise 被 resolve 之前， c.js 中任意一条语句都不会执行。</p>
<h2 id="Top-level-await-是怎么工作的"><a href="#Top-level-await-是怎么工作的" class="headerlink" title="Top-level await 是怎么工作的"></a>Top-level await 是怎么工作的</h2><p>JavaScript 会静态地确认哪些模块是异步的，这些模块导出的 Promise 都会放到 Promise.all() 中。其余的导入仍然照常处理，并且拒绝（reject）和同步的异常都会被转为异步函数。</p>
<h2 id="Top-level-await-还可以做些什么"><a href="#Top-level-await-还可以做些什么" class="headerlink" title="Top-level await 还可以做些什么"></a>Top-level await 还可以做些什么</h2><h3 id="资源初始化"><a href="#资源初始化" class="headerlink" title="资源初始化"></a>资源初始化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//connect() return a promise.</span></span><br><span class="line"><span class="keyword">const</span> connection = <span class="keyword">await</span> dbConnector.connect();</span><br></pre></td></tr></table></figure>
<h3 id="动态加载模块"><a href="#动态加载模块" class="headerlink" title="动态加载模块"></a>动态加载模块</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`./file<span class="subst">$&#123;v&#125;</span>.js`</span>);</span><br></pre></td></tr></table></figure>
<h3 id="资源加载备选方案"><a href="#资源加载备选方案" class="headerlink" title="资源加载备选方案"></a>资源加载备选方案</h3><p>如果 CDN A 无法导入 Vue，那么会尝试从 CDN B 中导入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Vue = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">"https://cdn-a.dewu.com/Vue"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  Vue = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">"https://cdn-b.dewu.com/Vue"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.bitsrc.io/why-should-you-use-top-level-await-in-javascript-a3ba8139ef23" target="_blank" rel="noopener">https://blog.bitsrc.io/why-should-you-use-top-level-await-in-javascript-a3ba8139ef23</a></li>
<li><a href="https://javascript.plainenglish.io/javascript-top-level-await-in-a-nutshell-4e352b3fc8c8" target="_blank" rel="noopener">https://javascript.plainenglish.io/javascript-top-level-await-in-a-nutshell-4e352b3fc8c8</a></li>
<li><a href="https://2ality.com/2020/09/ecmascript-2021.html" target="_blank" rel="noopener">https://2ality.com/2020/09/ecmascript-2021.html</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/06/14/ployfill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/06/14/ployfill/" itemprop="url">
                  如何实现个在线的按需的 ployfill
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-14T21:10:04+08:00">
                2021-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>polyfill 在英文中有垫片的意思，意为兜底的东西。在计算机科学中，指的是对未能实现进行的”兜底”操作。简单的说就是它可以让你可以毫无顾虑地使用最新的 JavaScript 特性，而不需要关注浏览器兼容性。<br>我们用最多的 polyfill 方式都是基于 core-js 正常使用方式一般是这两种： 1.通过 cdn 不考虑按需引入整个 core-js 文件非常大，最新的 3.15.2 版本大小 742 kB。 2.用 babel 处理，通过设置 @babel/preset-env 加上 useBuiltins 配置来按需裁剪 core-js。<br>目前主流做法都是选择方案 2 通过 @babel/preset-env 裁剪，事实上，在 CDN 的缓存的作用下收益会比方案 2 剪裁有更好的性能。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>根据 babel 的做原理，如果能可以根据浏览器的兼容性配置动态的生成裁剪后的 core-js，然后只引入 CDN 上剪裁后的 core-js 文件。</p>
<h3 id="如何根据浏览器的兼容性动态剪裁"><a href="#如何根据浏览器的兼容性动态剪裁" class="headerlink" title="如何根据浏览器的兼容性动态剪裁"></a>如何根据浏览器的兼容性动态剪裁</h3><p>很简单，只需要按照 babel 的处理方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"core-js"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"regenerator-runtime/runtime"</span>;</span><br></pre></td></tr></table></figure>
<p>配一个 .browserlisrc 浏览器信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome <span class="number">86</span></span><br></pre></td></tr></table></figure>
<p>利用 rollup 打包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">"@rollup/plugin-babel"</span>;</span><br><span class="line"><span class="keyword">import</span> nodeResolve <span class="keyword">from</span> <span class="string">"@rollup/plugin-node-resolve"</span>;</span><br><span class="line"><span class="comment">// CommonJS格式</span></span><br><span class="line"><span class="keyword">import</span> commonJS <span class="keyword">from</span> <span class="string">"@rollup/plugin-commonjs"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; terser &#125; <span class="keyword">from</span> <span class="string">"rollup-plugin-terser"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  input: <span class="string">"index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    file: <span class="string">"dist.js"</span>,</span><br><span class="line">    format: <span class="string">"iife"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    babel(&#123; <span class="attr">babelHelpers</span>: <span class="string">"bundled"</span> &#125;),</span><br><span class="line">    nodeResolve(),</span><br><span class="line">    commonJS(),</span><br><span class="line">    terser(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经过 rollup 打包后就会生成一个根据浏览器裁剪后的 ployfill 文件了。</p>
<h3 id="如何云化"><a href="#如何云化" class="headerlink" title="如何云化"></a>如何云化</h3><p>上面我们通过 babel 工具去生成 polyfill，然后上传到 CDN 并修改引用地址，当需要不同浏览器兼容性的时又要重复上面的操作，成本很高，所以我们希望运用云函数的能力来实现在线生成，生成的逻辑在线化，目前云服务上都提供 Serverless 计算服务像阿里云 <a href="https://www.aliyun.com/product/fc" target="_blank" rel="noopener">函数计算 FC</a> 。</p>
<h4 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h4><p>只需要将 rollup 调用方式改成 api，通过 url 传参方式传递浏览器信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; encode &#125; = <span class="built_in">require</span>(<span class="string">"js-base64"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; rollup &#125; = <span class="built_in">require</span>(<span class="string">"rollup"</span>);</span><br><span class="line"><span class="keyword">const</span> rollupConfig = <span class="built_in">require</span>(<span class="string">"./factory/rollupConfig"</span>);</span><br><span class="line"><span class="keyword">const</span> terser = <span class="built_in">require</span>(<span class="string">"terser"</span>);</span><br><span class="line"><span class="keyword">const</span> respond = <span class="function">(<span class="params">body, statusCode = <span class="number">200</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    statusCode,</span><br><span class="line">    body,</span><br><span class="line">    isBase64Encoded: <span class="literal">false</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">"Content-Type"</span>:</span><br><span class="line">        statusCode === <span class="number">200</span></span><br><span class="line">          ? <span class="string">"application/javascript; charset=utf-8"</span></span><br><span class="line">          : <span class="string">"text/plain; charset=utf-8"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">exports.handler = <span class="keyword">async</span> (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; targets &#125; = event.queryStringParameters;</span><br><span class="line">  <span class="keyword">if</span> (!targets) &#123;</span><br><span class="line">    <span class="keyword">return</span> respond(<span class="string">"No targets specified"</span>, <span class="number">400</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> key = encode(targets, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> bundle = <span class="keyword">await</span> rollup(rollupConfig(targets));</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      output: [asset],</span><br><span class="line">    &#125; = <span class="keyword">await</span> bundle.generate(&#123; <span class="attr">file</span>: <span class="string">"dist.js"</span>, <span class="attr">format</span>: <span class="string">"iife"</span> &#125;);</span><br><span class="line">    <span class="keyword">const</span> minified = <span class="keyword">await</span> terser.minify(asset.code);</span><br><span class="line">    <span class="keyword">return</span> respond(minified.code);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(ex);</span><br><span class="line">    <span class="keyword">return</span> respond(ex.message, <span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样在线生成搞定了，但是每次生成时间巨长，真实启动的服务并不可用，所以我们需要在生成的前面加一个 CDN 配置，需要在上线前预热 CDN 就能达到秒开。当然业界也有成熟的在线服务例如 <a href="https://polyfill.io/v3/" target="_blank" rel="noopener">https://polyfill.io/v3/</a></p>
<h2 id="现实"><a href="#现实" class="headerlink" title="现实"></a>现实</h2><p>这样就完成了加载按需剪裁 CDN 资源的 ployfill，减少了资源大小，同时增加了缓存命中。<br>但是 <a href="https://developers.google.com/web/updates/2020/10/http-cache-partitioning" target="_blank" rel="noopener">chrome 85</a> 版本之后更新了缓存策略，新的策略生效后会大大降低缓存命中,新的策略：</p>
<ul>
<li>之前，单资源的缓存是以 URL 来作为键，并不关心请求 URL 的来源；</li>
<li>目前，缓存的键由 URL、顶部 window 域名、当前 window 域名三元组构成；<br>其他浏览器支持情况：</li>
<li>Safari 实现了顶部 window 域名 + URL 的键控制机制；</li>
<li>Firefox 即将实现同粒度的缓存键；<br>更新缓存机制后，缓存未命中的情形增加了 3.6%，整体网络加载字节数增加了 4%。</li>
</ul>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>虽然由于浏览器的缓存策略更新从而导致跨站缓存无法共享，但是本站的收益还是很大的。另外也可以采用更加细致的方案，把每一个 core-js 的所有 api 都在线化编译成独立的 ES 模块，然后项目采用 ES 模块的方式打包，让浏览器去加载最小粒度的 polyfill，精细度更大。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/03/26/IntersectionObserver实现高性能的交互动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/03/26/IntersectionObserver实现高性能的交互动画/" itemprop="url">
                  IntersectionObserver实现高性能的交互动画
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-26T21:07:55+08:00">
                2021-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>背景：以前我们在写滚动动画的时候通常判断元素是否显示通常会通过 getBoundingClientRect 获取位置，但是 getBoundingClientRect 将触发重排，利用此技术可能会很快造成性能瓶颈。</p>
</blockquote>
<h2 id="关于-IntersectionObserver"><a href="#关于-IntersectionObserver" class="headerlink" title="关于 IntersectionObserver"></a>关于 IntersectionObserver</h2><p>IntersectionObserver 是 web 领域众多观察器中的一个，是用来是观察元素和窗体相交的状态，很适合用在滚动交互事件，像是懒加载、埋点等场景。</p>
<blockquote>
<p>除了 IntersectionObserver ，我们常用的还有用来观察 DOM 变化的 MutationObserver；用来观察元素的尺寸变化 ResizeObserver。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>创建一个 intersection observer</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [entry] = entries;</span><br><span class="line">  <span class="keyword">if</span> (entry.isIntersecting) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"元素曝光了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  root: <span class="built_in">document</span>.querySelector(<span class="string">"#scrollArea"</span>), <span class="comment">// 指定根(root)元素，必须是目标元素的父级元素，如果未指定或者为null，则默认为浏览器视窗。</span></span><br><span class="line">  rootMargin: <span class="string">"0px"</span>, <span class="comment">// 根(root)元素的外边距</span></span><br><span class="line">  threshold: <span class="number">1.0</span>, <span class="comment">// 阈值为1.0意味着目标元素完全出现在root选项指定的元素中可见时，回调函数将会被执行。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(callback, options);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ele = <span class="built_in">document</span>.querySelector(<span class="string">".animatedElement"</span>);</span><br><span class="line"></span><br><span class="line">observer.observe(ele);</span><br></pre></td></tr></table></figure>
<p>callback 回调函数将会在主线程中被执行, 其中 entry 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entry.boundingClientRect 目标元素的区域信息</span><br><span class="line">entry.intersectionRatio 目标元素的可见比率</span><br><span class="line">entry.intersectionRect 目标元素与根元素交叉的区域信息</span><br><span class="line">entry.isIntersecting 是否进入可视区域</span><br><span class="line">entry.rootBounds 根元素的矩形区域信息</span><br><span class="line">entry.target 被观察的目标，是一个DOM节点</span><br><span class="line">entry.time 可见性发生变化的时间,相交发生时距离页面打开时的毫秒数.精度为微秒。</span><br></pre></td></tr></table></figure>
<p>Intersection Observer 可用的方法有 observe()，unobserve() 和 disconnect()。</p>
<ul>
<li>observe()：用来添加观察者要监视的目标元素，观察者可以具有多个目标元素，但是此方法一次只能接受一个目标。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const element = document.querySelector(&apos;.animatedElement&apos;);</span><br><span class="line">observer.observe(element);</span><br></pre></td></tr></table></figure>
<ul>
<li>unobserve()：用来从观察的元素列表中移除元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.unobserve(element);</span><br></pre></td></tr></table></figure>
<ul>
<li>disconnect()：用来停止观察其所有目标元素。观察者本身仍处于活动状态，但没有目标。在 disconnect() 之后，目标元素仍然可以通过 observe() 传递给观察者。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure>
<h2 id="利用-getBoundingClientRect-实现动画"><a href="#利用-getBoundingClientRect-实现动画" class="headerlink" title="利用 getBoundingClientRect 实现动画"></a>利用 getBoundingClientRect 实现动画</h2><p>通常是监听滚动，通过获取元素位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, () =&gt; checkForVisibility);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, () =&gt; checkForVisibility);</span><br></pre></td></tr></table></figure>
<p>根据元素的位置触发动画</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkForVisibility</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = <span class="built_in">document</span>.querySelector(<span class="string">".animatedElement"</span>);</span><br><span class="line">  <span class="keyword">const</span> distTop = element.getBoundingClientRect().top;</span><br><span class="line">  <span class="keyword">const</span> distBottom = element.getBoundingClientRect().bottom;</span><br><span class="line">  <span class="keyword">const</span> distPercentTop = <span class="built_in">Math</span>.round((distTop / <span class="built_in">window</span>.innerHeight) * <span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> distPercentBottom = <span class="built_in">Math</span>.round((distBottom / <span class="built_in">window</span>.innerHeight) * <span class="number">100</span>);</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 getBoundingClientRect 将触发重排也就会造成性能问题，那 getBoundingClientRect() 为什么会触发 Reflow 呢？<br>在 chromium 的源码中搜索 getBoundingClientRect 可以看到代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOMRect* Range::getBoundingClientRect() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> DOMRect::FromFloatRect(BoundingRect());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BoundingRect() 中调用了 UpdateStyleAndLayout</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FloatRect Range::BoundingRect() <span class="keyword">const</span> &#123;</span><br><span class="line">owner_document_-&gt;UpdateStyleAndLayout(DocumentUpdateReason::kJavaScript);</span><br><span class="line"></span><br><span class="line">Vector&lt;FloatQuad&gt; quads;</span><br><span class="line">GetBorderAndTextQuads(quads);</span><br><span class="line"></span><br><span class="line">FloatRect result;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> FloatQuad&amp; quad : quads)</span><br><span class="line">result.Unite(quad.BoundingBox()); <span class="comment">// Skips empty rects.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If all rects are empty, return the first rect.</span></span><br><span class="line"><span class="keyword">if</span> (result.IsEmpty() &amp;&amp; !quads.IsEmpty())</span><br><span class="line"><span class="keyword">return</span> quads.front().BoundingBox();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 UpdateStyleAndLayout 方法调用之后将会触发 LayoutTree 的重新渲染，也就是 Reflow。</p>
<h2 id="利用-IntersectionObserver-实现动画"><a href="#利用-IntersectionObserver-实现动画" class="headerlink" title="利用 IntersectionObserver 实现动画"></a>利用 IntersectionObserver 实现动画</h2><p>通过 Intersection Observer API 获取到两个元素重叠部分的准确值，只需几行代码即可设置根据元素可见性触发动画：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animationObserver = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> entries) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    entry.target.classList.toggle(<span class="string">"animating"</span>, entry.isIntersecting);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> querySelectorAll(<span class="string">".animatedElement"</span>)) &#123;</span><br><span class="line">  animationObserver.observe(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IntersectionObserver-polyfill"><a href="#IntersectionObserver-polyfill" class="headerlink" title="IntersectionObserver-polyfill"></a>IntersectionObserver-polyfill</h2><p>对于不支持的浏览器可以引入 w3c 官方创建的 polyfill <a href="https://github.com/w3c/IntersectionObserver。">https://github.com/w3c/IntersectionObserver。</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>• <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API</a><br>• <a href="https://www.zhangxinxu.com/wordpress/2020/12/js-intersectionobserver-nav/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2020/12/js-intersectionobserver-nav/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/02/07/代码质量-代码重复/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/02/07/代码质量-代码重复/" itemprop="url">
                  代码质量-代码重复
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-07T19:37:34+08:00">
                2021-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>背景:重复率是 oasis（衡量前端工程质量平台）的检测指标之一，对项目定期进行代码重复率检测是一个很有意义的事，可以帮助开发人员发现冗余代码，进行代码抽象和重构。</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>代码重复（英文：duplicate code，也叫代码克隆）在程序设计中表示一段源代码在一个程序，或者一个团体所维护的不同程序中重复出现，是不希望出现的现象。为避免巧合，只有一定数量的代码完全相同才能判定为代码重复。 – 维基百科</p>
</blockquote>
<p>代码重复一般分为两大类：</p>
<ul>
<li>句法重复<br>两个函数的代码片段基本一致，只是参数名、函数名、字符等做了修改，或是多/少了某一行多代码，这种改动只是文本层面的改动，也被称为。</li>
<li>语义重复<br>两个函数的代码实现不同，从文本层面看区别较大，但实现的都是同一个功能。</li>
</ul>
<p>基于句法重复、语义重复两大类，然后被划分为四小类：</p>
<ul>
<li>完全一致的代码或者只修改了空格和评论（句法克隆）。</li>
<li>结构上和句法上一致的代码，例如只是修改了变量名 （句法克隆）。</li>
<li>插入和删除了部分代码（句法克隆）。</li>
<li>功能和逻辑上一致的代码，语义上的拷贝（语义克隆）。<br>其中前三种为句法克隆，第四种为语义克隆。检测难度也是一次递增，目前对前三种代码重复的检测已颇为成熟； 而对第四种的检测准确率仍不高，无法达到应用标准。<br>重复代码未必就是 copy-paste 产生的，可能就是不同人重复写的，就算是 copy-paste 产生的，在 paste 之后可能代码也会发生变化。</li>
</ul>
<h2 id="前端重复检测"><a href="#前端重复检测" class="headerlink" title="前端重复检测"></a>前端重复检测</h2><h3 id="检测代码重复的手段"><a href="#检测代码重复的手段" class="headerlink" title="检测代码重复的手段"></a>检测代码重复的手段</h3><ul>
<li>Textual：代码片段以文本/字符串/词法的形式相互比较，并且只有在两个代码片段在文本内容方面确实相同时才被发现被克隆。</li>
<li>Token：在编译器的词法分析阶段，所有源代码行都被划分为一系列 Token。 然后将所有 Token 转换回 Token 序列。</li>
<li>Syntactic（句法分析）：<ul>
<li>基于树: 提取的 AST 用于子树比较以识别相似区域。</li>
<li>基于度量：通过源代码收集度量，然后使用这些度量为每个代码片段生成向量。然后使用向量对代码的相似度进行对比。</li>
</ul>
</li>
<li>Semantic（语义克隆）：主要检测代码片段不同，但功能相同的函数。</li>
<li>Learning : 通过机器学习和统计分析的方式来进行克隆检测。</li>
</ul>
<h3 id="检测代码重复的流程"><a href="#检测代码重复的流程" class="headerlink" title="检测代码重复的流程"></a>检测代码重复的流程</h3><ol>
<li>将源码拆分为对比单元（comparison units, 如 class，function，block，statement）。</li>
<li>将对比单元转化为中间表达（IR, Intermediate Representation，如 token，AST, PDG）。</li>
<li>再对这些对比单元的 IR 进行 match detection（对比），通常是将对比单元组成 clone pair 的形式：一次对比两个（c1, c2）或是多个（c1, c2, c3）。</li>
</ol>
<h3 id="检测工具"><a href="#检测工具" class="headerlink" title="检测工具"></a>检测工具</h3><ul>
<li>jsinspect<br>利用 babylon 对于 JavaScript 或者 JSX 代码构建 AST 语法树，根据不同的 AST 节点类型，标记相似结构的代码块，检测效果比较好。</li>
<li>jscpd：其重复率判定依据为一定长度标识符的 MD5 值是否相同，虽然结果没有 jsinspect 好，但是支持文件格式广泛，如 java、oc、js、jsx、vue、ts、less 等。</li>
<li>PMD：支持 js 文件检测，也可以自己开发扩展包来解析指定的语言（需要安装 java 环境，npm 不支持，无法匹配前端脚手架）。</li>
</ul>
<p>由于前端文件类型众多所以 oasis 最终选择了 jscpd 作为代码重复率检测工具。</p>
<h3 id="重复率标准"><a href="#重复率标准" class="headerlink" title="重复率标准"></a>重复率标准</h3><p>重复率标准的制定需要参考的因素有很多，例如 tokens、项目、架构、时间等等,目前 oasis 平台是 10%，具体数值还会在运行一段时间后观察调整。<br>代码重复率 = 重复的行数 / 扫描的文件总行数。</p>
<h3 id="降低重复率"><a href="#降低重复率" class="headerlink" title="降低重复率"></a>降低重复率</h3><p>应用中，可以参考《重构》（Refactoring）中说的三次原则（Rule of three），即同样的代码将要出现第三次前，考虑抽象它，复用它。具备小而美的工程思想，随着前端生态的完善，前端的组件化开发效率已经有了很大的提升。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码重复会让项目失控，重复代码不仅让代码量大增，造成编译速度慢，占用大量存储空间，造成了代码可维护性差，代码质量下降。通过重构从而降低代码的耦合性，这样不仅提高代码的灵活性、健壮性以及可读性，也方便后期的维护。我们也不是单纯地追求公共代码地完全剥离化，过度的抽象反而会降低代码的可读性与可理解性。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>oasisV0.1 beta 版本目前已经完成大文件、重复代码块，圈复杂度、最佳实践、基础库落地、 npm 依赖库的安全分析功能，接入 0 成本目前已经上线欢迎大家体验、建议、吐槽。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2021/01/03/代码质量-圈复杂度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/03/代码质量-圈复杂度/" itemprop="url">
                  代码质量-圈复杂度
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-03T21:27:05+08:00">
                2021-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>圈复杂度是 oasis（衡量前端工程质量平台）的检测指标之一，目的是为了检测出逻辑复杂，可能质量低，且难于测试和维护的模块，提高 CR 效率和推动优化提升前端工程质量。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>圈复杂度（Cyclomatic complexity，CC）也称为条件复杂度，其符号为 V(G),是衡量计算机程序复杂程度的一种措施。它根据程序从开始到结束的线性独立路径的数量计算得来的,其数量上为独立路径的条数，也可理解为覆盖所有的可能情况最少使用的测试用例个数。</p>
<h2 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h2><p>圈复杂度大说明程序代码的判断逻辑复杂，可能质量低，且难于测试和维护。 代码复杂度低，代码不一定好，但代码复杂度高，代码一定不好。</p>
<table>
<thead>
<tr>
<th>圈复杂度</th>
<th>代码状况</th>
<th>可测性</th>
<th>维护成本</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 - 10</td>
<td>清晰</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>10 - 20</td>
<td>复杂</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>20 - 30</td>
<td>非常复杂</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>&gt; 30</td>
<td>不可读</td>
<td>不可测</td>
<td>非常高</td>
</tr>
</tbody>
</table>
<p>同时测试驱动的开发和圈复杂度存在紧密的关系。一个好的测试用例是创建数量与被测代码圈复杂度值相等的测试用例，以此提升测试用例对代码的分支覆盖率。</p>
<h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p>圈复杂度有两种计算方法：点边计算法和节点判定法。</p>
<h3 id="节点判定法"><a href="#节点判定法" class="headerlink" title="节点判定法"></a>节点判定法</h3><p>因为圈复杂度所反映的是“判定条件”的数量，所以圈复杂度实际上就是等于判定节点的数量再加上 1。从 1 开始，一直往下通过程序,一但遇到 P 关键字，或者其它同类的词，就加 1。</p>
<blockquote>
<p>V (G) = P + 1</p>
</blockquote>
<p>其中 P 为判定节点数，常见的判定节点有：</p>
<p>if 语句、while 语句、for 语句、case 语句、catch 语句、and 和 or 布尔操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function test(a) &#123;</span><br><span class="line">    let b = 1;</span><br><span class="line">    if (a &lt; 0 || a &gt; 100) &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (a &lt; 30 ) &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 31:</span><br><span class="line">            b++ ;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return b === 1 ? 0 : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 个 if ，1 个 or ，1 个 for ，1 个 while，1 个 case，1 个三元 所以代码复杂度 7</p>
<h3 id="点边计算法"><a href="#点边计算法" class="headerlink" title="点边计算法"></a>点边计算法</h3><p>圈复杂度由程序的控制流图来计算：节点对应程序中个别的代码，而若一个程序运行后会立刻运行另一代码，则会有边连接另一代码对应的节点。</p>
<blockquote>
<p>V(G) = E - N + 2</p>
</blockquote>
<p>E 表示控制流图中边的数量，N 表示控制流图中节点的数量。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glhni7agy2j30wm0p4753.jpg" alt=""></p>
<p>如上图正常顺序的圈复杂度为 1；if else 的圈复杂度为 2；while 的圈复杂度也为 2。</p>
<h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><h3 id="es6-plato"><a href="#es6-plato" class="headerlink" title="es6-plato"></a>es6-plato</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev es6-plato</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot; : &#123;</span><br><span class="line">    &quot;complexity-report&quot;: &quot;./node_modules/.bin/es6-plato -r -d ./report src&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run complexity-report</span><br></pre></td></tr></table></figure>
<h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>oasis 用的是 eslint 提供了检测代码圈复杂度的 rules ，根据 eslint 的 api 会自动检测出所有函数的代码复杂度输出检测信息，通过解析检测信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CLIEngine(&#123;</span><br><span class="line">  baseConfig: &#123;</span><br><span class="line">    root: <span class="literal">true</span>,</span><br><span class="line">    parser: <span class="string">"vue-eslint-parser"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: <span class="number">9</span>,</span><br><span class="line">    sourceType: <span class="string">"module"</span>,</span><br><span class="line">    ecmaFeatures: &#123;</span><br><span class="line">      experimentalObjectRestSpread: <span class="literal">true</span>,</span><br><span class="line">      jsx: <span class="literal">true</span>,</span><br><span class="line">      globalReturn: <span class="literal">true</span>,</span><br><span class="line">      impliedStrict: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    parser: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  useEslintrc: <span class="literal">false</span>,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    complexity: [<span class="string">"error"</span>, &#123; <span class="attr">max</span>: <span class="number">0</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="降低圈复杂度"><a href="#降低圈复杂度" class="headerlink" title="降低圈复杂度"></a>降低圈复杂度</h2><p>降低复杂度有的是把函数的一部分提取成另一个子函数，不会降低整个项目的复杂度，只是把决策点移到其他地方，但是这样做可以降低你在同一时间必须关注的复杂度。</p>
<h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><blockquote>
<p>函数应该做一件事，做好这件事，只做这一件事。 — 代码整洁之道</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a === <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b === <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> calcA(a) + calcB(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcA</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// dosomething</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a === <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// dosomething</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcB</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// dosomething</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b === <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// dosomething</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (f(a, b, c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g(a, b, c)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (h(a, b, c)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j(a, b, c)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k(a, b, c)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rules = &#123;</span><br><span class="line">  x: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">  y: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">  z: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> action = determineAction(a, b, c)</span><br><span class="line">  <span class="keyword">return</span> rules[action](a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="职责链"><a href="#职责链" class="headerlink" title="职责链"></a>职责链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (f(a, b, c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g(a, b, c)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (h(a, b, c)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j(a, b, c)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k(a, b, c)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rules = [</span><br><span class="line">  &#123;</span><br><span class="line">    match: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">    action: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    match: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">    action: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    match: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">    action: <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rules.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rules[i].match(a, b, c)) &#123;</span><br><span class="line">      <span class="keyword">return</span> rules[i].action(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>圈复杂度低，代码不一定好，但圈复杂度很高，代码一定不好，所以圈复杂度才作为一个 oasis 的指标之一。圈复杂度还需要具体情况具体分析，其只作为重构的一个度量指标，作为决策的一个参考依据。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>oasisV0.1 beta 版本目前已经完成大文件、重复代码块，圈复杂度、最佳实践、基础库落地、 npm 依赖库的安全分析功能，接入 0 成本目前已经上线欢迎大家体验、建议、吐槽。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2020/11/23/SPAVUE应用实现页面缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/11/23/SPAVUE应用实现页面缓存/" itemprop="url">
                  SPA VUE应用实现页面缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-23T21:36:15+08:00">
                2020-11-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在 SPA 应用中产品希望在用户在多个页面来回切换的时候，不要丢失查询的结果。</p>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><blockquote>
<p><keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</keep-alive></transition></keep-alive></p>
</blockquote>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><ul>
<li>整个页面缓存</li>
</ul>
<p>采用在 router 的 meta 属性里增加一个 keepAlive 字段，然后在父组件或者根组件中，根据 keepAlive 字段的状态使用 <keep-alive> 标签，实现对 <router-view> 的缓存</router-view></keep-alive></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-<span class="keyword">if</span>=<span class="string">"$route.meta.keepAlive"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp">&lt;router-view v-if="!$route.meta.keepAlive" /</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>动态缓存</li>
</ul>
<p>使用 vuex 配合 exclude 和 include，通过 include 和 exclude 决定那些组件进行缓存。注意这里说的是组件，并且 cachedView 数组存放的是组件的名字，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=<span class="string">"$store.state.keepAlive.cachedView"</span>&gt;</span><br><span class="line">    &lt;router-view /&gt;</span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="本项目的实现"><a href="#本项目的实现" class="headerlink" title="本项目的实现"></a>本项目的实现</h3><ul>
<li>版本一：基于路由缓存</li>
</ul>
<p>当前框架是嵌套的动态路由是无法动态缓存组件，并且如果使用方案一 meta 属性里增加一个 keepAlive 字段也是不支持的，只能通过维护一个缓存的 url 来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ISCACHE_ARRAY = ['url']</span></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">          &lt;router-view v-<span class="keyword">if</span>=<span class="string">"ISCACHE_ARRAY.indexOf($route.fullPath) !== -1"</span> :key=<span class="string">"$route.fullPath"</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/router-view&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>keep-alive&gt;</span><br><span class="line">        &lt;router-view v-<span class="keyword">if</span>=<span class="string">"ISCACHE_ARRAY.indexOf($route.fullPath) === -1"</span> :key=<span class="string">"$route.fullPath"</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/router-view&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样是持久缓存了整个页面，问题也就出现当用户通过 tabviews 关闭页面然后从左侧打开菜单时是缓存的页面，这个不符合日常使用习惯，所以为了解决数据新鲜度的问题，看了文档发现在 keep-alive 的模式下多了 activated 这个生命周期函数,keep-alive 的声明周期执行:</p>
<ul>
<li>页面第一次进入，钩子的触发顺序<br>created-&gt; mounted-&gt; activated，<br>退出时触发 deactivated 当再次进入（前进或者后退）时，只触发 activated</li>
<li>事件挂载的方法等，只执行一次的放在 mounted 中；组件每次进去执行的方法放在 activated 中</li>
</ul>
<p>所以在 activated 触发查询请求就能保证数据的新鲜度。</p>
<p>但是使用后发现由于你切换 tab 是会请求数据，但是本项目的数据量有很大导致频繁 loading 。</p>
<ul>
<li>版本二：动态缓存</li>
</ul>
<p>由于版本一需要频繁拉去数据导致此方案已不合适只能动态缓存。<br>由于框架的原因，框架里把路由和菜单用同一个数据模型采用的嵌套路由是无法缓存组件的，改造前路由如下：<br><img src="https://cdn.poizon.com/node-common/d1edd0fb704d5c4605d07f525626713f.png" alt=""></p>
<p>所以需要改造确定：左侧菜单嵌套，路由展开不嵌套的方式：<br>app.vue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;Layout&gt;&lt;/Layout&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>layout.vue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=&quot;cachedViews&quot;&gt;</span><br><span class="line">          &lt;router-view :key=&quot;key&quot;&gt;</span><br><span class="line">          &lt;/router-view&gt;</span><br><span class="line">        &lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p>通过上面的修改完成动态缓存实现。</p>
<p>其中 cachedViews 是通过监听路由动态增加删除维护要缓存的组件数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;</span><br><span class="line">  cachedViews: [],</span><br><span class="line">&#125;</span><br><span class="line">const mutations = &#123;</span><br><span class="line">  ADD_VIEWS: (state, view) =&gt; &#123;</span><br><span class="line">    if (state.cachedViews.includes(view.name)) return</span><br><span class="line">    state.cachedViews.push(view.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  DEL_CACHED_VIEW: (state, view) =&gt; &#123;</span><br><span class="line">    const index = state.cachedViews.indexOf(view.name)</span><br><span class="line">    index &gt; -1 &amp;&amp; state.cachedViews.splice(index, 1)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">const actions = &#123;</span><br><span class="line">  addCachedView(&#123; commit &#125;, view) &#123;</span><br><span class="line">    commit(&apos;ADD_VIEWS&apos;, view)</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteCachedView(&#123; commit &#125;, view) &#123;</span><br><span class="line">    commit(&apos;DEL_CACHED_VIEW&apos;, view)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  namespaced: true,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过监听路由变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    &apos;$route&apos;(newRoute) &#123;</span><br><span class="line">      const &#123; name &#125; = newRoute</span><br><span class="line">      console.log(name)</span><br><span class="line">      const cacheRout = this.ISCACHE_MAP[name] || []</span><br><span class="line">      cacheRout.map((item) =&gt; &#123;</span><br><span class="line">        store.dispatch(&apos;cached/addCachedView&apos;, &#123; name: item &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>ISCACHE_MAP 是配置每个页面要缓存的那些组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const ISCACHE_MAP = &#123;</span><br><span class="line">  &apos;/receipts-order&apos;: [&apos;ReceiptsOrder&apos;],</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当通过 tabview 关闭页面时清除组件名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">closeTag(newRoute) &#123;</span><br><span class="line">     const &#123; name &#125; = newRoute</span><br><span class="line">     const cacheRout = this.ISCACHE_MAP[name] || []</span><br><span class="line">     cacheRout.map((item) =&gt; &#123;</span><br><span class="line">       store.dispatch(&apos;cached/deleteCachedView&apos;, &#123; name: item &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
<p>关于展开路由是在动态路由添加时展开:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export const flatten = (data) =&gt; &#123;</span><br><span class="line">  return data.reduce((arr, v) =&gt; &#123;</span><br><span class="line">    if (Array.isArray(v.children) &amp;&amp; v.children.length !== 0) &#123;</span><br><span class="line">      return arr.concat(flatten(v.children))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return arr.concat([v])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line">routes.addRoutes(flatten(routeList))</span><br></pre></td></tr></table></figure>
<p>改造后的路由：</p>
<p><img src="https://cdn.poizon.com/node-common/5246ccef44ed399213902d488a0e24ea.png" alt=""></p>
<p>到此完美解决了当前框架的设计问题</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述的常规方案网上一大把，如何将它们合理的使用在项目中，这才是我们需要多去思考的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2020/10/02/配置打包分析与实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/10/02/配置打包分析与实践/" itemprop="url">
                  vue-cli 配置打包分析与实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-02T22:33:19+08:00">
                2020-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统,它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。</p>
<h2 id="如何看-webpack-最终配置"><a href="#如何看-webpack-最终配置" class="headerlink" title="如何看 webpack 最终配置"></a>如何看 webpack 最终配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"webpack_output_dynamic"</span>: <span class="string">"vue inspect --mode=dynamic &gt; output.js"</span>,</span><br><span class="line">    <span class="string">"webpack_output_production"</span>: <span class="string">"vue inspect --mode=production &gt; output.js"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何统计打包的时间"><a href="#如何统计打包的时间" class="headerlink" title="如何统计打包的时间"></a>如何统计打包的时间</h2><p>speed-measure-webpack-plugin 是一个专门测试 webpack 构建速度的工具，可以在终端列出所有 Loader 和 Plugin 的耗时。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SpeedMeasurePlugin = <span class="built_in">require</span>(<span class="string">'speed-measure-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasurePlugin()</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: smp.wrap(&#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>webpack 打包结束后，输出的时间统计</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> SMP  ⏱</span><br><span class="line">General output time took <span class="number">51.66</span> secs</span><br><span class="line"></span><br><span class="line"> SMP  ⏱  Plugins</span><br><span class="line">DllReferencePlugin took <span class="number">0.55</span> secs</span><br><span class="line"></span><br><span class="line"> SMP  ⏱  Loaders</span><br><span class="line">mini-css-extract-plugin, and</span><br><span class="line">css-loader, and</span><br><span class="line">sass-loader took <span class="number">14.16</span> secs</span><br><span class="line">  <span class="built_in">module</span> count = <span class="number">1</span></span><br><span class="line">css-loader, and</span><br><span class="line">sass-loader took <span class="number">14.15</span> secs</span><br><span class="line">  <span class="built_in">module</span> count = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>配置 vue.config.js</p>
<h2 id="添加别名-resolve-alias"><a href="#添加别名-resolve-alias" class="headerlink" title="添加别名 resolve.alias"></a>添加别名 resolve.alias</h2><p>目前的配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">configureWebpack: &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">         <span class="string">'@'</span>: <span class="string">'/Users/admin/Documents/code/gondor/src'</span>,</span><br><span class="line">      vue$: <span class="string">'vue/dist/vue.runtime.esm.js'</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展名配置-resolve-extensions"><a href="#扩展名配置-resolve-extensions" class="headerlink" title="扩展名配置 resolve.extensions"></a>扩展名配置 resolve.extensions</h2><p>extensions 的配置原则是频率出现高的排前面，数组长度尽量小,以下是 vue-cli 中的默认配置 [‘.mjs’, ‘.js’, ‘.jsx’, ‘.vue’, ‘.json’, ‘.wasm’]</p>
<p>我们的文件没有 .mjs、.jsx，所以在 vue.config.js 中我这样配置会更好：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  config.resolve.extensions.store = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">".js"</span>, <span class="string">".vue"</span>, <span class="string">".json"</span>, <span class="string">".wasm"</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="确定搜索目录-resolve-modules"><a href="#确定搜索目录-resolve-modules" class="headerlink" title="确定搜索目录 resolve.modules"></a>确定搜索目录 resolve.modules</h2><p>当搜索模块的时候告诉 webpack 确定的目录文件，这样可以避免无用的检索。webpack 默认的配置是相对路径，检索当前目录的下的 node_modules，如果没有则再会去根目录下的 node_modules，直到没有最后抛错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  config.resolve.modules.store = <span class="keyword">new</span> <span class="built_in">Set</span>([</span><br><span class="line">    path.resolve(__dirname, <span class="string">"node_modules"</span>),</span><br><span class="line">    <span class="string">"node_modules"</span>,</span><br><span class="line">  ]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面也是默认的</p>
<h2 id="忽略非模块化-Library-module-noParse"><a href="#忽略非模块化-Library-module-noParse" class="headerlink" title="忽略非模块化 Library module.noParse"></a>忽略非模块化 Library module.noParse</h2><p>忽略那些文件中不含有 import, require, define 的调用，或任何其他导入机制的 library。忽略大型的 library 可以提高构建性能。下面是默认配置，请根据项目需要修改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configureWebpack: &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    noParse: <span class="regexp">/^(vue|vue-router|vuex|vuex-router-sync)$/</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态链接库-DllPlugin"><a href="#动态链接库-DllPlugin" class="headerlink" title="动态链接库 DllPlugin"></a>动态链接库 DllPlugin</h2><p>DllPlugin 和 DllReferencePlugin 实现了拆分 bundles，可以将一些不常被更新的第三方依赖预编译到一个或多个 manifest.json 中，做到一次打包就可以重复引用的效果。比如说我们 vue 全家桶、axios 等依赖，只要版本不升级就没必要多次打包，我们可以让这些依赖与业务代码分开打包。<br>使用方式大致分三步：</p>
<ul>
<li>利用 DllPlugin 配置预先打包出 _.manifest.json 文件。</li>
<li>在 webpack 主配置中设置 DllReferencePlugin，告诉 webpack 使用了哪些动态链接库。</li>
<li>在页面文件中加载所有的动态链接库。<br>webpack.dll.config.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> DllPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/DllPlugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 将 Vue 相关模块打包到一个单独的动态链接库中</span></span><br><span class="line">    vue: [<span class="string">"vue"</span>, <span class="string">"vue-router"</span>, <span class="string">"vuex"</span>],</span><br><span class="line">    <span class="comment">// 将其他的一些不变动的第三方库打包到一个动态链接库中</span></span><br><span class="line">    polyfill: [<span class="string">"element-ui"</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 输出动态链接库的文件名称，[name] 代表当前动态链接库的名称</span></span><br><span class="line">    <span class="comment">// name 来自 entry 对象中的 key</span></span><br><span class="line">    filename: <span class="string">"[name].dll.js"</span>,</span><br><span class="line">    <span class="comment">// 输出的文件都放到 dist 目录下</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    <span class="comment">// 动态链接库全局名称，例如 vue 就是 _dll_vue</span></span><br><span class="line">    library: <span class="string">"dll[name]"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> DllPlugin(&#123;</span><br><span class="line">      <span class="comment">// 动态链接库的全局变量名称需要和 output.library 中的名称一致</span></span><br><span class="line">      <span class="comment">// 代表 manifest.json 文件中的 name 字段的值</span></span><br><span class="line">      <span class="comment">// 例如 vue.manifest.json 中的 'name': '_dll_vue'</span></span><br><span class="line">      name: <span class="string">"dll[name]"</span>,</span><br><span class="line">      <span class="comment">// 动态链接库文件输出的文件名，例如 vue.manifest.json</span></span><br><span class="line">      path: path.join(__dirname, <span class="string">"dll"</span>, <span class="string">"[name].manifest.json"</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>vue.config.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="comment">// 告诉 webpack 使用的动态链接库</span></span><br><span class="line">      <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">        manifest:      <span class="built_in">require</span>(<span class="string">'./dll/vue.manifest.json'</span>),</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">        manifest: <span class="built_in">require</span>(<span class="string">'./dll/polyfill.manifest.json'</span>),</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">在 package.json 中增加</span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string"> "scripts": &#123;</span></span><br><span class="line"><span class="string">    "dll": "webpack --config webpack.dll.config.js"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="hard-source-webpack-plugin"><a href="#hard-source-webpack-plugin" class="headerlink" title="hard-source-webpack-plugin"></a>hard-source-webpack-plugin</h2><p>webpack4 抛弃了使用 dll，hard-source-webpack-plugin 就是一个很好的替代者，它可为模块提供中间缓存步骤。第二次构建将明显更快。</p>
<h2 id="外部扩展（external）"><a href="#外部扩展（external）" class="headerlink" title="外部扩展（external）"></a>外部扩展（external）</h2><p>externals 配置选项提供了「从输出的 bundle 中排除依赖」的方法，也是个人最提倡的采用 script 引入 CDN 资源</p>
<h2 id="分环境压缩代码"><a href="#分环境压缩代码" class="headerlink" title="分环境压缩代码"></a>分环境压缩代码</h2><p>在 development 环境时，我们可以关闭压缩来提升打包速度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.VUE_APP_ENV === <span class="string">"dynamic"</span>) &#123;</span><br><span class="line">    <span class="comment">// development</span></span><br><span class="line">    <span class="comment">// js is not compressed</span></span><br><span class="line">    config.optimization.minimize(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// css is not compressed</span></span><br><span class="line">    config.plugins.delete(<span class="string">"optimize-css"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="打包后的代码质量"><a href="#打包后的代码质量" class="headerlink" title="打包后的代码质量"></a>打包后的代码质量</h2><p>使用 webpack-bundle-analyzer 分析工具，在启动打包完成后，会在 8888 端口显示一个交互式可视化 bundle treemap。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>升级打包机配置</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lennonover" />
          <p class="site-author-name" itemprop="name">lennonover</p>
           
              <p class="site-description motion-element" itemprop="description">一丿口石砳磊</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">67</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lennonover</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
