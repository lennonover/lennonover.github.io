<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一丿口石砳磊">
<meta property="og:type" content="website">
<meta property="og:title" content="lennonover">
<meta property="og:url" content="https://github.com/lennonover/index.html">
<meta property="og:site_name" content="lennonover">
<meta property="og:description" content="一丿口石砳磊">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lennonover">
<meta name="twitter:description" content="一丿口石砳磊">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/lennonover/"/>





  <title> lennonover </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lennonover</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2019/02/12/video-自动播放/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/12/video-自动播放/" itemprop="url">
                  video 自动播放
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T21:57:58+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2019/01/27/Js-几种循环的比较/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/27/Js-几种循环的比较/" itemprop="url">
                  Js 几种循环的比较
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T21:34:29+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TEST_SIZE = <span class="number">10000000</span>;</span><br><span class="line"><span class="comment">// 常用</span></span><br><span class="line"><span class="keyword">let</span> arr1 = (<span class="keyword">new</span> <span class="built_in">Array</span>(TEST_SIZE)).fill(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> target1 = [];</span><br><span class="line"><span class="keyword">let</span> iStart1 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">    target1.push(arr1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iEnd1 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'for:'</span> +(iEnd1 - iStart1)+<span class="string">'ms'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取 len</span></span><br><span class="line"><span class="keyword">let</span> arr11 = (<span class="keyword">new</span> <span class="built_in">Array</span>(TEST_SIZE)).fill(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> target11 = [];</span><br><span class="line"><span class="keyword">let</span> iStart11 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="keyword">let</span> len = arr11.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    target11.push(arr11[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iEnd11 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'for-len:'</span> +(iEnd11 - iStart11)+<span class="string">'ms'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒叙</span></span><br><span class="line"><span class="keyword">let</span> arr12 = (<span class="keyword">new</span> <span class="built_in">Array</span>(TEST_SIZE)).fill(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> target12 = [];</span><br><span class="line"><span class="keyword">let</span> iStart12 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = arr12.length; i--;) &#123;</span><br><span class="line">    target12.push(arr12[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iEnd12 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'for-re:'</span> +(iEnd12 - iStart12)+<span class="string">'ms'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将取值与判断合并，通过不停的枚举每一项来循环</span></span><br><span class="line"><span class="keyword">let</span> arr13 = (<span class="keyword">new</span> <span class="built_in">Array</span>(TEST_SIZE)).fill(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> target13 = [];</span><br><span class="line"><span class="keyword">let</span> iStart13 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, a; a = arr13[i]; i++) &#123;</span><br><span class="line">    target13.push(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iEnd13 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'for-a:'</span> +(iEnd13 - iStart13)+<span class="string">'ms'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach</span></span><br><span class="line"><span class="keyword">let</span> arr2 = (<span class="keyword">new</span> <span class="built_in">Array</span>(TEST_SIZE)).fill(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> target2 = [];</span><br><span class="line"><span class="keyword">let</span> iStart2 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">arr2.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    target2.push(item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> iEnd2 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'forEach:'</span> +(iEnd2 - iStart2)+<span class="string">'ms'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">let</span> arr3 = (<span class="keyword">new</span> <span class="built_in">Array</span>(TEST_SIZE)).fill(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> target3 = [];</span><br><span class="line"><span class="keyword">let</span> iStart3 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">arr3.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    target3.push(item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> iEnd3 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'map:'</span> +(iEnd3 - iStart3)+<span class="string">'ms'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">let</span> arr4 = (<span class="keyword">new</span> <span class="built_in">Array</span>(TEST_SIZE)).fill(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> target4 = [];</span><br><span class="line"><span class="keyword">let</span> iStart4 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(index &lt; arr4.length) &#123;</span><br><span class="line">    target4.push(arr4[index]);</span><br><span class="line">    index++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iEnd4 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'while:'</span> +(iEnd4 - iStart4)+<span class="string">'ms'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for in</span></span><br><span class="line"><span class="keyword">let</span> arr5 = (<span class="keyword">new</span> <span class="built_in">Array</span>(TEST_SIZE)).fill(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> target5 = [];</span><br><span class="line"><span class="keyword">let</span> iStart5 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> obj <span class="keyword">in</span> arr5) &#123;</span><br><span class="line">    target5.push(arr5[obj]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iEnd5 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'forin:'</span> +(iEnd5 - iStart5)+<span class="string">'ms'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><blockquote>
<p>测试环境<br>机器 iMac (Retina 5K, 27-inch, Late 2015) 10.13.6 (17G65)3.2 GHz Intel Core i5<br>node v8.11.3<br>chrome  71.0.3578.98（正式版本） （64 位）<br>firefox 64.0 (64 位)<br>safair</p>
</blockquote>
<p><img src="https://i.loli.net/2019/01/30/5c51901ba3fee.png" alt="结果"></p>
<ul>
<li><p>谷歌浏览器中 ES6+ 的循环语法会普遍比传统的循环语法慢</p>
</li>
<li><p>不管是 for 循环还是 forEach v8 里面都差不多</p>
</li>
<li><p>对于 “枚举” 循环</p>
<p>  数组中应当避免查找空值或者是超出范围的值，这样会导致在原型链中的向上查找，很耗性能。这种循环方式会把所有的元素取出，并不停的迭代下一个，直到出现 undefined 或 null ，这样就出现的向上查找的情景。</p>
</li>
<li><p>对于 提前取数组长度也就是方法二 </p>
<p>  实际数组的 length 在每次循环中都会重新读区，并不会提前计算好，而是 v8 引擎最大限度的优化了对象取值的性能。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2019/01/19/2018总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/19/2018总结/" itemprop="url">
                  2018总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-19T19:37:43+08:00">
                2019-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ul>
<li>React</li>
<li>前端在交互、视觉上更多的探索</li>
<li>技术水平的提升：宽度和深度</li>
<li>技术类的书籍很多都开了头但没能读完 18 年能坚持读完</li>
</ul>
</blockquote>
<p>首先先看看 2017 年的立的 flag，现在看看好宽泛啊：</p>
<ul>
<li><p>react<br>  用 react 全家桶单独开发过项目也算是完成当初期望，但是下半年主要公司都花在 vue 上，这是始料不及的。</p>
</li>
<li><p>在用户体验方面<br>  目前在项目做作了了许多前端方面的最佳实践达到预期目标</p>
</li>
<li><p>前端水平<br>  明显感觉没有进步很大相对于前面两年，目前也分析了原因主要是下半年换工作到了上海加入了理想的团队反而有所放松。</p>
</li>
<li><p>读书<br>  是看了好多书嗯非技术的</p>
</li>
</ul>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>很高兴张鑫旭老师的内推加入了一个很棒很有爱的前端团队，工作内容的变化，行业的转变也带来了一些挑战，当然也很快融入进去。<br>从软件公司到互联网公司的转变，真正做到直面用户也给了我在用户体验方面有很大的提升。下半年主要的技术栈是 vue ，真香警告！ vue 做的真的是太有好了，每每发出 wc 还可以这样。</p>
<p>今年的文章写得太少了，社区方面也是。</p>
<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p>今年最大的 flag 就是可以生活和工作处理好！还有要学会演讲，因为团队分享是老是感觉力不从心， PPT 也是，当时完全忽略了这种技术以外的软技能，来到这边之后才发现。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/10/13/视频优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/13/视频优化/" itemprop="url">
                  HTML5 视频秒开优化-moov 前置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-13T18:04:00+08:00">
                2018-10-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本文是我部门的一次分享，张鑫旭老师也整理过相应文字版本我在补充下</p>
</blockquote>
<p>现在创意 H5 做的堪比电影，传统方式的动画、gif 已经满足不了性能需求，越来越多的内容正在以 HTML5 视频的方式呈现，随之而来的视频优化变得的越来越重要。HTML5 视频秒播优化的有很多方面，从服务器，cdn 部署接入，数据连接 / 获取，客户端缓存，出帧策略，到视频文件 I 帧位置等，今天从视频文件格式的角度介绍。</p>
<h2 id="一个活动"><a href="#一个活动" class="headerlink" title="一个活动"></a>一个活动</h2><p>在座诸位，请打开浏览器，新开一个标签页，打开开发者工具，切换到 network 面板 → Media 选项，然后 — 复制下面地址（天猫某活动备份地址）到地址栏，回车：<a href="http://ali-tmhly.h5.neone.com.cn/" target="_blank" rel="noopener">ali-tmhly.h5.neone.com.cn/</a> 。此时，你会看到一个名为 video2 的 mp4，前前后后发送了 3 次请求：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/16796dda9dfbf600?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片alt"></p>
<p>这是糟糕的！应该只有 1 次请求才是最佳的！</p>
<h2 id="3-次请求的原因"><a href="#3-次请求的原因" class="headerlink" title="3 次请求的原因"></a>3 次请求的原因</h2><p>一个 MP4 视频文件，不单单是视频内容，还有很多其他信息，尺寸，时长，字幕，版权信息等。</p>
<p>这些信息被放在一个一个的 box 中，换句话说就是，一个 MP4 文件由很多个 box 组成的，用以存储媒体信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/10/16796ddaa2978a85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片alt"></p>
<p>其中，有个与请求数有关的 box 名叫 MOOV BOX。</p>
<h3 id="MOOV-BOX"><a href="#MOOV-BOX" class="headerlink" title="MOOV BOX"></a>MOOV BOX</h3><p>Moov box 存放的是如何播放视频的信息，如尺寸和每秒的帧数，则存储在叫做 moov 的特殊 box 中。你可以认为 moov box 是某种意义上的 MP4 文件目录。<br>当你播放视频时，程序会查找 MP4 文件，定位 moov box 的位置，然后借此去查找视频和音频的起始位置来开始播放。<br>Box 可能以任意顺序排列，所以程序一开始并不知道 moov box 哪里。如果是本地播放，没有任何问题，因为你已经拥有整个视频文件；但如果在线观看，也就是流传输 HTML5 视频时，就会有问题了。</p>
<h3 id="读取-MOOV-过程"><a href="#读取-MOOV-过程" class="headerlink" title="读取 MOOV 过程"></a>读取 MOOV 过程</h3><p>浏览器直接发起 HTTP MP4 请求，读取响应 body 的开头，如果发现 moov 在开头，就接着往下读<br>mdat。如果发现开头没有，先读到 mdat，立马 RESET 这个连接，节省流量，通过 Range 头读取文件末尾数据，因为前面一个 HTTP 请求已经获取到了 Content-Length ，知道了 MP4 文件的整个大小，通过 Range 头读取部分文件尾部数据也是可以读取到的。<br>也就说，之所以上面天猫某活动 MP4 视频会发起 3 次请求，就是因为视频的 moov box 放在了文件末尾。</p>
<h3 id="为什么会放在后面"><a href="#为什么会放在后面" class="headerlink" title="为什么会放在后面"></a>为什么会放在后面</h3><p>因为在导出 视频文件是时候一般软件都是先写入 mdat 后写入 moov，因此绝大多数工具都会默认把 moov 数据放到 mdat 后边，比如 mp4writer，ffmpeg 等工具</p>
<h2 id="三、如何避免视频的3次请求"><a href="#三、如何避免视频的3次请求" class="headerlink" title="三、如何避免视频的3次请求"></a>三、如何避免视频的3次请求</h2><p>很简单，使用工具把 Moov box 提到视频的前面就好了。</p>
<ul>
<li><p>Handbrake<br>HandBrake 乃 Web MP4 视频优化工具不二之选，其中就有 moov box 前置优化 web 请求的功能。</p>
</li>
<li><p>ffmpeg<br>FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用 LGPL 或 GPL 许可证。它提供了录制、转换以及流化音视频的完整解决方案。</p>
</li>
</ul>
<p><code>ffmpeg -i 你的视频.mp4 -movflags faststart -acodec copy -vcodec copy 输出的视频.mp4</code></p>
<h2 id="优化之后"><a href="#优化之后" class="headerlink" title="优化之后"></a>优化之后</h2><p><img src="https://user-gold-cdn.xitu.io/2018/12/10/16796ddabf54be7a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片alt"></p>
<p>此时，视频请求就只有一次了，口说无凭，直接看证据，狠戳这个demo，起点某视频活动。</p>
<p>可以看到，加载的时候，就只会有 1 个请求。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>相关软件 </p>
<p><a href="https://pan.baidu.com/s/1yU0mi0eOcPcvtmeICeouZg" target="_blank" rel="noopener">链接</a>  密码: rm1f</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/04/17/硬件渲染了解一下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/17/硬件渲染了解一下/" itemprop="url">
                  硬件渲染了解一下
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T21:26:41+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>浏览器的渲染方式，主要分为两种，第一种是软件渲染，第二种是硬件渲染。如果绘制工作只是由 CPU 完成，那么称之为软件渲染，如果绘制工作由 GPU 完成，则称之为硬件渲染。软件渲染与硬件渲染有不同的缓存机制，只要我们合理利用，就能发挥出最好的效果。</p>
<h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><p>浏览器还有一种名为硬件渲染的渲染方式，它是使用 GPU 的硬件能力来帮助渲染页面,那么是怎么设置的？</p>
<ul>
<li>启用硬件加速<br>  在<code>chrome</code>的地址栏中输入<code>chrome://settings/</code>回车滚动页面到地步，点击<code>显示高级设置</code>再次滚动到页面地步，找到<code>使用硬件加速模式</code></li>
<li>开启gup硬件加速<br>  在<code>chrome</code>的地址栏中输入<code>chrome://flags/#disable-accelerated-video-decode</code>找到<code>硬件加速的视频解码</code>，点击<code>启用</code></li>
</ul>
<p>完成上面两步后重启浏览器</p>
<h2 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h2><p>大家都知道在页面性能优化的时候都会用到 <code>GPU 加速</code>、<code>硬件加速</code>类似方式，浏览器一帧（1000/16ms）会依次执行以下，减少或者避免 layout，paint 可以让页更加流畅：</p>
<blockquote>
<ol>
<li>JavaScript：JavaScript 实现动画效果，DOM 元素操作等。</li>
<li>Style（计算样式）：确定每个 DOM 元素应该应用什么 CSS 规则。</li>
<li>Layout（布局）：计算每个 DOM 元素在最终屏幕上显示的大小和位置。由于 web 页面的元素布局是相对的，所以其中任意一个元素的位置发生变化，都会联动的引起其他元素发生变化，这个过程叫 reflow。</li>
<li>Paint（绘制）：在多个层上绘制 DOM 元素的的文字、颜色、图像、边框和阴影等。</li>
<li>Composite（渲染层合并）：按照合理的顺序合并图层然后显示到屏幕上。</li>
</ol>
</blockquote>
<p>一个页面是由多个图层最后形成一个完整的合成层才被渲染出来效果就像这样：<br><img src="https://user-gold-cdn.xitu.io/2018/4/17/162d382466397a7a?w=973&amp;h=602&amp;f=png&amp;s=358760" alt="渲染图"></p>
<p>硬件渲染 WebKit 会依据指定条件决定将那些 RenderLayer 对象组合在一起形成一个新层并缓存在 GPU，这些新层我们统称为合成层（Compositing Layer）。这些合成层提升成独立的层，被独立出来之后，便不会再影响其他 dom 的布局。如果发生 偏移、透明度等等变换 GPU 要做的只是把更新的合成层进行相应的变换并送入 Compositor 重新合成即可，利用这个优点我们可以把页面中一些布局经常变换的 dom 提升到独立的层。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/17/162d39bcf891cd34?w=1742&amp;h=667&amp;f=png&amp;s=269284" alt=""></p>
<p>在上图中黄色边框表示放到了一个新的复合层（composited layer）中渲染，左侧的列表里列出页面里存在哪些渲染层，右侧的 Details 显示的是这些渲染层的详细信息，包括渲染层的大小、形成原因等。</p>
<h2 id="如何触发合成层"><a href="#如何触发合成层" class="headerlink" title="如何触发合成层"></a>如何触发合成层</h2><ol>
<li>根节点 document</li>
<li>HTML5 Video或者Canvas元素。</li>
<li>元素有一个 z-index 较低且包含一个复合层的兄弟元素</li>
<li>3D 或透视变换(perspective，transform) CSS 属性 比如常用的 （设置translateZ()、backface-visibility为hidden）</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>也就是上面第三条，英文原版是这么说</p>
<blockquote>
<p>Element has a sibling with a lower z-index which has a compositing layer (in other words the it’s rendered on top of a composited layer)</p>
</blockquote>
<p>意思是，如果有一个元素，它的兄弟元素在复合层中渲染，而这个兄弟元素的z-index比较小，那么这个元素（不管是不是应用了硬件加速样式）也会被放到复合层中。</p>
<p>所以用轮播、动画loading等页面的时候要注意下要遵循最小化影响原则，如果调试看到有很多 <code>黄色边框</code> 就要注意了。</p>
<blockquote>
<p>使用 3D 硬件加速提升动画性能时，最好给元素增加一个 z-index 属性，人为干扰复合层的排序，可以有效减少 chrome 创建不必要的复合层，提升渲染性能，移动端优化效果尤为明显。</p>
</blockquote>
<h2 id="关于-CSS3-will-change"><a href="#关于-CSS3-will-change" class="headerlink" title="关于 CSS3 will-change"></a>关于 CSS3 will-change</h2><p>前面说的那些有点hach，CSS3 will-change 才是正规军是属于 web 标准属性，兼容性这块 Chrome/FireFox/Opera 是支持的，他是提前通知浏览器元素将要做什么动画，让浏览器提前准备合适的优化设置，具体值：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 关键字值 */</span></span><br><span class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">auto</span>;</span><br><span class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">scroll-position</span>;</span><br><span class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">contents</span>;</span><br><span class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">transform</span>;        <span class="comment">/* &lt;custom-ident&gt;示例 */</span></span><br><span class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">opacity</span>;          <span class="comment">/* &lt;custom-ident&gt;示例 */</span></span><br><span class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">left</span>, <span class="selector-tag">top</span>;        <span class="comment">/* 两个&lt;animateable-feature&gt;示例 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局值 */</span></span><br><span class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure></p>
<p>will-change 虽然可以加速,但是不可滥用。。。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/03/30/函数式编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/30/函数式编程/" itemprop="url">
                   函数式编程(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-30T20:20:09+08:00">
                2018-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>函数式语言给了我一个全新的视角，从一个完全不同的方式去看待编程，开始会感到不自然，需要时间去适应。所有的定义都是基于函数，值不可更改，无状态，但是时间久了就会发现代码会更加简洁，而且容易复用。</p>
<h2 id="if-简化"><a href="#if-简化" class="headerlink" title="if 简化"></a>if 简化</h2><p>几乎每个if语句的实例都可以用一个等价的三元操作来替代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 典型的</span><br><span class="line">function saveCustomer(customer) &#123;</span><br><span class="line">  if (isCustomerValid(customer)) &#123;</span><br><span class="line">    database.save(customer)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    alert(&apos;customer is invalid&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 三元</span><br><span class="line">function saveCustomer(customer) &#123;</span><br><span class="line">  return isCustomerValid(customer)</span><br><span class="line">    ? database.save(customer)</span><br><span class="line">    : alert(&apos;customer is invalid&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// ES6 的写法</span><br><span class="line">const saveCustomer = customer =&gt;</span><br><span class="line">  isCustomerValid(customer)</span><br><span class="line">    ? database.save(customer)</span><br><span class="line">    : alert(&apos;customer is invalid&apos;)</span><br></pre></td></tr></table></figure>
<p>多层嵌套</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 多层 else-if</span><br><span class="line">function customerValidation(customer) &#123;</span><br><span class="line">  if (!customer.email) &#123;</span><br><span class="line">    return error(&apos;email is require&apos;)</span><br><span class="line">  &#125; else if (!customer.login) &#123;</span><br><span class="line">    return error(&apos;login is required&apos;)</span><br><span class="line">  &#125; else if (!customer.name) &#123;</span><br><span class="line">    return error(&apos;name is required&apos;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return customer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6 三元修正</span><br><span class="line">const customerValidation = customer =&gt;</span><br><span class="line">  !customer.email   ? error(&apos;email is required&apos;)</span><br><span class="line">  : !customer.login ? error(&apos;login is required&apos;)</span><br><span class="line">  : !customer.name  ? error(&apos;name is required&apos;)</span><br><span class="line">                    : customer</span><br></pre></td></tr></table></figure>
<p>现在就可以清楚地看到左侧定义的所有条件以及右侧返回的值。</p>
<h2 id="没有-for-循环"><a href="#没有-for-循环" class="headerlink" title="没有 for 循环"></a>没有 for 循环</h2><p>filter, map 和 reduce 可以满足所有情况, filter、map 和 reduce 共同点就是并不会对原数组做任何改动，结果都是生成一个新变量。</p>
<p>原始代码 获得小于 10个月的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const peoples = [</span><br><span class="line">  &#123; name: &apos;小明&apos;,     months: 84 &#125;,</span><br><span class="line">  &#123; name: &apos;小小明&apos;,   months: 24 &#125;,</span><br><span class="line">  &#123; name: &apos;小小小明&apos;, months: 4 &#125;</span><br><span class="line">]</span><br><span class="line">var children = []</span><br><span class="line">for (var i = 0; i &lt; peoples.length; i++) &#123;</span><br><span class="line">  if (peoples[i].months &lt; 10) &#123;</span><br><span class="line">    children.push(peoples[i].name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(children)</span><br></pre></td></tr></table></figure></p>
<p>将 if 语句提取到它自己的函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const isChildren = people =&gt; people.months &lt; 10</span><br><span class="line">var children = []</span><br><span class="line">for (var i = 0; i &lt; peoples.length; i++) &#123;</span><br><span class="line">  if (isChildren(peoples[i])) &#123;</span><br><span class="line">    children.push(peoples[i].name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个改变是从 people 类型的对象中提取转换（或映射）到名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const isChildren = people =&gt; people.months &lt; 10</span><br><span class="line">const getName = people =&gt; people.name</span><br><span class="line">var children = []</span><br><span class="line">for (var i = 0; i &lt; peoples.length; i++) &#123;</span><br><span class="line">  if (isChildren(peoples[i])) &#123;</span><br><span class="line">    children.push(getName(peoples[i]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步 使用 map 操作，最好地展示您的代码的可读性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const isChildren = people =&gt; people.months &lt; 10</span><br><span class="line">const getName = people =&gt; people.name</span><br><span class="line">const children =</span><br><span class="line">  peoples.filter(isChildren)</span><br><span class="line">      .map(getName)</span><br></pre></td></tr></table></figure>
<p>完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const isChildren = people =&gt; people.months &lt; 10</span><br><span class="line">const getName = people =&gt; people.name</span><br><span class="line">const getChildrenNames = peoples =&gt;</span><br><span class="line">  peoples.filter(isChildren)</span><br><span class="line">      .map(getName)</span><br><span class="line">const peoples = [</span><br><span class="line">    &#123; name: &apos;小明&apos;,     months: 84 &#125;,</span><br><span class="line">    &#123; name: &apos;小小明&apos;,   months: 24 &#125;,</span><br><span class="line">    &#123; name: &apos;小小小明&apos;, months: 4 &#125;</span><br><span class="line">]</span><br><span class="line">const children = getChildrenNames(peoples)</span><br><span class="line">console.log(children)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/03/14/一道面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/14/一道面试题/" itemprop="url">
                  一道面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-14T20:29:08+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>浏览器中输入<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 直到看到页面之间发生了什么？</p>
</blockquote>
<p>今天就说说根据这道题梳理自己的前端知识！</p>
<h2 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h2><p>解释 URL 是浏览器的活，所以首先要搞明白浏览器的工作方式。<br>浏览器是多进程的，有一个主控进程，进程可能包括主控进程，插件进程，GPU，tab 页（浏览器内核）等等，主要包括：</p>
<ul>
<li>Browser 进程：浏览器的主进程（负责协调、主控），只有一个</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
<li>GPU进程：最多一个，用于 3D 绘制</li>
<li>浏览器渲染进程（内核）：默认每个 Tab 页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白 tab 会合并成一个进程）</li>
</ul>
<p>浏览器渲染进程是多线程的，它有主要几大类子线程</p>
<ul>
<li>GUI 线程</li>
<li>JS 引擎线程</li>
<li>事件触发线程</li>
<li>定时器线程</li>
<li>网络请求线程</li>
</ul>
<p>输入URL后，从浏览器会进行解析，URL 一般包括几大部分：</p>
<ul>
<li>protocol，协议头，譬如有 http，https 等</li>
<li>host，主机域名或IP地址</li>
<li>port，端口号</li>
<li>path，目录路径</li>
<li>query，即查询参数</li>
<li>fragment，即 # 后的 hash 值，一般用来定位到某个位置</li>
</ul>
<p>每次网络请求时都需要开辟单独的线程进行,览器会根据解析出得协议，开辟一个网络线程，前往请求资源.</p>
<h2 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h2><p>网络请求之前会先都差缓存，HTTP 缓存有多种规则，根据是否需要重新向服务器发起请求来分类，将其分为强制缓存，对比缓存。</p>
<ul>
<li><p>强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起 http 请求</p>
</li>
<li><p>对比缓存（304）时，浏览器会向服务端发起 http 请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存，可以使用 <code>Ctrl + F5</code> 强制刷新可以使得对比缓存无效</p>
</li>
</ul>
<p>http1.0中的缓存控制：</p>
<ul>
<li>Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置 no-cache 时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容 http1.0，所以以前又被大量应用）</li>
<li>Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires 一般对应服务器端时间，如 Expires：Fri, 30 Oct 1998 14:19:41</li>
<li>If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-Modified-Since，而服务端的是 Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified 匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内</li>
</ul>
<p>http1.1中的缓存控制：</p>
<ul>
<li>Cache-Control：缓存控制头部，有no-cache、max-age等多种取值</li>
<li><p>Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age 是 Cache-Control 头部的值，不是独立的头部，譬如 Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算</p>
</li>
<li><p>If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-None-Match，而服务端的是 E-tag，同样，发出请求后，如果 If-None-Match 和 E-tag 匹配，则代表内容未变，通知浏览器使用本地缓存，和 Last-Modified 不同，E-tag 更精确，它是类似于指纹一样的东西，基于 FileEtag INode Mtime Size 生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</p>
</li>
</ul>
<p>强缓存判断依据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）Cache-Control =&gt; Cache-Control: max-age = 35600</span><br><span class="line">（http1.0）Expires =&gt; 服务器端的时间</span><br></pre></td></tr></table></figure>
<p>cache-control 中的 max-age 保存一个相对时间。例如 Cache-Control: max-age = 35600，表示浏览器收到文件后，缓存在35600s内均有效。如果同时存在 cache-control 和 Expires ，浏览器总是优先使用cache-control。<br>Max-Age 相比 Expires，Expires 使用的是服务器端的时间，但是有时候会有这样一种情况-客户端时间和服务端不同步。所以一般 http1.1 后不推荐使用 Expires。</p>
<p>对比缓存判断依据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）E-tag/If-None-Match</span><br><span class="line">（http1.0）Last-Modified/If-Modified-Since</span><br></pre></td></tr></table></figure>
<p>last-modified 是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送 if-modified-since 字段。服务器用本地 Last-modified 时间与 if-modified-since 时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。</p>
<p>E-tag：资源的实体标识（哈希字符串），当资源内容更新时，E-tag 会改变。服务器会判断E-tag是否发生变化，如果变化则返回新资源，否则返回304。<br>　　<br>如果同时带有 E-tag 和 Last-Modified，服务端会优先检查 E-tag</p>
<p>在浏览器接收到服务器响应后，会检测响应头部（Header），如果有nEtag 字段，那么浏览器就会将本次缓存写入硬盘中。
　　
　　</p>
<h2 id="开启线程发出请求"><a href="#开启线程发出请求" class="headerlink" title="开启线程发出请求"></a>开启线程发出请求</h2><ul>
<li>dns 查询</li>
</ul>
<p>dns 是通常是完成域名到 ip 的映射，大致流程：</p>
<ul>
<li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host</li>
<li>如果本地没有，就向 dns 域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的 IP</li>
</ul>
<p>dns 解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑 <code>dns-prefetch</code> 优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a 标签的 DNS 预解析 默认是开启的 但是当 使用 https 的时候是默认关闭的需要手动开启 a 标签的预解析</span><br><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;    </span><br><span class="line"></span><br><span class="line">开启 dns 预解析</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;IP地址&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>tcp/ip 请求</li>
</ul>
<p>首先会建立 tcp 连接</p>
<ul>
<li>建立链接（三次握手）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端发个请求“开门呐，我要进来”给服务器</span><br><span class="line">服务器发个“进来吧，我去给你开门”给客户端</span><br><span class="line">客户端有很客气的发个“谢谢，我要进来了”给服务器</span><br></pre></td></tr></table></figure>
<p>建立连接也会断开连接只是不是这时候断开，先提前说下</p>
<ul>
<li>断开连接（四次挥手）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端发个“时间不早了，我要走了”给服务器，等服务器起身送他</span><br><span class="line">服务器听到了，发个“我知道了，那我送你出门吧”给客户端，等客户端走</span><br><span class="line">服务器把门关上后，发个“我关门了”给客户端，然后等客户端走（尼玛~矫情啊）</span><br><span class="line">客户端发个“我知道了，我走了”，之后自己就走了</span><br></pre></td></tr></table></figure>
<p>由于 tcp/ip 对链接有并发的控制，所以有甚多针对请求的优化，比如合并请求的雪碧图。<br>关于这里有涉及到五层网络协议，就是从客户端发出 http 请求到服务器接收，中间会经过一系列的流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用层（dns,http） DNS 解析成IP并发送 http 请求</span><br><span class="line">传输层（tcp/ip）建立连接</span><br><span class="line">网络层（ip）IP 寻址</span><br><span class="line">数据链层（ppp）封装成二进制帧</span><br><span class="line">物理层 物理传输</span><br></pre></td></tr></table></figure></p>
<p>其实也有一个完整的 OSI 七层框架，与之相比，多了会话层、表示层。</p>
<p>浏览器向服务器发送 HTTP 请求。</p>
<ul>
<li>http 报文结构</li>
</ul>
<p>报文一般包括了：通用头部，请求/响应头部，请求/响应体</p>
<ul>
<li>通用头部<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Request Url: 请求的web服务器地址</span><br><span class="line">Request Method: 请求方式</span><br><span class="line">（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</span><br><span class="line">Status Code: 请求的返回状态码，如200代表成功</span><br><span class="line">Remote Address: 请求的远程服务器地址（会转为IP）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>code 状态码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx——指示信息，表示请求已接收，继续处理</span><br><span class="line">2xx——成功，表示请求已被成功接收、理解、接受</span><br><span class="line">3xx——重定向，要完成请求必须进行更进一步的操作</span><br><span class="line">4xx——客户端错误，请求有语法错误或请求无法实现</span><br><span class="line">5xx——服务器端错误，服务器未能实现合法的请求</span><br></pre></td></tr></table></figure></p>
<p>请求/响应头部</p>
<p>常用的请求头部（部分）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Accept: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的 Content-Type ）</span><br><span class="line">Accept-Encoding：浏览器支持的压缩类型,如 gzip 等,超出类型不能接收</span><br><span class="line">Content-Type：客户端发送出去实体内容的类型</span><br><span class="line">Cache-Control: 指定请求和响应遵循的缓存机制，如 no-cache</span><br><span class="line">If-Modified-Since：对应服务端的 Last-Modified ，用来匹配看文件是否变动，只能精确到 1s 之内，http1.0中</span><br><span class="line">Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</span><br><span class="line">Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</span><br><span class="line">If-None-Match：对应服务端的 E-tag，用来匹配文件内容是否改变（非常精确），http1.1 中</span><br><span class="line">Cookie: 有 cookie 并且同域访问时会自动带上</span><br><span class="line">Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如 keep-alive</span><br><span class="line">Host：请求的服务器 URL</span><br><span class="line">Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin 比 Referer 更尊重隐私</span><br><span class="line">Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</span><br><span class="line">User-Agent：用户客户端的一些必要信息，如 UA 头部等</span><br></pre></td></tr></table></figure>
<p>常用的响应头部（部分）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: 服务器端允许的请求 Headers</span><br><span class="line">Access-Control-Allow-Methods: 服务器端允许的请求方法</span><br><span class="line">Access-Control-Allow-Origin: 服务器端允许的请求 Origin 头部（譬如为*）</span><br><span class="line">Content-Type：服务端返回的实体内容的类型</span><br><span class="line">Date：数据从服务器发送的时间</span><br><span class="line">Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档</span><br><span class="line">Last-Modified：请求资源的最后修改时间</span><br><span class="line">Expires：应该在什么时候认为文档已经过期,从而不再缓存它</span><br><span class="line">Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control 后有效</span><br><span class="line">E-tag：请求变量的实体标签的当前值</span><br><span class="line">Set-Cookie：设置和页面关联的 cookie，服务器通过这个头部把 cookie 传给客户端</span><br><span class="line">Keep-Alive：如果客户端有 keep-alive，服务端也会有响应（如 timeout=38 ）</span><br><span class="line">Server：服务器的一些相关信息</span><br></pre></td></tr></table></figure>
<p>一般来说，请求头部和响应头部是匹配分析的。</p>
<p>譬如，请求头部的 Accept 要和响应头部的 Content-Type 匹配，否则会报错</p>
<p>譬如，跨域请求时，请求头部的 Origin 要匹配响应头部的 Access-Control-Allow-Origin，否则会报跨域错误</p>
<p>譬如，在使用缓存时，请求头部的 If-Modified-Since、If-None-Match 分别和响应头部的Last-Modified、E-tag对应</p>
<h2 id="服务器接收到请求"><a href="#服务器接收到请求" class="headerlink" title="服务器接收到请求"></a>服务器接收到请求</h2><ul>
<li>负载均衡</li>
</ul>
<p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡。用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了 nginx 控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的 HTTP 响应，并将它反馈给用户</p>
<ul>
<li><p>后台的处理</p>
</li>
<li><p>cookie<br>cookie 是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用.<br>由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化,例如：</p>
</li>
<li><p>将静态资源分组，分别放到不同的子域名下</p>
</li>
<li>而子域名请求时，是不会带上父级域名的cookie的，所以就避免了浪费</li>
</ul>
<p>说到了多域名拆分，这里再提一个问题，那就是：</p>
<p>在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）此时就需要用到一种优化方案：dns-prefetch（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）</p>
<p>说到 cookie 就要把 localStorage，sessionStorage 区分下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</span><br><span class="line"></span><br><span class="line">cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。</span><br><span class="line"></span><br><span class="line">存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带cookie，所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到5M或更大。</span><br><span class="line"></span><br><span class="line">数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</span><br><span class="line"></span><br><span class="line">作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。</span><br></pre></td></tr></table></figure>
<ul>
<li>gzip 压缩</li>
</ul>
<p>gzip 是 GNU zip的缩写，它是一个 GNU 自由软件的文件压缩程序。一般服务器都会开启 gzip 这样可以减少带宽消耗。但是 HTTP 压缩需要成本。Web 服务器获得需要的内容，然后压缩它，最后将它发送到客户端。如果内容不能被进一步压缩，你只是在浪费 CPU 做无意义的任务，采用 HTTP 压缩已经被过压缩的东西并不能使它更小。事实上，添加标头，压缩字典，并校验响应体实际上使它变得更大。</p>
<ul>
<li>长连接与短连接</li>
</ul>
<p>首先看tcp/ip层面的定义：</p>
<ul>
<li>长连接：一个 tcp/ip 连接上可以连续发送多个数据包，在 tcp 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li>
<li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li>
</ul>
<p>然后在http层面：</p>
<ul>
<li>http1.0中，默认使用的是短连接，也就是说，浏览器每进行一次 http 操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li>
<li>http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 http 的 tcp 连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li>
</ul>
<p>注意： keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</p>
<ul>
<li>https</li>
</ul>
<p>简单来看，https 与 http 的区别就是： 在请求前，会建立 ssl 链接，确保接下来的通信都是加密的，无法被轻易截取分析。如果要将网站升级成 https，需要后端支持（后端需要申请证书等），然后 https 的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说 http2.0 配合 https 的体验更佳（因为 http2.0 更快了）SSL/TLS 的握手流程握手流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器建立 SSL 连接，像服务端 发送一个随机数和加密方法</span><br><span class="line">2. 服务端选取加密方法回复一个随机数并将自己的证书发送过去</span><br><span class="line">3. 浏览器收到证书后</span><br><span class="line">    - 验证证书合法性</span><br><span class="line">    - 用户街道证书后生成新的随机数，然后证书中的公钥以及指定的加密方法加密发送</span><br><span class="line">    - 通过一定的算法生成 HTTP 链接数据传输的对称加密 key</span><br><span class="line">    - 使用约定好的算法计算握手消息，并使用生成的 key 对消息进行加密，最后将之前生成的所有信息发送给服务端。 </span><br><span class="line">4. 服务端收到浏览器的回复</span><br><span class="line">    - 利用已知的加解密方式与自己的私钥进行解密</span><br><span class="line">    - 和浏览器相同规则生成 key</span><br><span class="line">    - 使用 key 解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</span><br><span class="line">    - 使用 key 加密一段握手消息，发送给浏览器</span><br><span class="line">5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束</span><br></pre></td></tr></table></figure>
<ul>
<li>http 2.0</li>
</ul>
<p>http2.0 它相当于是 http 的下一代规范，与http1.1的显著不同点：</p>
<ul>
<li>http1.1 中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来</li>
<li>ttp2.0 中，一个 tcp/ip 请求可以请求多个资源，也就是说，只要一次 tcp/ip 请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li>
</ul>
<p>http2.0的一些特性：</p>
<ul>
<li>多路复用（即一个tcp/ip连接可以请求多个资源）</li>
<li>首部压缩（http头部压缩，减少体积）</li>
<li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li>
<li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li>
<li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li>
</ul>
<p>注意：HTTP2.0 的多路复用和 HTTP1.1 中的长连接复用的区别就是：</p>
<p>HTTP/1.1 Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞。</p>
<p>HTTP/2 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</p>
<ul>
<li><p>浏览器接收响应</p>
</li>
<li><p>构建渲染树</p>
</li>
</ul>
<p>浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树。</p>
<ul>
<li>HTML解析，构建DOM</li>
</ul>
<p>解析 HTML 到构建出DOM当然过程可以简述如下：</p>
<p><code>Bytes → characters → tokens → nodes → DOM</code></p>
<ul>
<li>生成CSS规则</li>
</ul>
<p>CSS 规则树的生成也是类似。简述为：</p>
<p><code>Bytes → characters → tokens → nodes → CSSOM</code></p>
<ul>
<li>渲染</li>
</ul>
<p>布局是由 CPU 处理的，而绘制则是由 GPU 完成的,GPU 会对我们的渲染层作缓存，如果我们把那些一直发生大量重排重绘的元素提取出来，单独触发一个渲染层，那样这个元素不就不会“连累”其他元素一块重绘。<br>Video 元素、WebGL、Canvas、CSS3 3D、CSS滤镜、z-index 大于某个相邻节点的元素都会触发新的 Layer，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个 gif 图，gif 图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。所以这需要通过特殊的方式来强制 gif 图属于自己一个图层，就是给某个元素加上下面的样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateZ</span>(0);</span><br><span class="line"><span class="selector-tag">backface-visibility</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure></p>
<p>也会触发渲染层，把容易触发重排重绘的元素单独触发渲染层，让它与那些“静态”元素隔离，让GPU分担更多的渲染工作，我们通常把这样的措施成为硬件加速，或者是GPU加速。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Style：该区域为样式计算阶段，浏览器会根据选择器（就是CSS选择器，如.td）计算出哪些节点应用哪些CSS规则，然后计算出每个节点的最终样式并应用到节点上。</span><br><span class="line"></span><br><span class="line">Layout：该区域为布局计算阶段，浏览器会在该过程中根据节点的样式规则来计算它要占据的空间大小以及在屏幕中的位置。</span><br><span class="line"></span><br><span class="line">Paint：该区域为绘制阶段，浏览器会先创建绘图调用的列表，然后填充像素。绘制阶段会涉及到文本、颜色、图像、边框和阴影，基本上包括了每个可视部分。绘制一般是在多个图层（用过Photoshop等图片编辑软件的童鞋一定很眼熟图层这个词，这里的图层的含义其实是差不多的）上完成的。</span><br><span class="line"></span><br><span class="line">Composite：该区域为合成阶段，浏览器将多个图层按照正确顺序绘制到屏幕上。</span><br></pre></td></tr></table></figure>
<p>如果动态修改了 DOM 或 CSS，就会重新布局（Layout）或渲染（Repaint）这里 Layou t和 Repaint 的概念是有区别的：</p>
<ul>
<li><p>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</p>
</li>
<li><p>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</p>
</li>
</ul>
<p>什么会引起回流？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.页面渲染初始化</span><br><span class="line"></span><br><span class="line">2.DOM结构改变，比如删除了某个节点</span><br><span class="line"></span><br><span class="line">3.render树变化，比如减少了padding</span><br><span class="line"></span><br><span class="line">4.窗口resize</span><br><span class="line"></span><br><span class="line">5.改变字体大小会引发回流</span><br><span class="line"></span><br><span class="line">6.最复杂的一种：获取某些属性，引发回流</span><br><span class="line">很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</span><br><span class="line">    (1) offset(Top/Left/Width/Height)</span><br><span class="line">    (2) scroll(Top/Left/Width/Height)</span><br><span class="line">    (3) cilent(Top/Left/Width/Height)</span><br><span class="line">    (4) width,height</span><br><span class="line">    (5) 调用了getComputedStyle()或者IE的currentStyle</span><br></pre></td></tr></table></figure>
<p>回流一定伴随着重绘，重绘却可以单独出现</p>
<p>所以一般会有一些优化方案，如：</p>
<ul>
<li>减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新</li>
<li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document</li>
<li>避免多次读取offset等属性。无法避免则将它们缓存到变量</li>
<li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li>
</ul>
<p>最后如果想要知道每个CSS属性将会对哪个阶段产生怎样的影响，请去 <a href="https://csstriggers.com/" target="_blank" rel="noopener">CSS Triggers</a>，该网站详细地说明了每个CSS属性会影响到哪个阶段。</p>
<ul>
<li>关闭TCP连接或继续保持连接</li>
</ul>
<p>通过四次挥手关闭连接</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/03/02/文字避让/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/02/文字避让/" itemprop="url">
                  文字避让
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T20:58:22+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>webGis 经常会遇到地图上标记文字问题，但是文字空间不够时，就会造成文字重叠显示混乱的现象，导致效果很不好，下面就说说解决方案。</p>
<h2 id="文字避让"><a href="#文字避让" class="headerlink" title="文字避让"></a>文字避让</h2><p>文字标注算法是 GIS 中最复杂（NP）的问题之一，本篇将介绍四分位模型算法。<br>关于文字在地图上的坐标是经纬度坐标根据墨卡托转换而来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;南京市&quot;,//要显示的文字</span><br><span class="line">    &quot;lon&quot;: 118.15,</span><br><span class="line">    &quot;lat&quot;: 32.89,</span><br><span class="line">    &quot;pixel&quot;: &#123; //像素坐标</span><br><span class="line">      &quot;x&quot;: 968,</span><br><span class="line">      &quot;y&quot;: 736</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>求出每段文字矩形的实际大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ctx = this.container.getContext(&apos;2d&apos;); // canvas 上下文</span><br><span class="line">let width= ctx.measureText(name).width;</span><br></pre></td></tr></table></figure>
<p>通过 measureText 得到每个文字的宽度，canvas 并没有直接获取文字的方法，那文字的高度如何的得到呢？</p>
<p>我们通过反复测试发现 canvas 的 font 等于 “13px Arial” 字体的时候，文字的高度大概是 fontSize 的 1.1 倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let fontSize = parseInt(ctx.font);</span><br><span class="line">let height = fontSize * 1.1;</span><br></pre></td></tr></table></figure>
<p>文字的宽度和高度得到后，我们就可以创建文字矩形的坐标系了。</p>
<p>所谓四分位模型，每一个标记点都有上下左右四个放文字的位子，如果左边放不下，那就放右边试试，还不行就放到下面试试，以此类推</p>
<p>创建右侧虚拟矩形坐标描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_getLeftAnchor() &#123;</span><br><span class="line">    let x = this.center.x - this.radius - this.textReact.width,</span><br><span class="line">        y = this.center.y - this.textReact.height / 2,</span><br><span class="line">        diam = this.radius * 2,</span><br><span class="line">        maxH = diam &gt; this.textReact.height ? diam : this.textReact.height; //矩形的高度</span><br><span class="line">    return &#123;</span><br><span class="line">        x,</span><br><span class="line">        y,</span><br><span class="line">        minX: x,</span><br><span class="line">        maxX: this.center.x + this.radius,</span><br><span class="line">        minY: this.center.y - maxH / 2,</span><br><span class="line">        maxY: this.center.y + maxH / 2</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以此类推，描述下面、左面、上面的虚拟矩形坐标。</p>
<ul>
<li>判断碰撞</li>
</ul>
<p>判断两个矩形是否覆盖相交，根据矩形的 minX,maxX,minY,maxY 判断相交，原理比较简单，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断分位是否相交</span><br><span class="line"> * @param &#123;*&#125; target </span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">isAnchorMeet(target) &#123;</span><br><span class="line">    let react = this.getCurrentRect(),</span><br><span class="line">        targetReact = target.getCurrentRect();</span><br><span class="line">    if ((react.minX &lt; targetReact.maxX) &amp;&amp; (targetReact.minX &lt; react.maxX) &amp;&amp;</span><br><span class="line">        (react.minY &lt; targetReact.maxY) &amp;&amp; (targetReact.minY &lt; react.maxY)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>创建虚拟文字集合对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let labels = pixels.map((val) =&gt; &#123;</span><br><span class="line">    let radius = val.pixel.radius + this.style.normal.borderWidth; //圆点半径</span><br><span class="line">    return new Label(val.pixel.x, val.pixel.y, radius, fontSize, byteWidth, val.name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>递归遍历虚拟文字集合、判断是否与其他相交，如果有相交就移动当前文字位子，直到不相交为止。当找不到合适位置时，就选择隐藏当前文字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    var meet = false; //本轮是否有相交</span><br><span class="line">    for (let i = 0; i &lt; labels.length; i++) &#123;</span><br><span class="line">        let temp = labels[i];</span><br><span class="line">        for (let j = 0; j &lt; labels.length; j++) &#123;</span><br><span class="line">            if (i != j &amp;&amp; temp.show &amp;&amp; temp.isAnchorMeet(labels[j])) &#123;</span><br><span class="line">                temp.next();</span><br><span class="line">                meet = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; while (meet);</span><br></pre></td></tr></table></figure>
<ul>
<li>绘画文字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">labels.forEach(function (item) &#123;</span><br><span class="line">    if (item.show) &#123; //是否显示</span><br><span class="line">        let pixel = item.getCurrentRect();</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.fillText(item.text, pixel.x, pixel.y);</span><br><span class="line">        ctx.fill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/01/26/git-工作流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/26/git-工作流/" itemprop="url">
                  git 工作流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-26T21:38:02+08:00">
                2018-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>git 是目前最流行的源代码管理工具，Git 的确可以在各个方面做很多事情，然而任然存在采用何种分支管理的问题，Git 分支管理并没有普遍适用的最佳做法，只有对每个团队和项目而言最适合的工作流。<br>git 的操作还是有一定复杂度的，错误的操作影响也比较大，异步小心就会导致部分代码丢失，还很难查到具体出问题的时间点和功能点。</p>
<p>我们采用的是 git-flow 流程,包含 4 类分支，分别是 master、develop、新功能分支（feature）和 hotfix。</p>
<h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>在 github 中创建一个新的仓库，只有一个 master 分支</p>
<h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><p>每次开发新功能，都应该从当前主开发分支新建一个功能分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature-wz-qx</span><br></pre></td></tr></table></figure>
<h2 id="提交分支"><a href="#提交分支" class="headerlink" title="提交分支"></a>提交分支</h2><p>模块开发差不多，提交代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add -F</span><br><span class="line">git commit -m &apos;add xxxxx&apos;</span><br></pre></td></tr></table></figure>
<p>关于 commit 完整的 log 由 类别(必须)  简短描述(必须) 详细描述(可选) 三部分组成：</p>
<ul>
<li>类别<ul>
<li>add 增加</li>
<li>fix 修复 bug</li>
<li>change 修改</li>
<li>del 移除</li>
<li>refactor 代码重构</li>
<li>docs 文档</li>
</ul>
</li>
</ul>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;add xxxxx&apos;</span><br></pre></td></tr></table></figure>
<p>如果增加详细描述，具体内容前空一行，兼容 Markdown。<br>还可以可以配合 <a href="https://gitmoji.carloscuesta.me/" target="_blank" rel="noopener">gitmoji</a> 强化信息可读性。</p>
<h2 id="合并提交记录"><a href="#合并提交记录" class="headerlink" title="合并提交记录"></a>合并提交记录</h2><p>为了避免太多的 commit 而造成版本控制的混乱，通常我们推荐将这些 commit 合并成一个。假如我们提交了四次记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">commit 14c69cf825c17bd3e48154994e6f722db251fcfb</span><br><span class="line">Author: lennonover &lt;lennonover@163.com&gt;</span><br><span class="line">Date:   Tue Jan 23 16:38:57 2018 +0800</span><br><span class="line"></span><br><span class="line">    add forth </span><br><span class="line"></span><br><span class="line">commit 969161b68ab3b479fc52a26c4f053395ce4f3c63</span><br><span class="line">Author: lennonover &lt;lennonover@163.com&gt;</span><br><span class="line">Date:   Tue Jan 23 16:01:12 2018 +0800</span><br><span class="line"></span><br><span class="line">    add third </span><br><span class="line"></span><br><span class="line">commit 44adff48febeb65e5f89e2dc18ecc3ba7c9c31ba</span><br><span class="line">Author: lennonover &lt;lennonover@gmail.com&gt;</span><br><span class="line">Date:   Tue Jan 23 15:56:27 2018 +0800</span><br><span class="line"></span><br><span class="line">    add second </span><br><span class="line"></span><br><span class="line">commit a897c7ac82eb2de3e8268454d19f2ec91a5be9bd</span><br><span class="line">Author: lennonover &lt;lennonover@gmail.com&gt;</span><br><span class="line">Date:   Tue Jan 23 15:56:04 2018 +0800</span><br><span class="line"></span><br><span class="line">    add first</span><br></pre></td></tr></table></figure>
<p>如何把四次合并到一起，并且只保留 最后一次 的 Git message 呢？推荐 git rebase 进行合并操作。</p>
<p>合并最后四个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure>
<p>git 会打开一个互动界面，方便用户对历史提交进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pick 969161b add first</span><br><span class="line">pick 14c69cf add second </span><br><span class="line">pick b246936 add third</span><br><span class="line">pick 5b192dc add forth </span><br><span class="line"></span><br><span class="line"># Rebase 44adff4..5b192dc onto 44adff4 (4 command(s))</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = 使用该提交</span><br><span class="line"># r, reword = 使用该提交，但需要编辑提交信息</span><br><span class="line"># e, edit = 使用该提交，但此处暂停并提供修改机会</span><br><span class="line"># s, squash = 使用该提交，但合并到上一个提交记录中</span><br><span class="line"># f, fixup = 类似 squash，但丢弃当前提交记录的提交信息</span><br><span class="line"># x, exec = 执行 shell 命令</span><br><span class="line"># d, drop = 移除当前提交</span><br></pre></td></tr></table></figure>
<p>我们需要把前面的 pick 改为 squash 这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pick 969161b add first</span><br><span class="line">squash 14c69cf add second </span><br><span class="line">squash b246936 add third</span><br><span class="line">squash 5b192dc add forth</span><br></pre></td></tr></table></figure>
<p>完成后，使用 <code>:wq</code> 保存并退出。这个时候则需要在下一步中对这 4 条 commit 信息进行修改和保存(如果 fixup 的话，则直接丢弃其它记录，省去下一步操作)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># This is a combinatin of 4 commits.</span><br><span class="line"># This is the 1st commit message:</span><br><span class="line">add first </span><br><span class="line"># This is the commit message #2:</span><br><span class="line">add second </span><br><span class="line"># This is the commit message #3:</span><br><span class="line">add third</span><br><span class="line"># This is the commit message #4:</span><br><span class="line">add forth</span><br></pre></td></tr></table></figure>
<p>使用 <code>:wq</code> 后，通过 git log 可以看到仅剩一条 commit 记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commit c2391a59bf51240a60ab4c8455b251cff1ec3cdd</span><br><span class="line">Author: lennonover &lt;lennonover@163.com&gt;</span><br><span class="line">Date:   Wed Jan 24 15:01:12 2018 +0800</span><br><span class="line"></span><br><span class="line">    add stylelint-0.0.3</span><br></pre></td></tr></table></figure>
<p>rebase 的风险：</p>
<p>当待合并 commit 记录中杂糅着他人的 commit 记录，此时就不可以再对这部分 commit 记录做合并操作。</p>
<p>但只要新开分支且保持分支独立开发，杂糅的情况就不存在。</p>
<h2 id="推送到仓库"><a href="#推送到仓库" class="headerlink" title="推送到仓库"></a>推送到仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin feature-wz-qx</span><br></pre></td></tr></table></figure>
<h2 id="提交-Merge-Request-申请"><a href="#提交-Merge-Request-申请" class="headerlink" title="提交 Merge Request 申请"></a>提交 Merge Request 申请</h2><p>请求相关同学从你的 feature-wz-qx 合并分支</p>
<ul>
<li>提交 Merge Request：</li>
</ul>
<p>通过「＋Create Merge Request」按钮创建一个 Merge Request；</p>
<ul>
<li>指定「Assignee」：</li>
</ul>
<p>指定需要 review 你代码的同学，禁止指定自己；</p>
<ul>
<li>更改「Target branch」：</li>
</ul>
<p>改变为需要合并进去的目标分支；</p>
<ul>
<li>设置合并后删除被合并分支的选项：</li>
</ul>
<p>勾选「Remove source branch when merge request is accepted.」选项，在合并完成后删除源分支，控制分支总数量；</p>
<ul>
<li>提交合并请求</li>
</ul>
<p>完成上述设置后，相关同学将会收到邮件通知，此时可进入 GitLab 进行 code review。如果发现问题则对问题代码进行点评并拒绝关闭申请，反之则通过合并申请。</p>
<h2 id="修复-Bug"><a href="#修复-Bug" class="headerlink" title="修复 Bug"></a>修复 Bug</h2><p>发现 bug 了,从 develop 分支上新建分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hotfix/xxx develop</span><br></pre></td></tr></table></figure>
<p>改完推送到仓库后提交 Merge Request 申请</p>
<h2 id="减少冲突"><a href="#减少冲突" class="headerlink" title="减少冲突"></a>减少冲突</h2><p>从我们的工作流程上来说，代码合并导致的问题，一般都发生在特性、修复分支合并到 master 或者 develop 的时候，因为这个时候开始，才是真正与其他分支汇合，不同的改动会发生冲突。而且合并没法完全避免，我们只能去思考如何减少合并冲突。</p>
<ul>
<li>合理的分工，人员职责划分尽量清晰，减少互相之间的交叉，减少多个人同时改动同一份代码的几率</li>
<li>合适的合并工具</li>
<li>合并后的代码检查</li>
<li>公共代码改动，要通知各使用方变化点</li>
<li>code review</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/lennonover/2018/01/15/npm-script/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lennonover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lennonover">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/15/npm-script/" itemprop="url">
                  npm script
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T23:45:36+08:00">
                2018-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>读书少了最近才看到这篇文章 <a href="https://www.keithcirkel.co.uk/why-we-should-stop-using-grunt/" target="_blank" rel="noopener">Why we should stop using Grunt &amp; Gulp</a>。文章中笔者建议大家使用 npm 作为替代方案，绝对要打 call。npm 的 scripts 配置可以更简单的实现这些构建工具的所有功能。确实，npm script 相比 grunt、gulp 之类的构建工具简单很多，它消除了这些构建工具所带来的抽象层，并带给我们更大的自由度。而且随着社区的发展，各种基础工具你都可以信手拈来，只要你会使用 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npmjs.com</a> 去搜索，或者去 <a href="https://libraries.io/" target="_blank" rel="noopener">libraries.io</a> 上搜索（当然我们公司的工作流还是在农耕火种时代。</p>
<h2 id="npm-script"><a href="#npm-script" class="headerlink" title="npm script"></a>npm script</h2><p>npm 为我们提供了快速创建 package.json 文件的命令 npm init，执行该命令会问几个基本问题，如包名称、版本号、作者信息、入口文件、仓库地址、许可协议等，多数问题已经提供了默认值。</p>
<p>npm 允许在 package.json 文件里面，使用 scripts 字段定义脚本命令，而执行它的是 npm 核心命令之一的 npm run-script 命令（简称 npm run ），npm run 就会自动新建一个 Shell 并且可以从 package.json 中解析出 scripts 对象，然后将该对象的键作为 npm run 的第一个参数，它会在操作系统的默认终端中执行该键对应的命令。例如下面的 package.json：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'name'</span>: <span class="string">'hello-npm-script'</span>,</span><br><span class="line">  <span class="string">'version'</span>: <span class="string">'0.1.0'</span>,</span><br><span class="line">  <span class="string">'main'</span>: <span class="string">'index.js'</span>,</span><br><span class="line">  <span class="string">'scripts'</span>: &#123;</span><br><span class="line">    <span class="string">'lint:js'</span>: <span class="string">'eslint *.js'</span>,</span><br><span class="line">    <span class="string">'lint:css'</span>: <span class="string">'stylelint *.less'</span>,</span><br><span class="line">    <span class="string">'test'</span>: <span class="string">'npm run lint:js &amp;&amp; npm run lint:css'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果运行 <code>npm run lint:js</code> ，npm 将在终端中执行 <code>eslint *.js</code>。执行 <code>npm run xxx</code> 时会将 <code>node_modules/.bin</code> 加入终端的 PATH 环境变量中，这样你就可以直接运行那些作为依赖安装的二进制模块，也就是说你不需要 <code>./node_modules/.bin/eslint **.js</code> 或 <code>$(npm bin)/eslint **.js</code> 这样来指定命令的路径。</p>
<p>如果运行 <code>npm run test</code> 则表示子命令的执行顺序是先 <code>lint:js</code> 后  <code>lint:css</code> 来，实现了多个 npm script 串行执行。</p>
<p>由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符 也就是 <code>*</code>。</p>
<h2 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h2><p>npm 可以在 scripts 中为任何可执行的命令指定 <code>pre-</code> 和 <code>post-</code> 钩子。例如，当运行 <code>npm run lint:js</code> 时，即便是没有在 scripts 中定义对应的 <code>pre-</code> 命令，npm 也会首先执行 <code>npm run prelint:js</code>，接着才是 <code>npm run lint:js</code>，最后是 <code>npm run postlint:js</code>。</p>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p><code>--</code> 是 npm 用来传递参数的，例如 <code>npm run lint:js -- a.js</code> 将运行 <code></code>eslint *.js a.js`</p>
<h2 id="命令行自动补全"><a href="#命令行自动补全" class="headerlink" title="命令行自动补全"></a>命令行自动补全</h2><ul>
<li><p>不带任何参数运行 npm run 能列出 scripts 对象中定义的所有命令，，再结合管道操作符、less 命令（ less 是 linux 里面的工具）</p>
</li>
<li><p>npm 自身也提供了自动完成工具 <a href="https://docs.npmjs.com/cli/completion" target="_blank" rel="noopener">completion</a></p>
</li>
</ul>
<h2 id="跨平台运行"><a href="#跨平台运行" class="headerlink" title="跨平台运行"></a>跨平台运行</h2><ul>
<li><p>使用 <a href="http://www.yolinux.com/TUTORIALS/unix_for_dos_users.html" target="_blank" rel="noopener">跨平台的命令</a></p>
</li>
<li><p>使用 node packages 。可以使用 node packages 来取代 shell 命令。</p>
</li>
</ul>
<h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>  因为 JSON 规范不支持添加注释，所以不能在 package.json 里添加注释。</p>
<h2 id="常用脚本"><a href="#常用脚本" class="headerlink" title="常用脚本"></a>常用脚本</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除目录</span></span><br><span class="line"><span class="string">"clean"</span>: <span class="string">"rimraf dist/*"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地搭建一个 HTTP 服务</span></span><br><span class="line"><span class="string">"serve"</span>: <span class="string">"http-server -p 9090 dist/"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开浏览器</span></span><br><span class="line"><span class="string">"open:dev"</span>: <span class="string">"opener http://localhost:9090"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时刷新</span></span><br><span class="line"> <span class="string">"livereload"</span>: <span class="string">"live-reload --port 9091 dist/"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 HTML 文件</span></span><br><span class="line"><span class="string">"build:html"</span>: <span class="string">"jade index.jade &gt; dist/index.html"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要 CSS 文件有变动，就重新执行构建</span></span><br><span class="line"><span class="string">"watch:css"</span>: <span class="string">"watch 'npm run build:css' assets/styles/"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要 HTML 文件有变动，就重新执行构建</span></span><br><span class="line"><span class="string">"watch:html"</span>: <span class="string">"watch 'npm run build:html' assets/html"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部署到 Amazon S3</span></span><br><span class="line"><span class="string">"deploy:prod"</span>: <span class="string">"s3-cli sync ./dist/ s3://example-com/prod-site/"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 favicon</span></span><br><span class="line"><span class="string">"build:favicon"</span>: <span class="string">"node scripts/favicon.js"</span>,</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener">npm scripts 使用指南</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lennonover" />
          <p class="site-author-name" itemprop="name">lennonover</p>
           
              <p class="site-description motion-element" itemprop="description">一丿口石砳磊</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">44</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lennonover</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
